{
  "Metadata": {
    "Title": "SPIR-V Specification Provisional",
    "Author": "John Kessenich, Google; Boaz Ouriel, Intel; Raun Krisch, Intel",
    "Revnumber": "version 1.1, Revision 5",
    "LastUpdate": "Last updated 2016-04-14 16:52:03 MDT"
  },
  "OpCodes": [
    {
      "Name": "OpNop",
      "Description": "<a id=\"OpNop\"></a><strong>OpNop</strong><br />\n<br />\n This has no semantic impact and can safely be removed from a module.",
      "DescriptionPlain": "OpNop\n\n This has no semantic impact and can safely be removed from a module.",
      "Category": "Miscellaneous",
      "Capabilities": [],
      "WordCount": "1",
      "WordCountFix": 1,
      "OpCode": 0,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpUndef",
      "Description": "<a id=\"OpUndef\"></a><strong>OpUndef</strong><br />\n<br />\nMake an <a href=\"#Intermediate\">intermediate</a> object whose value is undefined.<br />\n<br />\n<em>Result Type</em> is the type of object to make.<br />\n<br />\nEach consumption of <em>Result &lt;id&gt;</em> yields an arbitrary, possibly different bit pattern.",
      "DescriptionPlain": "OpUndef\n\nMake an intermediate object whose value is undefined.\n\nResult Type is the type of object to make.\n\nEach consumption of Result &lt;id&gt; yields an arbitrary, possibly different bit pattern.",
      "Category": "Miscellaneous",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 1,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSizeOf",
      "Description": "<a id=\"OpSizeOf\"></a><strong>OpSizeOf</strong><br />\n<br />\nComputes the run-time size of the type pointed to by <em>Pointer</em><br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pointer</em> must point to a concrete type.",
      "DescriptionPlain": "OpSizeOf\n\nComputes the run-time size of the type pointed to by Pointer\n\nResult Type must be a 32-bit integer type scalar.\n\nPointer must point to a concrete type.",
      "Category": "Miscellaneous",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 321,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSourceContinued",
      "Description": "<a id=\"OpSourceContinued\"></a><strong>OpSourceContinued</strong><br />\n<br />\nContinue specifying the <em>Source</em> text from the previous instruction. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Continued Source</em> is a continuation of the source text in the previous <em>Source</em>.<br />\n<br />\nThe previous instruction must be an <a href=\"#OpSource\"><strong>OpSource</strong></a> or an <strong>OpSourceContinued</strong> instruction. As is true for all literal strings, the previous instruction&#8217;s string was nul terminated. That terminating 0 word from the previous instruction is not part of the source text; the first character of <em>Continued Source</em> logically immediately follows the last character of <em>Source</em> before its nul.",
      "DescriptionPlain": "OpSourceContinued\n\nContinue specifying the Source text from the previous instruction. This has no semantic impact and can safely be removed from a module.\n\nContinued Source is a continuation of the source text in the previous Source.\n\nThe previous instruction must be an OpSource or an OpSourceContinued instruction. As is true for all literal strings, the previous instruction&#8217;s string was nul terminated. That terminating 0 word from the previous instruction is not part of the source text; the first character of Continued Source logically immediately follows the last character of Source before its nul.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 2,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "ContinuedSource",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpSource",
      "Description": "<a id=\"OpSource\"></a><strong>OpSource</strong><br />\n<br />\nDocument what <a href=\"#Source_Language\">source language</a> and text this module was translated from. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Version</em> is the version of the source language. This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<br />\n<em>File</em> is an <a href=\"#OpString\"><strong>OpString</strong></a> instruction and is the source-level file name.<br />\n<br />\n<em>Source</em> is the text of the source-level file.<br />\n<br />\nEach client API describes what form the <em>Version</em> operand takes, per source language.",
      "DescriptionPlain": "OpSource\n\nDocument what source language and text this module was translated from. This has no semantic impact and can safely be removed from a module.\n\nVersion is the version of the source language. This literal operand is limited to a single word.\n\nFile is an OpString instruction and is the source-level file name.\n\nSource is the text of the source-level file.\n\nEach client API describes what form the Version operand takes, per source language.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 3,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "SourceLanguage",
          "Type": "SourceLanguage"
        },
        {
          "Name": "Version",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Optional",
          "Type": "IDFile?"
        },
        {
          "Name": "Optional",
          "Type": "LiteralStringSource?"
        }
      ]
    },
    {
      "Name": "OpSourceExtension",
      "Description": "<a id=\"OpSourceExtension\"></a><strong>OpSourceExtension</strong><br />\n<br />\nDocument an extension to the source language. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Extension</em> is a string describing a source-language extension. Its form is dependent on the how the source language describes extensions.",
      "DescriptionPlain": "OpSourceExtension\n\nDocument an extension to the source language. This has no semantic impact and can safely be removed from a module.\n\nExtension is a string describing a source-language extension. Its form is dependent on the how the source language describes extensions.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 4,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Extension",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpName",
      "Description": "<a id=\"OpName\"></a><strong>OpName</strong><br />\n<br />\nAssign a name string to another instruction&#8217;s <em>Result &lt;id&gt;</em>. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Target</em> is the <em>Result &lt;id&gt;</em> to assign a name to. It can be the <em>Result &lt;id&gt;</em> of any other instruction; a variable, function, type, intermediate result, etc.<br />\n<br />\n<em>Name</em> is the string to assign.",
      "DescriptionPlain": "OpName\n\nAssign a name string to another instruction&#8217;s Result &lt;id&gt;. This has no semantic impact and can safely be removed from a module.\n\nTarget is the Result &lt;id&gt; to assign a name to. It can be the Result &lt;id&gt; of any other instruction; a variable, function, type, intermediate result, etc.\n\nName is the string to assign.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 5,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Target",
          "Type": "ID"
        },
        {
          "Name": "Name",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpMemberName",
      "Description": "<a id=\"OpMemberName\"></a><strong>OpMemberName</strong><br />\n<br />\nAssign a name string to a member of a structure type. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Type</em> is the <em>&lt;id&gt;</em> from an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> instruction.<br />\n<br />\n<em>Member</em> is the number of the member to assign in the structure. The first member is member 0, the next is member 1, &#8230; This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<br />\n<em>Name</em> is the string to assign to the member.",
      "DescriptionPlain": "OpMemberName\n\nAssign a name string to a member of a structure type. This has no semantic impact and can safely be removed from a module.\n\nType is the &lt;id&gt; from an OpTypeStruct instruction.\n\nMember is the number of the member to assign in the structure. The first member is member 0, the next is member 1, &#8230; This literal operand is limited to a single word.\n\nName is the string to assign to the member.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 6,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Type",
          "Type": "ID"
        },
        {
          "Name": "Member",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Name",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpString",
      "Description": "<a id=\"OpString\"></a><strong>OpString</strong><br />\n<br />\nAssign a <em>Result &lt;id&gt;</em> to a string for use by other debug instructions (see <a href=\"#OpLine\"><strong>OpLine</strong></a> and <a href=\"#OpSource\"><strong>OpSource</strong></a>). This has no semantic impact and can safely be removed from a module. (Removal also requires removal of all instructions referencing <em>Result &lt;id&gt;</em>.)<br />\n<br />\n<em>String</em> is the literal string being assigned a <em>Result &lt;id&gt;</em>.",
      "DescriptionPlain": "OpString\n\nAssign a Result &lt;id&gt; to a string for use by other debug instructions (see OpLine and OpSource). This has no semantic impact and can safely be removed from a module. (Removal also requires removal of all instructions referencing Result &lt;id&gt;.)\n\nString is the literal string being assigned a Result &lt;id&gt;.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 7,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "String",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpLine",
      "Description": "<a id=\"OpLine\"></a><strong>OpLine</strong><br />\n<br />\nAdd source-level location information. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n This location information applies to the instructions physically following this instruction, up to the first occurrence of any of the following: the next end of block, the next <strong>OpLine</strong> instruction, or the next <a href=\"#OpNoLine\"><strong>OpNoLine</strong></a> instruction.<br />\n<br />\n<em>File</em> must be an <a href=\"#OpString\"><strong>OpString</strong></a> instruction and is the source-level file name.<br />\n<br />\n<em>Line</em> is the source-level line number. This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<br />\n<em>Column</em> is the source-level column number. This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<br />\n<strong>OpLine</strong> can generally immediately precede other instructions, with the following exceptions:<br />\n<br />\n - it may not be used until after the <a href=\"#Annotation\">annotation</a> instructions,<br />\n   (see the <a href=\"#LogicalLayout\">Logical Layout</a> section)<br />\n<br />\n - cannot be the last instruction in a block, which is defined to end with a <a href=\"#Termination\">termination instruction</a><br />\n<br />\n - if a branch <a href=\"#Merge\">merge instruction</a> is used, the last <strong>OpLine</strong> in the block must be before its merge instruction",
      "DescriptionPlain": "OpLine\n\nAdd source-level location information. This has no semantic impact and can safely be removed from a module.\n\n This location information applies to the instructions physically following this instruction, up to the first occurrence of any of the following: the next end of block, the next OpLine instruction, or the next OpNoLine instruction.\n\nFile must be an OpString instruction and is the source-level file name.\n\nLine is the source-level line number. This literal operand is limited to a single word.\n\nColumn is the source-level column number. This literal operand is limited to a single word.\n\nOpLine can generally immediately precede other instructions, with the following exceptions:\n\n - it may not be used until after the annotation instructions,\n   (see the Logical Layout section)\n\n - cannot be the last instruction in a block, which is defined to end with a termination instruction\n\n - if a branch merge instruction is used, the last OpLine in the block must be before its merge instruction",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 8,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "File",
          "Type": "ID"
        },
        {
          "Name": "Line",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Column",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpNoLine",
      "Description": "<a id=\"OpNoLine\"></a><strong>OpNoLine</strong><br />\n<br />\nDiscontinue any source-level location information that might be active from a previous <a href=\"#OpLine\"><strong>OpLine</strong></a> instruction. This has no semantic impact and can safely be removed from a module.<br />\n<br />\nThis instruction can only appear after the <a href=\"#Annotation\">annotation</a> instructions (see the <a href=\"#LogicalLayout\">Logical Layout</a> section). It cannot be the last instruction in a block, or the second-to-last instruction if the block has a <a href=\"#Merge\">merge instruction</a>. There is not a requirement that there is a preceding <strong>OpLine</strong> instruction.",
      "DescriptionPlain": "OpNoLine\n\nDiscontinue any source-level location information that might be active from a previous OpLine instruction. This has no semantic impact and can safely be removed from a module.\n\nThis instruction can only appear after the annotation instructions (see the Logical Layout section). It cannot be the last instruction in a block, or the second-to-last instruction if the block has a merge instruction. There is not a requirement that there is a preceding OpLine instruction.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "1",
      "WordCountFix": 1,
      "OpCode": 317,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpModuleProcessed",
      "Description": "<a id=\"OpModuleProcessed\"></a><strong>OpModuleProcessed</strong><br />\n<br />\nDocument a process that was applied to a module. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Process</em> is a string describing a process and/or tool (processor) that did the processing. Its form is dependent on the processor.",
      "DescriptionPlain": "OpModuleProcessed\n\nDocument a process that was applied to a module. This has no semantic impact and can safely be removed from a module.\n\nProcess is a string describing a process and/or tool (processor) that did the processing. Its form is dependent on the processor.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 330,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Process",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpDecorate",
      "Description": "<a id=\"OpDecorate\"></a><strong>OpDecorate</strong><br />\n<br />\nAdd a <a href=\"#Decoration\">Decoration</a> to another <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Target</em> is the <em>&lt;id&gt;</em> to decorate.  It can potentially be any <em>&lt;id&gt;</em> that is a forward reference. A set of decorations can be grouped together by having multiple <strong>OpDecorate</strong> instructions target the same <a href=\"#OpDecorationGroup\"><strong>OpDecorationGroup</strong></a> instruction.",
      "DescriptionPlain": "OpDecorate\n\nAdd a Decoration to another &lt;id&gt;.\n\nTarget is the &lt;id&gt; to decorate.  It can potentially be any &lt;id&gt; that is a forward reference. A set of decorations can be grouped together by having multiple OpDecorate instructions target the same OpDecorationGroup instruction.",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 71,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Target",
          "Type": "ID"
        },
        {
          "Name": "Decoration",
          "Type": "Decoration"
        },
        {
          "Name": null,
          "Type": null
        }
      ]
    },
    {
      "Name": "OpMemberDecorate",
      "Description": "<a id=\"OpMemberDecorate\"></a><strong>OpMemberDecorate</strong><br />\n<br />\nAdd a <a href=\"#Decoration\">Decoration</a> to a member of a structure type.<br />\n<br />\n<em>Structure type</em> is the <em>&lt;id&gt;</em> of a type from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.<br />\n<br />\n<em>Member</em> is the number of the member to decorate in the type. The first member is member 0, the next is member 1, &#8230;<br />\n<br />\nNote: See <strong>OpDecorate</strong> for creating groups of decorations for consumption by <strong>OpGroupMemberDecorate</strong>",
      "DescriptionPlain": "OpMemberDecorate\n\nAdd a Decoration to a member of a structure type.\n\nStructure type is the &lt;id&gt; of a type from OpTypeStruct.\n\nMember is the number of the member to decorate in the type. The first member is member 0, the next is member 1, &#8230;\n\nNote: See OpDecorate for creating groups of decorations for consumption by OpGroupMemberDecorate",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 72,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "StructureType",
          "Type": "ID"
        },
        {
          "Name": "Member",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Decoration",
          "Type": "Decoration"
        },
        {
          "Name": null,
          "Type": null
        }
      ]
    },
    {
      "Name": "OpDecorationGroup",
      "Description": "<a id=\"OpDecorationGroup\"></a><strong>OpDecorationGroup</strong><br />\n<br />\nA collector for <a href=\"#Decoration\">Decorations</a> from <a href=\"#OpDecorate\"><strong>OpDecorate</strong></a> instructions. All such <strong>OpDecorate</strong> instructions targeting this <strong>OpDecorationGroup</strong> instruction must precede it. Subsequent <a href=\"#OpGroupDecorate\"><strong>OpGroupDecorate</strong></a> and <a href=\"#OpGroupMemberDecorate\"><strong>OpGroupMemberDecorate</strong></a> instructions that consume this instruction&#8217;s <em>Result &lt;id&gt;</em> will apply these decorations to their targets.",
      "DescriptionPlain": "OpDecorationGroup\n\nA collector for Decorations from OpDecorate instructions. All such OpDecorate instructions targeting this OpDecorationGroup instruction must precede it. Subsequent OpGroupDecorate and OpGroupMemberDecorate instructions that consume this instruction&#8217;s Result &lt;id&gt; will apply these decorations to their targets.",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 73,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupDecorate",
      "Description": "<a id=\"OpGroupDecorate\"></a><strong>OpGroupDecorate</strong><br />\n<br />\nAdd a group of <a href=\"#Decoration\">Decorations</a> to another <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Decoration Group</em> is the <em>&lt;id&gt;</em> of an <a href=\"#OpDecorationGroup\"><strong>OpDecorationGroup</strong></a> instruction.<br />\n<br />\n<em>Targets</em> is a list of <em>&lt;id&gt;s</em> to decorate with the groups of decorations.",
      "DescriptionPlain": "OpGroupDecorate\n\nAdd a group of Decorations to another &lt;id&gt;.\n\nDecoration Group is the &lt;id&gt; of an OpDecorationGroup instruction.\n\nTargets is a list of &lt;id&gt;s to decorate with the groups of decorations.",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 74,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "DecorationGroup",
          "Type": "ID"
        },
        {
          "Name": "Targets",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpGroupMemberDecorate",
      "Description": "<a id=\"OpGroupMemberDecorate\"></a><strong>OpGroupMemberDecorate</strong><br />\n<br />\nAdd a group of <a href=\"#Decoration\">Decorations</a> to members of structure types.<br />\n<br />\n<em>Decoration Group</em> is the <em>&lt;id&gt;</em> of an <a href=\"#OpDecorationGroup\"><strong>OpDecorationGroup</strong></a> instruction.<br />\n<br />\n<em>Targets</em> is a list of (<em>&lt;id&gt;</em>, <em>Member</em>) pairs to decorate with the groups of decorations. Each <em>&lt;id&gt;</em> in the pair must be a target structure type, and the associated <em>Member</em> is the number of the member to decorate in the type. The first member is member 0, the next is member 1, &#8230;",
      "DescriptionPlain": "OpGroupMemberDecorate\n\nAdd a group of Decorations to members of structure types.\n\nDecoration Group is the &lt;id&gt; of an OpDecorationGroup instruction.\n\nTargets is a list of (&lt;id&gt;, Member) pairs to decorate with the groups of decorations. Each &lt;id&gt; in the pair must be a target structure type, and the associated Member is the number of the member to decorate in the type. The first member is member 0, the next is member 1, &#8230;",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 75,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "DecorationGroup",
          "Type": "ID"
        },
        {
          "Name": "<id>s",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpExtension",
      "Description": "<a id=\"OpExtension\"></a><strong>OpExtension</strong><br />\n<br />\nDeclare use of an extension to SPIR-V. This allows validation of additional instructions, tokens, semantics, etc.<br />\n<br />\n<em>Name</em> is the extension&#8217;s name string.",
      "DescriptionPlain": "OpExtension\n\nDeclare use of an extension to SPIR-V. This allows validation of additional instructions, tokens, semantics, etc.\n\nName is the extension&#8217;s name string.",
      "Category": "Extension",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 10,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Name",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpExtInstImport",
      "Description": "<a id=\"OpExtInstImport\"></a><strong>OpExtInstImport</strong><br />\n<br />\nImport an extended set of instructions. It can be later referenced by the <em>Result &lt;id&gt;</em>.<br />\n<br />\n<em>Name</em> is the extended instruction-set&#8217;s name string. There must be an external specification defining the semantics for this extended instruction set.<br />\n<br />\nSee <a href=\"#ExtInst\">Extended Instruction Sets</a> for more information.",
      "DescriptionPlain": "OpExtInstImport\n\nImport an extended set of instructions. It can be later referenced by the Result &lt;id&gt;.\n\nName is the extended instruction-set&#8217;s name string. There must be an external specification defining the semantics for this extended instruction set.\n\nSee Extended Instruction Sets for more information.",
      "Category": "Extension",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 11,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Name",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpExtInst",
      "Description": "<a id=\"OpExtInst\"></a><strong>OpExtInst</strong><br />\n<br />\nExecute an instruction in an imported set of extended instructions.<br />\n<br />\n<em>Result Type</em> is as defined, per <em>Instruction</em>, in the external specification for <em>Set</em>.<br />\n<br />\n<em>Set</em> is the result of an <a href=\"#OpExtInstImport\"><strong>OpExtInstImport</strong></a> instruction.<br />\n<br />\n<em>Instruction</em> is the enumerant of the instruction to execute within <em>Set</em>. This literal operand is limited to a single <a href=\"#Word\">word</a>. The semantics of the instruction must be defined in the external specification for <em>Set</em>.<br />\n<br />\n<em>Operand 1, &#8230;</em> are the operands to the extended instruction.",
      "DescriptionPlain": "OpExtInst\n\nExecute an instruction in an imported set of extended instructions.\n\nResult Type is as defined, per Instruction, in the external specification for Set.\n\nSet is the result of an OpExtInstImport instruction.\n\nInstruction is the enumerant of the instruction to execute within Set. This literal operand is limited to a single word. The semantics of the instruction must be defined in the external specification for Set.\n\nOperand 1, &#8230; are the operands to the extended instruction.",
      "Category": "Extension",
      "Capabilities": [],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 12,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Set",
          "Type": "ID"
        },
        {
          "Name": "Instruction",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Operands",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpMemoryModel",
      "Description": "<a id=\"OpMemoryModel\"></a><strong>OpMemoryModel</strong><br />\n<br />\nSet addressing model and memory model for the entire module.<br />\n<br />\n<em>Addressing Model</em> selects the module&#8217;s <a href=\"#Addressing_Model\"><strong>Addressing Model</strong></a>.<br />\n<br />\n<em>Memory Model</em> selects the module&#8217;s memory model, see <a href=\"#Memory_Model\"><strong>Memory Model</strong></a>.",
      "DescriptionPlain": "OpMemoryModel\n\nSet addressing model and memory model for the entire module.\n\nAddressing Model selects the module&#8217;s Addressing Model.\n\nMemory Model selects the module&#8217;s memory model, see Memory Model.",
      "Category": "Mode-Setting",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 14,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "AddressingModel",
          "Type": "AddressingModel"
        },
        {
          "Name": "MemoryModel",
          "Type": "MemoryModel"
        }
      ]
    },
    {
      "Name": "OpEntryPoint",
      "Description": "<a id=\"OpEntryPoint\"></a><strong>OpEntryPoint</strong><br />\n<br />\nDeclare an <a href=\"#EntryPoint\">entry point</a> and its execution model.<br />\n<br />\n<em>Execution Model</em> is the execution model for the entry point and its static call tree.  See <a href=\"#Execution_Model\">Execution Model</a>.<br />\n<br />\n<em>Entry Point</em> must be the <em>Result &lt;id&gt;</em> of an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.<br />\n<br />\n<em>Name</em> is a name string for the entry point. A module cannot have two <strong>OpEntryPoint</strong> instructions with the same <a href=\"#Execution_Model\">Execution Model</a> and the same <em>Name</em> string.<br />\n<br />\n<em>Interface</em> is a list of <em>&lt;id&gt;</em> of global <a href=\"#OpVariable\"><strong>OpVariable</strong></a> instructions with either <strong>Input</strong> or <strong>Output</strong> for its <a href=\"#Storage_Class\">Storage Class</a> operand. These declare the input/output interface of the entry point.  They could be a subset of the input/output declarations of the module, and a superset of those referenced by the entry point&#8217;s static call tree. It is invalid for the entry point&#8217;s static call tree to reference such an <em>&lt;id&gt;</em> if it was not listed with this instruction.<br />\n<br />\n<em>Interface</em> <em>&lt;id&gt;</em> are forward references.  They allow declaration of all variables forming an interface for an entry point, whether or not all the variables are actually used by the entry point.",
      "DescriptionPlain": "OpEntryPoint\n\nDeclare an entry point and its execution model.\n\nExecution Model is the execution model for the entry point and its static call tree.  See Execution Model.\n\nEntry Point must be the Result &lt;id&gt; of an OpFunction instruction.\n\nName is a name string for the entry point. A module cannot have two OpEntryPoint instructions with the same Execution Model and the same Name string.\n\nInterface is a list of &lt;id&gt; of global OpVariable instructions with either Input or Output for its Storage Class operand. These declare the input/output interface of the entry point.  They could be a subset of the input/output declarations of the module, and a superset of those referenced by the entry point&#8217;s static call tree. It is invalid for the entry point&#8217;s static call tree to reference such an &lt;id&gt; if it was not listed with this instruction.\n\nInterface &lt;id&gt; are forward references.  They allow declaration of all variables forming an interface for an entry point, whether or not all the variables are actually used by the entry point.",
      "Category": "Mode-Setting",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 15,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "ExecutionModel",
          "Type": "ExecutionModel"
        },
        {
          "Name": "EntryPoint",
          "Type": "ID"
        },
        {
          "Name": "Name",
          "Type": "LiteralString"
        },
        {
          "Name": "Interfaces",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpExecutionMode",
      "Description": "<a id=\"OpExecutionMode\"></a><strong>OpExecutionMode</strong><br />\n<br />\nDeclare an execution mode for an entry point.<br />\n<br />\n<em>Entry Point</em> must be the <em>Entry Point &lt;id&gt;</em> operand of an <a href=\"#OpEntryPoint\"><strong>OpEntryPoint</strong></a> instruction.<br />\n<br />\n<em>Mode</em> is the execution mode. See <a href=\"#Execution_Mode\">Execution Mode</a>.",
      "DescriptionPlain": "OpExecutionMode\n\nDeclare an execution mode for an entry point.\n\nEntry Point must be the Entry Point &lt;id&gt; operand of an OpEntryPoint instruction.\n\nMode is the execution mode. See Execution Mode.",
      "Category": "Mode-Setting",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 16,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "EntryPoint",
          "Type": "ID"
        },
        {
          "Name": "Mode",
          "Type": "ExecutionMode"
        },
        {
          "Name": "Optional",
          "Type": "Literal(s)SeeExecutionMode?"
        }
      ]
    },
    {
      "Name": "OpCapability",
      "Description": "<a id=\"OpCapability\"></a><strong>OpCapability</strong><br />\n<br />\nDeclare a capability used by this module.<br />\n<br />\n<em>Capability</em> is the <a href=\"#Capability\">capability</a> declared by this instruction.  There are no restrictions on the order in which capabilities are declared.<br />\n<br />\nSee the <a href=\"#Capabilities\">capabilities section</a> for more detail.",
      "DescriptionPlain": "OpCapability\n\nDeclare a capability used by this module.\n\nCapability is the capability declared by this instruction.  There are no restrictions on the order in which capabilities are declared.\n\nSee the capabilities section for more detail.",
      "Category": "Mode-Setting",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 17,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "<null>",
          "Type": "<null>"
        }
      ]
    },
    {
      "Name": "OpTypeVoid",
      "Description": "<a id=\"OpTypeVoid\"></a><strong>OpTypeVoid</strong><br />\n<br />\nDeclare the void type.",
      "DescriptionPlain": "OpTypeVoid\n\nDeclare the void type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 19,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeBool",
      "Description": "<a id=\"OpTypeBool\"></a><strong>OpTypeBool</strong><br />\n<br />\nDeclare the <a href=\"#Boolean\"><em>Boolean type</em></a>.  Values of this type can only be either <strong>true</strong> or <strong>false</strong>. There is no physical size or bit pattern defined for these values.  If they are stored (in conjunction with <a href=\"#OpVariable\"><strong>OpVariable</strong></a>), they can only be used with logical addressing operations, not physical, and only with non-externally visible shader <a href=\"#Storage_Class\">Storage Classes</a>: <strong>Workgroup</strong>, <strong>CrossWorkgroup</strong>, <strong>Private</strong>, and <strong>Function</strong>.",
      "DescriptionPlain": "OpTypeBool\n\nDeclare the Boolean type.  Values of this type can only be either true or false. There is no physical size or bit pattern defined for these values.  If they are stored (in conjunction with OpVariable), they can only be used with logical addressing operations, not physical, and only with non-externally visible shader Storage Classes: Workgroup, CrossWorkgroup, Private, and Function.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 20,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeInt",
      "Description": "<a id=\"OpTypeInt\"></a><strong>OpTypeInt</strong><br />\n<br />\nDeclare a new <a href=\"#Integer\"><em>integer type</em></a>.<br />\n<br />\n<em>Width</em> specifies how many bits wide the type is. This literal operand is limited to a single <a href=\"#Word\">word</a>. The bit pattern of a signed integer value is two&#8217;s complement.<br />\n<br />\n<em>Signedness</em> specifies whether there are signed semantics to preserve or validate.<br />\n0 indicates unsigned, or no signedness semantics<br />\n1 indicates signed semantics.<br />\nIn all cases, the type of operation of an instruction comes from the instruction&#8217;s opcode, not the signedness of the operands.",
      "DescriptionPlain": "OpTypeInt\n\nDeclare a new integer type.\n\nWidth specifies how many bits wide the type is. This literal operand is limited to a single word. The bit pattern of a signed integer value is two&#8217;s complement.\n\nSignedness specifies whether there are signed semantics to preserve or validate.\n0 indicates unsigned, or no signedness semantics\n1 indicates signed semantics.\nIn all cases, the type of operation of an instruction comes from the instruction&#8217;s opcode, not the signedness of the operands.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 21,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Width",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Signedness",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpTypeFloat",
      "Description": "<a id=\"OpTypeFloat\"></a><strong>OpTypeFloat</strong><br />\n<br />\nDeclare a new <a href=\"#Floating\"><em>floating-point type</em></a>.<br />\n<br />\n<em>Width</em> specifies how many bits wide the type is. The bit pattern of a floating-point value is as described by the IEEE 754 standard.",
      "DescriptionPlain": "OpTypeFloat\n\nDeclare a new floating-point type.\n\nWidth specifies how many bits wide the type is. The bit pattern of a floating-point value is as described by the IEEE 754 standard.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 22,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Width",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpTypeVector",
      "Description": "<a id=\"OpTypeVector\"></a><strong>OpTypeVector</strong><br />\n<br />\nDeclare a new <a href=\"#Vector\">vector type</a>.<br />\n<br />\n<em>Component Type</em> is the type of each component in the resulting type.  It must be a <a href=\"#Scalar\">scalar type</a>.<br />\n<br />\n<em>Component Count</em> is the number of components in the resulting type.  It must be at least 2.<br />\n<br />\nComponents are numbered consecutively, starting with 0.",
      "DescriptionPlain": "OpTypeVector\n\nDeclare a new vector type.\n\nComponent Type is the type of each component in the resulting type.  It must be a scalar type.\n\nComponent Count is the number of components in the resulting type.  It must be at least 2.\n\nComponents are numbered consecutively, starting with 0.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 23,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ComponentType",
          "Type": "ID"
        },
        {
          "Name": "ComponentCount",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpTypeMatrix",
      "Description": "<a id=\"OpTypeMatrix\"></a><strong>OpTypeMatrix</strong><br />\n<br />\nDeclare a new matrix type.<br />\n<br />\n<em>Column Type</em> is the type of each column in the matrix.  It must be vector type.<br />\n<br />\n<em>Column Count</em> is the number of columns in the new matrix type. It must be at least 2.<br />\n<br />\nMatrix columns are numbered consecutively, starting with 0. This is true independently of any <a href=\"#Decoration\">Decorations</a> describing the memory layout of a matrix (e.g., <strong>RowMajor</strong> or <strong>MatrixStride</strong>).",
      "DescriptionPlain": "OpTypeMatrix\n\nDeclare a new matrix type.\n\nColumn Type is the type of each column in the matrix.  It must be vector type.\n\nColumn Count is the number of columns in the new matrix type. It must be at least 2.\n\nMatrix columns are numbered consecutively, starting with 0. This is true independently of any Decorations describing the memory layout of a matrix (e.g., RowMajor or MatrixStride).",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 24,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ColumnType",
          "Type": "ID"
        },
        {
          "Name": "ColumnCount",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpTypeImage",
      "Description": "<a id=\"OpTypeImage\"></a><strong>OpTypeImage</strong><br />\n<br />\nDeclare a new <a href=\"#ImageTerm\">image</a> type. Consumed, for example, by <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. This type is opaque: values of this type have no defined physical size or bit pattern.<br />\n<br />\n<em>Sampled Type</em> is the type of the components that result from sampling or reading from this image type. Must be a scalar <a href=\"#Numerical\">numerical type</a> or <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n<br />\n<em>Dim</em> is the image <a href=\"#Dim\">dimensionality</a> (Dim).<br />\n<br />\n<em>Depth</em> is whether or not this image is a depth image. (Note that whether or not depth comparisons are actually done is a property of the sampling opcode, not of this type declaration.)<br />\n0 indicates not a depth image<br />\n1 indicates a depth image<br />\n2 means no indication as to whether this is a depth or non-depth image<br />\n<br />\n<em>Arrayed</em> must be one of the following indicated values:<br />\n0 indicates non-arrayed content<br />\n1 indicates arrayed content<br />\n<br />\n<em>MS</em> must be one of the following indicated values:<br />\n0 indicates single-sampled content<br />\n1 indicates multisampled content<br />\n<br />\n<em>Sampled</em> indicates whether or not this image will be accessed in combination with a <a href=\"#Sampler\">sampler</a>, and must be one of the following values:<br />\n0 indicates this is only known at run time, not at compile time<br />\n1 indicates will be used with sampler<br />\n2 indicates will be used without a sampler (a storage image)<br />\n<br />\n<em>Image Format</em> is the <a href=\"#Image_Format\">Image Format</a>, which can be <strong>Unknown</strong>, depending on the client API.<br />\n<br />\nIf <a href=\"#Dim\"><em>Dim</em></a> is <strong>SubpassData</strong>, <em>Sampled</em> must be 2, <em>Image Format</em> must be <strong>Unknown</strong>, and the <a href=\"#Execution_Model\">Execution Model</a> must be <strong>Fragment</strong>.<br />\n<br />\n<em>Access Qualifier</em> is an image <a href=\"#Access_Qualifier\"><strong>Access Qualifier</strong></a>.",
      "DescriptionPlain": "OpTypeImage\n\nDeclare a new image type. Consumed, for example, by OpTypeSampledImage. This type is opaque: values of this type have no defined physical size or bit pattern.\n\nSampled Type is the type of the components that result from sampling or reading from this image type. Must be a scalar numerical type or OpTypeVoid.\n\nDim is the image dimensionality (Dim).\n\nDepth is whether or not this image is a depth image. (Note that whether or not depth comparisons are actually done is a property of the sampling opcode, not of this type declaration.)\n0 indicates not a depth image\n1 indicates a depth image\n2 means no indication as to whether this is a depth or non-depth image\n\nArrayed must be one of the following indicated values:\n0 indicates non-arrayed content\n1 indicates arrayed content\n\nMS must be one of the following indicated values:\n0 indicates single-sampled content\n1 indicates multisampled content\n\nSampled indicates whether or not this image will be accessed in combination with a sampler, and must be one of the following values:\n0 indicates this is only known at run time, not at compile time\n1 indicates will be used with sampler\n2 indicates will be used without a sampler (a storage image)\n\nImage Format is the Image Format, which can be Unknown, depending on the client API.\n\nIf Dim is SubpassData, Sampled must be 2, Image Format must be Unknown, and the Execution Model must be Fragment.\n\nAccess Qualifier is an image Access Qualifier.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "9 + variable",
      "WordCountFix": 9,
      "OpCode": 25,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledType",
          "Type": "ID"
        },
        {
          "Name": "Dim",
          "Type": "Dim"
        },
        {
          "Name": "Depth",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Arrayed",
          "Type": "LiteralNumber"
        },
        {
          "Name": "MS",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Sampled",
          "Type": "LiteralNumber"
        },
        {
          "Name": "ImageFormat",
          "Type": "ImageFormat"
        },
        {
          "Name": "Optional",
          "Type": "AccessQualifier?"
        }
      ]
    },
    {
      "Name": "OpTypeSampler",
      "Description": "<a id=\"OpTypeSampler\"></a><strong>OpTypeSampler</strong><br />\n<br />\nDeclare the <a href=\"#Sampler\">sampler</a> type. Consumed by <a href=\"#OpSampledImage\"><strong>OpSampledImage</strong></a>. This type is opaque: values of this type have no defined physical size or bit pattern.",
      "DescriptionPlain": "OpTypeSampler\n\nDeclare the sampler type. Consumed by OpSampledImage. This type is opaque: values of this type have no defined physical size or bit pattern.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 26,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeSampledImage",
      "Description": "<a id=\"OpTypeSampledImage\"></a><strong>OpTypeSampledImage</strong><br />\n<br />\nDeclare a <a href=\"#SampledImage\">sampled image</a> type, the <em>Result Type</em> of <a href=\"#OpSampledImage\"><strong>OpSampledImage</strong></a>, or an externally combined sampler and image. This type is opaque: values of this type have no defined physical size or bit pattern.<br />\n<br />\n<em>Image Type</em> must be an <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.  It is the type of the image in the combined sampler and image type.",
      "DescriptionPlain": "OpTypeSampledImage\n\nDeclare a sampled image type, the Result Type of OpSampledImage, or an externally combined sampler and image. This type is opaque: values of this type have no defined physical size or bit pattern.\n\nImage Type must be an OpTypeImage.  It is the type of the image in the combined sampler and image type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 27,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ImageType",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeArray",
      "Description": "<a id=\"OpTypeArray\"></a><strong>OpTypeArray</strong><br />\n<br />\nDeclare a new array type: a dynamically-indexable ordered aggregate of elements all having the same type.<br />\n<br />\n<em>Element Type</em> is the type of each element in the array.<br />\n<br />\n<em>Length</em> is the number of elements in the array.  It must be at least 1. <em>Length</em> must come from a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of an <a href=\"#Integer\"><em>integer-type</em></a> scalar whose value is at least 1.<br />\n<br />\nArray elements are number consecutively, starting with 0.",
      "DescriptionPlain": "OpTypeArray\n\nDeclare a new array type: a dynamically-indexable ordered aggregate of elements all having the same type.\n\nElement Type is the type of each element in the array.\n\nLength is the number of elements in the array.  It must be at least 1. Length must come from a constant instruction of an integer-type scalar whose value is at least 1.\n\nArray elements are number consecutively, starting with 0.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 28,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ElementType",
          "Type": "ID"
        },
        {
          "Name": "Length",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeRuntimeArray",
      "Description": "<a id=\"OpTypeRuntimeArray\"></a><strong>OpTypeRuntimeArray</strong><br />\n<br />\nDeclare a new run-time array type.  Its length is not known at compile time.<br />\n<br />\n<em>Element Type</em> is the type of each element in the array. It must be a <a href=\"#Concrete\">concrete</a> type.<br />\n<br />\n See <a href=\"#OpArrayLength\"><strong>OpArrayLength</strong></a> for getting the <em>Length</em> of an array of this type.<br />\n<br />\n<a href=\"#Object\">Objects</a> of this type can only be created with <a href=\"#OpVariable\"><strong>OpVariable</strong></a> using the <strong>Uniform</strong> <a href=\"#Storage_Class\">Storage Class</a>.",
      "DescriptionPlain": "OpTypeRuntimeArray\n\nDeclare a new run-time array type.  Its length is not known at compile time.\n\nElement Type is the type of each element in the array. It must be a concrete type.\n\n See OpArrayLength for getting the Length of an array of this type.\n\nObjects of this type can only be created with OpVariable using the Uniform Storage Class.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 29,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ElementType",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeStruct",
      "Description": "<a id=\"OpTypeStruct\"></a><strong>OpTypeStruct</strong><br />\n<br />\nDeclare a new structure type: an aggregate of potentially heterogeneous members.<br />\n<br />\n<em>Member N type</em> is the type of member <em>N</em> of the structure. The first member is member 0, the next is member 1, &#8230;<br />\n<br />\nIf an operand is not yet defined, it must be defined by an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>, where the type pointed to is an <strong>OpTypeStruct</strong>.",
      "DescriptionPlain": "OpTypeStruct\n\nDeclare a new structure type: an aggregate of potentially heterogeneous members.\n\nMember N type is the type of member N of the structure. The first member is member 0, the next is member 1, &#8230;\n\nIf an operand is not yet defined, it must be defined by an OpTypePointer, where the type pointed to is an OpTypeStruct.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 30,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Members",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpTypeOpaque",
      "Description": "<a id=\"OpTypeOpaque\"></a><strong>OpTypeOpaque</strong><br />\n<br />\nDeclare a structure type with no body specified.",
      "DescriptionPlain": "OpTypeOpaque\n\nDeclare a structure type with no body specified.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 31,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "TheNameOfTheOpaqueType",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpTypePointer",
      "Description": "<a id=\"OpTypePointer\"></a><strong>OpTypePointer</strong><br />\n<br />\nDeclare a new pointer type.<br />\n<br />\n<em>Storage Class</em> is the <a href=\"#Storage_Class\">Storage Class</a> of the memory holding the object pointed to. If there was a forward reference to this type from an <a href=\"#OpTypeForwardPointer\"><strong>OpTypeForwardPointer</strong></a>, the <em>Storage Class</em> of that instruction must equal the <em>Storage Class</em> of this instruction.<br />\n<br />\n<em>Type</em> is the type of the object pointed to.",
      "DescriptionPlain": "OpTypePointer\n\nDeclare a new pointer type.\n\nStorage Class is the Storage Class of the memory holding the object pointed to. If there was a forward reference to this type from an OpTypeForwardPointer, the Storage Class of that instruction must equal the Storage Class of this instruction.\n\nType is the type of the object pointed to.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 32,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "StorageClass",
          "Type": "StorageClass"
        },
        {
          "Name": "Type",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeFunction",
      "Description": "<a id=\"OpTypeFunction\"></a><strong>OpTypeFunction</strong><br />\n<br />\nDeclare a new function type.<br />\n<br />\n<a href=\"#OpFunction\"><strong>OpFunction</strong></a> will use this to declare the return type and parameter types of a function. <strong>OpFunction</strong> is the only valid use of <strong>OpTypeFunction</strong>.<br />\n<br />\n<em>Return Type</em> is the type of the return value of functions of this type. It must be a <a href=\"#Concrete\">concrete</a> or <a href=\"#Abstract\">abstract</a> type, or a pointer to such a type. If the function has no return value, <em>Return Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n<br />\n<em>Parameter N Type</em> is the type <em>&lt;id&gt;</em> of the type of parameter <em>N</em>.",
      "DescriptionPlain": "OpTypeFunction\n\nDeclare a new function type.\n\nOpFunction will use this to declare the return type and parameter types of a function. OpFunction is the only valid use of OpTypeFunction.\n\nReturn Type is the type of the return value of functions of this type. It must be a concrete or abstract type, or a pointer to such a type. If the function has no return value, Return Type must be OpTypeVoid.\n\nParameter N Type is the type &lt;id&gt; of the type of parameter N.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 33,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ReturnType",
          "Type": "ID"
        },
        {
          "Name": "Parameters",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpTypeEvent",
      "Description": "<a id=\"OpTypeEvent\"></a><strong>OpTypeEvent</strong><br />\n<br />\nDeclare an OpenCL event type.",
      "DescriptionPlain": "OpTypeEvent\n\nDeclare an OpenCL event type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 34,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeDeviceEvent",
      "Description": "<a id=\"OpTypeDeviceEvent\"></a><strong>OpTypeDeviceEvent</strong><br />\n<br />\nDeclare an OpenCL device-side event type.",
      "DescriptionPlain": "OpTypeDeviceEvent\n\nDeclare an OpenCL device-side event type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 35,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeReserveId",
      "Description": "<a id=\"OpTypeReserveId\"></a><strong>OpTypeReserveId</strong><br />\n<br />\nDeclare an OpenCL reservation id type.",
      "DescriptionPlain": "OpTypeReserveId\n\nDeclare an OpenCL reservation id type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 36,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeQueue",
      "Description": "<a id=\"OpTypeQueue\"></a><strong>OpTypeQueue</strong><br />\n<br />\nDeclare an OpenCL queue type.",
      "DescriptionPlain": "OpTypeQueue\n\nDeclare an OpenCL queue type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 37,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypePipe",
      "Description": "<a id=\"OpTypePipe\"></a><strong>OpTypePipe</strong><br />\n<br />\nDeclare an OpenCL pipe type.<br />\n<br />\n<em>Qualifier</em> is the pipe access qualifier.",
      "DescriptionPlain": "OpTypePipe\n\nDeclare an OpenCL pipe type.\n\nQualifier is the pipe access qualifier.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 38,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Qualifier",
          "Type": "AccessQualifier"
        }
      ]
    },
    {
      "Name": "OpTypeForwardPointer",
      "Description": "<a id=\"OpTypeForwardPointer\"></a><strong>OpTypeForwardPointer</strong><br />\n<br />\nDeclare the Storage Class for a forward reference to a pointer.<br />\n<br />\n<em>Pointer Type</em> is a forward reference to the result of an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. The type of object the pointer points to is declared by the <strong>OpTypePointer</strong> instruction, not this instruction. Subsequent <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> instructions can use <em>Pointer Type</em> as an operand.<br />\n<br />\n<em>Storage Class</em> is the <a href=\"#Storage_Class\">Storage Class</a> of the memory holding the object pointed to.",
      "DescriptionPlain": "OpTypeForwardPointer\n\nDeclare the Storage Class for a forward reference to a pointer.\n\nPointer Type is a forward reference to the result of an OpTypePointer. The type of object the pointer points to is declared by the OpTypePointer instruction, not this instruction. Subsequent OpTypeStruct instructions can use Pointer Type as an operand.\n\nStorage Class is the Storage Class of the memory holding the object pointed to.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 39,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "PointerType",
          "Type": "ID"
        },
        {
          "Name": "StorageClass",
          "Type": "StorageClass"
        }
      ]
    },
    {
      "Name": "OpTypePipeStorage",
      "Description": "<a id=\"OpTypePipeStorage\"></a><strong>OpTypePipeStorage</strong><br />\n<br />\nDeclare the OpenCL pipe-storage type.",
      "DescriptionPlain": "OpTypePipeStorage\n\nDeclare the OpenCL pipe-storage type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 322,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeNamedBarrier",
      "Description": "<a id=\"OpTypeNamedBarrier\"></a><strong>OpTypeNamedBarrier</strong><br />\n<br />\nDeclare the named-barrier type.",
      "DescriptionPlain": "OpTypeNamedBarrier\n\nDeclare the named-barrier type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 327,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConstantTrue",
      "Description": "<a id=\"OpConstantTrue\"></a><strong>OpConstantTrue</strong><br />\n<br />\nDeclare a <strong>true</strong> <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar constant.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.",
      "DescriptionPlain": "OpConstantTrue\n\nDeclare a true Boolean-type scalar constant.\n\nResult Type must be the scalar Boolean type.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 41,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConstantFalse",
      "Description": "<a id=\"OpConstantFalse\"></a><strong>OpConstantFalse</strong><br />\n<br />\nDeclare a <strong>false</strong> <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar constant.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.",
      "DescriptionPlain": "OpConstantFalse\n\nDeclare a false Boolean-type scalar constant.\n\nResult Type must be the scalar Boolean type.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 42,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConstant",
      "Description": "<a id=\"OpConstant\"></a><strong>OpConstant</strong><br />\n<br />\nDeclare a new <a href=\"#Integer\"><em>integer-type</em></a> or <a href=\"#Floating\"><em>floating-point-type</em></a> scalar constant.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.<br />\n<br />\n<em>Value</em> is the bit pattern for the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.",
      "DescriptionPlain": "OpConstant\n\nDeclare a new integer-type or floating-point-type scalar constant.\n\nResult Type must be a scalar integer type or floating-point type.\n\nValue is the bit pattern for the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 43,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": null,
          "Type": null
        }
      ]
    },
    {
      "Name": "OpConstantComposite",
      "Description": "<a id=\"OpConstantComposite\"></a><strong>OpConstantComposite</strong><br />\n<br />\nDeclare a new <a href=\"#CompositeType\"><em>composite</em></a> constant.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#CompositeType\"><em>composite</em></a> type, whose top-level members/elements/components/columns have the same type as the types of the <em>Constituents</em>. The ordering must be the same between the top-level types in <em>Result Type</em> and the <em>Constituents</em>.<br />\n<br />\n<em>Constituents</em> will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one <em>Constituent</em> for each top-level member/element/component/column of the result. The <em>Constituents</em> must appear in the order needed by the definition of the <em>Result Type</em>. The <em>Constituents</em> must all be <em>&lt;id&gt;s</em> of other constant declarations or an <a href=\"#OpUndef\"><strong>OpUndef</strong></a>.",
      "DescriptionPlain": "OpConstantComposite\n\nDeclare a new composite constant.\n\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the Constituents. The ordering must be the same between the top-level types in Result Type and the Constituents.\n\nConstituents will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the Result Type. The Constituents must all be &lt;id&gt;s of other constant declarations or an OpUndef.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 44,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Constituents",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpConstantSampler",
      "Description": "<a id=\"OpConstantSampler\"></a><strong>OpConstantSampler</strong><br />\n<br />\nDeclare a new sampler constant.<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Sampler Addressing Mode</em> is the addressing mode; a literal from <a href=\"#Sampler_Addressing_Mode\">Sampler Addressing Mode</a>.<br />\n<br />\n<em>Param</em> is one of:<br />\n0: Non Normalized<br />\n1: Normalized<br />\n<br />\n<em>Sampler Filter Mode</em> is the filter mode; a literal from <a href=\"#Sampler_Filter_Mode\">Sampler Filter Mode</a>.",
      "DescriptionPlain": "OpConstantSampler\n\nDeclare a new sampler constant.\n\nResult Type must be OpTypeSampler.\n\nSampler Addressing Mode is the addressing mode; a literal from Sampler Addressing Mode.\n\nParam is one of:\n0: Non Normalized\n1: Normalized\n\nSampler Filter Mode is the filter mode; a literal from Sampler Filter Mode.",
      "Category": "Constant-Creation",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 45,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SamplerAddressingMode",
          "Type": "SamplerAddressingMode"
        },
        {
          "Name": "Param",
          "Type": "LiteralNumber"
        },
        {
          "Name": "SamplerFilterMode",
          "Type": "SamplerFilterMode"
        }
      ]
    },
    {
      "Name": "OpConstantNull",
      "Description": "<a id=\"OpConstantNull\"></a><strong>OpConstantNull</strong><br />\n<br />\nDeclare a new <em>null</em> constant value.<br />\n<br />\nThe <em>null</em> value is type dependent, defined as follows:<br />\n -  Scalar Boolean: <strong>false</strong><br />\n -  Scalar integer: 0<br />\n -  Scalar floating point: +0.0 (all bits 0)<br />\n -  All other scalars: Abstract<br />\n -  Composites: Members are set recursively to the null constant according to the null value of their constituent types.<br />\n<br />\n<em>Result Type</em> must be one of the following types:<br />\n -  Scalar or vector <a href=\"#Boolean\"><em>Boolean type</em></a><br />\n -  Scalar or vector <a href=\"#Integer\"><em>integer type</em></a><br />\n -  Scalar or vector <a href=\"#Floating\"><em>floating-point type</em></a><br />\n -  Pointer type<br />\n -  <a href=\"#OpTypeEvent\"><em>Event type</em></a><br />\n -  <a href=\"#OpTypeDeviceEvent\"><em>Device side event type</em></a><br />\n -  <a href=\"#OpTypeReserveId\"><em>Reservation id type</em></a><br />\n -  <a href=\"#OpTypeQueue\"><em>Queue type</em></a><br />\n -  <a href=\"#CompositeType\"><em>Composite type</em></a>",
      "DescriptionPlain": "OpConstantNull\n\nDeclare a new null constant value.\n\nThe null value is type dependent, defined as follows:\n -  Scalar Boolean: false\n -  Scalar integer: 0\n -  Scalar floating point: +0.0 (all bits 0)\n -  All other scalars: Abstract\n -  Composites: Members are set recursively to the null constant according to the null value of their constituent types.\n\nResult Type must be one of the following types:\n -  Scalar or vector Boolean type\n -  Scalar or vector integer type\n -  Scalar or vector floating-point type\n -  Pointer type\n -  Event type\n -  Device side event type\n -  Reservation id type\n -  Queue type\n -  Composite type",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 46,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSpecConstantTrue",
      "Description": "<a id=\"OpSpecConstantTrue\"></a><strong>OpSpecConstantTrue</strong><br />\n<br />\nDeclare a <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar specialization constant with a default value of <strong>true</strong>.<br />\n<br />\nThis instruction can be specialized to become either an <a href=\"#OpConstantTrue\"><strong>OpConstantTrue</strong></a> or <a href=\"#OpConstantFalse\"><strong>OpConstantFalse</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
      "DescriptionPlain": "OpSpecConstantTrue\n\nDeclare a Boolean-type scalar specialization constant with a default value of true.\n\nThis instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.\n\nResult Type must be the scalar Boolean type.\n\nSee Specialization.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 48,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSpecConstantFalse",
      "Description": "<a id=\"OpSpecConstantFalse\"></a><strong>OpSpecConstantFalse</strong><br />\n<br />\nDeclare a <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar specialization constant with a default value of <strong>false</strong>.<br />\n<br />\nThis instruction can be specialized to become either an <a href=\"#OpConstantTrue\"><strong>OpConstantTrue</strong></a> or <a href=\"#OpConstantFalse\"><strong>OpConstantFalse</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
      "DescriptionPlain": "OpSpecConstantFalse\n\nDeclare a Boolean-type scalar specialization constant with a default value of false.\n\nThis instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.\n\nResult Type must be the scalar Boolean type.\n\nSee Specialization.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 49,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSpecConstant",
      "Description": "<a id=\"OpSpecConstant\"></a><strong>OpSpecConstant</strong><br />\n<br />\nDeclare a new <a href=\"#Integer\"><em>integer-type</em></a> or <a href=\"#Floating\"><em>floating-point-type</em></a> scalar specialization constant.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.<br />\n<br />\n<em>Value</em> is the bit pattern for the default value of the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.<br />\n<br />\nThis instruction can be specialized to become an <a href=\"#OpConstant\"><strong>OpConstant</strong></a> instruction.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
      "DescriptionPlain": "OpSpecConstant\n\nDeclare a new integer-type or floating-point-type scalar specialization constant.\n\nResult Type must be a scalar integer type or floating-point type.\n\nValue is the bit pattern for the default value of the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.\n\nThis instruction can be specialized to become an OpConstant instruction.\n\nSee Specialization.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 50,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": null,
          "Type": null
        }
      ]
    },
    {
      "Name": "OpSpecConstantComposite",
      "Description": "<a id=\"OpSpecConstantComposite\"></a><strong>OpSpecConstantComposite</strong><br />\n<br />\nDeclare a new <a href=\"#CompositeType\"><em>composite</em></a> specialization constant.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#CompositeType\"><em>composite</em></a> type, whose top-level members/elements/components/columns have the same type as the types of the <em>Constituents</em>. The ordering must be the same between the top-level types in <em>Result Type</em> and the <em>Constituents</em>.<br />\n<br />\n<em>Constituents</em> will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one <em>Constituent</em> for each top-level member/element/component/column of the result. The <em>Constituents</em> must appear in the order needed by the definition of the type of the result. The <em>Constituents</em> must be the <em>&lt;id&gt;</em> of other specialization constant or constant declarations.<br />\n<br />\nThis instruction will be specialized to an <a href=\"#OpConstantComposite\"><strong>OpConstantComposite</strong></a> instruction.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
      "DescriptionPlain": "OpSpecConstantComposite\n\nDeclare a new composite specialization constant.\n\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the Constituents. The ordering must be the same between the top-level types in Result Type and the Constituents.\n\nConstituents will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the type of the result. The Constituents must be the &lt;id&gt; of other specialization constant or constant declarations.\n\nThis instruction will be specialized to an OpConstantComposite instruction.\n\nSee Specialization.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 51,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Constituents",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpSpecConstantOp",
      "Description": "<a id=\"OpSpecConstantOp\"></a><strong>OpSpecConstantOp</strong><br />\n<br />\nDeclare a new specialization constant that results from doing an operation.<br />\n<br />\n<em>Result Type</em> must be the type required by the <em>Result Type</em> of <em>Opcode</em>.<br />\n<br />\n<em>Opcode</em> must be one of the following opcodes. This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<strong>OpSConvert</strong>, <strong>OpFConvert</strong><br />\n<strong>OpSNegate</strong>, <strong>OpNot</strong><br />\n<strong>OpIAdd</strong>, <strong>OpISub</strong><br />\n<strong>OpIMul</strong>, <strong>OpUDiv</strong>, <strong>OpSDiv</strong>, <strong>OpUMod</strong>, <strong>OpSRem</strong>, <strong>OpSMod</strong><br />\n<strong>OpShiftRightLogical</strong>, <strong>OpShiftRightArithmetic</strong>, <strong>OpShiftLeftLogical</strong><br />\n<strong>OpBitwiseOr</strong>, <strong>OpBitwiseXor</strong>, <strong>OpBitwiseAnd</strong><br />\n<strong>OpVectorShuffle</strong>, <strong>OpCompositeExtract</strong>, <strong>OpCompositeInsert</strong><br />\n<strong>OpLogicalOr</strong>, <strong>OpLogicalAnd</strong>, <strong>OpLogicalNot</strong>,<br />\n<strong>OpLogicalEqual</strong>, <strong>OpLogicalNotEqual</strong><br />\n<strong>OpSelect</strong><br />\n<strong>OpIEqual</strong>, <strong>OpINotEqual</strong><br />\n<strong>OpULessThan</strong>, <strong>OpSLessThan</strong><br />\n<strong>OpUGreaterThan</strong>, <strong>OpSGreaterThan</strong><br />\n<strong>OpULessThanEqual</strong>, <strong>OpSLessThanEqual</strong><br />\n<strong>OpUGreaterThanEqual</strong>, <strong>OpSGreaterThanEqual</strong><br />\n<br />\nIf the <strong>Shader</strong> capability was declared, the following opcode is also valid:<br />\n<strong>OpQuantizeToF16</strong><br />\n<br />\nIf the <strong>Kernel</strong> capability was declared, the following opcodes are also valid:<br />\n<strong>OpConvertFToS</strong>, <strong>OpConvertSToF</strong><br />\n<strong>OpConvertFToU</strong>, <strong>OpConvertUToF</strong><br />\n<strong>OpUConvert</strong><br />\n<strong>OpConvertPtrToU</strong>, <strong>OpConvertUToPtr</strong><br />\n<strong>OpGenericCastToPtr</strong>, <strong>OpPtrCastToGeneric</strong><br />\n<strong>OpBitcast</strong><br />\n<strong>OpFNegate</strong><br />\n<strong>OpFAdd</strong>, <strong>OpFSub</strong><br />\n<strong>OpFMul</strong>, <strong>OpFDiv</strong><br />\n<strong>OpFRem</strong>, <strong>OpFMod</strong><br />\n<strong>OpAccessChain</strong>, <strong>OpInBoundsAccessChain</strong><br />\n<strong>OpPtrAccessChain</strong>, <strong>OpInBoundsPtrAccessChain</strong><br />\n<br />\n<em>Operands</em> are the operands required by <em>opcode</em>, and satisfy the semantics of <em>opcode</em>. In addition, all <em>Operands</em> must be either:<br />\n - the <em>&lt;id&gt;s</em> of other <a href=\"#ConstantInstruction\">constant instructions</a>, or<br />\n - <strong>OpUndef</strong>, when allowed by <em>opcode</em>, or<br />\n - for the <strong>AccessChain</strong> named opcodes, their <em>Base</em> is allowed to be a global (module scope) <a href=\"#OpVariable\"><strong>OpVariable</strong></a> instruction.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
      "DescriptionPlain": "OpSpecConstantOp\n\nDeclare a new specialization constant that results from doing an operation.\n\nResult Type must be the type required by the Result Type of Opcode.\n\nOpcode must be one of the following opcodes. This literal operand is limited to a single word.\nOpSConvert, OpFConvert\nOpSNegate, OpNot\nOpIAdd, OpISub\nOpIMul, OpUDiv, OpSDiv, OpUMod, OpSRem, OpSMod\nOpShiftRightLogical, OpShiftRightArithmetic, OpShiftLeftLogical\nOpBitwiseOr, OpBitwiseXor, OpBitwiseAnd\nOpVectorShuffle, OpCompositeExtract, OpCompositeInsert\nOpLogicalOr, OpLogicalAnd, OpLogicalNot,\nOpLogicalEqual, OpLogicalNotEqual\nOpSelect\nOpIEqual, OpINotEqual\nOpULessThan, OpSLessThan\nOpUGreaterThan, OpSGreaterThan\nOpULessThanEqual, OpSLessThanEqual\nOpUGreaterThanEqual, OpSGreaterThanEqual\n\nIf the Shader capability was declared, the following opcode is also valid:\nOpQuantizeToF16\n\nIf the Kernel capability was declared, the following opcodes are also valid:\nOpConvertFToS, OpConvertSToF\nOpConvertFToU, OpConvertUToF\nOpUConvert\nOpConvertPtrToU, OpConvertUToPtr\nOpGenericCastToPtr, OpPtrCastToGeneric\nOpBitcast\nOpFNegate\nOpFAdd, OpFSub\nOpFMul, OpFDiv\nOpFRem, OpFMod\nOpAccessChain, OpInBoundsAccessChain\nOpPtrAccessChain, OpInBoundsPtrAccessChain\n\nOperands are the operands required by opcode, and satisfy the semantics of opcode. In addition, all Operands must be either:\n - the &lt;id&gt;s of other constant instructions, or\n - OpUndef, when allowed by opcode, or\n - for the AccessChain named opcodes, their Base is allowed to be a global (module scope) OpVariable instruction.\n\nSee Specialization.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 52,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Opcode",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Operands",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpVariable",
      "Description": "<a id=\"OpVariable\"></a><strong>OpVariable</strong><br />\n<br />\nAllocate an object in memory, resulting in a pointer to it, which can be used with <a href=\"#OpLoad\"><strong>OpLoad</strong></a> and <a href=\"#OpStore\"><strong>OpStore</strong></a>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <em>Type</em> operand is the type of object in memory.<br />\n<br />\n<em>Storage Class</em> is the <a href=\"#Storage_Class\">Storage Class</a> of the memory holding the object. It cannot be <strong>Generic</strong>.<br />\n<br />\n<em>Initializer</em> is optional.  If <em>Initializer</em> is present, it will be the initial value of the variable&#8217;s memory content. <em>Initializer</em> must be an <em>&lt;id&gt;</em> from a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> or a global (module scope) <a href=\"#OpVariable\"><strong>OpVariable</strong></a> instruction. <em>Initializer</em> must have the same type as the type pointed to by <em>Result Type</em>.",
      "DescriptionPlain": "OpVariable\n\nAllocate an object in memory, resulting in a pointer to it, which can be used with OpLoad and OpStore.\n\n Result Type must be an OpTypePointer. Its Type operand is the type of object in memory.\n\nStorage Class is the Storage Class of the memory holding the object. It cannot be Generic.\n\nInitializer is optional.  If Initializer is present, it will be the initial value of the variable&#8217;s memory content. Initializer must be an &lt;id&gt; from a constant instruction or a global (module scope) OpVariable instruction. Initializer must have the same type as the type pointed to by Result Type.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 59,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "StorageClass",
          "Type": "StorageClass"
        },
        {
          "Name": "Optional",
          "Type": "IDInitializer?"
        }
      ]
    },
    {
      "Name": "OpImageTexelPointer",
      "Description": "<a id=\"OpImageTexelPointer\"></a><strong>OpImageTexelPointer</strong><br />\n<br />\nForm a pointer to a texel of an image. Use of such a pointer is limited to atomic operations.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose <a href=\"#Storage_Class\"><em>Storage Class</em></a> operand is <strong>Image</strong>. Its <em>Type</em> operand must be a scalar <a href=\"#Numerical\">numerical type</a> or <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n<br />\n<em>Image</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <em>Type</em> <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. The <em>Sampled Type</em> of the type of <em>Image</em> must be the same as the <em>Type</em> pointed to by <em>Result Type</em>. The <a href=\"#Dim\"><em>Dim</em></a> operand of <em>Type</em> cannot be <strong>SubpassData</strong>.<br />\n<br />\n<em>Coordinate</em> and <em>Sample</em> specify which texel and sample within the image to form a pointer to.<br />\n<br />\n<em>Coordinate</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the number of components specified below, given the following <em>Arrayed</em> and <a href=\"#Dim\"><em>Dim</em></a> operands of the type of the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\nIf <em>Arrayed</em> is 0:<br />\n<strong>1D</strong>: scalar<br />\n<strong>2D</strong>: 2 components<br />\n<strong>3D</strong>: 3 components<br />\n<strong>Cube</strong>: 3 components<br />\n<strong>Rect</strong>: 2 components<br />\n<strong>Buffer</strong>: scalar<br />\n<br />\nIf <em>Arrayed</em> is 1:<br />\n<strong>1D</strong>: 2 components<br />\n<strong>2D</strong>: 3 components<br />\n<strong>Cube</strong>: 4 components<br />\n<br />\n<em>Sample</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. It specifies which sample to select at the given coordinate.  It must be a valid <em>&lt;id&gt;</em> for the value 0 if the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> has <em>MS</em> of 0.",
      "DescriptionPlain": "OpImageTexelPointer\n\nForm a pointer to a texel of an image. Use of such a pointer is limited to atomic operations.\n\nResult Type must be an OpTypePointer whose Storage Class operand is Image. Its Type operand must be a scalar numerical type or OpTypeVoid.\n\nImage must have a type of OpTypePointer with Type OpTypeImage. The Sampled Type of the type of Image must be the same as the Type pointed to by Result Type. The Dim operand of Type cannot be SubpassData.\n\nCoordinate and Sample specify which texel and sample within the image to form a pointer to.\n\nCoordinate must be a scalar or vector of integer type.  It must have the number of components specified below, given the following Arrayed and Dim operands of the type of the OpTypeImage.\n\nIf Arrayed is 0:\n1D: scalar\n2D: 2 components\n3D: 3 components\nCube: 3 components\nRect: 2 components\nBuffer: scalar\n\nIf Arrayed is 1:\n1D: 2 components\n2D: 3 components\nCube: 4 components\n\nSample must be an integer type scalar. It specifies which sample to select at the given coordinate.  It must be a valid &lt;id&gt; for the value 0 if the OpTypeImage has MS of 0.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 60,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Sample",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLoad",
      "Description": "<a id=\"OpLoad\"></a><strong>OpLoad</strong><br />\n<br />\nLoad through a pointer.<br />\n<br />\n<em>Result Type</em> is the type of the loaded object.<br />\n<br />\n<em>Pointer</em> is the pointer to load through.  Its type must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose <em>Type</em> operand is the same as <em>Result Type</em>.<br />\n<br />\n<em>Memory Access</em> must be a <a href=\"#Memory_Access\">Memory Access</a> literal. If not present, it is the same as specifying <strong>None</strong>.",
      "DescriptionPlain": "OpLoad\n\nLoad through a pointer.\n\nResult Type is the type of the loaded object.\n\nPointer is the pointer to load through.  Its type must be an OpTypePointer whose Type operand is the same as Result Type.\n\nMemory Access must be a Memory Access literal. If not present, it is the same as specifying None.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 61,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "MemoryAccess?"
        }
      ]
    },
    {
      "Name": "OpStore",
      "Description": "<a id=\"OpStore\"></a><strong>OpStore</strong><br />\n<br />\nStore through a pointer.<br />\n<br />\n<em>Pointer</em> is the pointer to store through.  Its type must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose <em>Type</em> operand is the same as the type of <em>Object</em>.<br />\n<br />\n<em>Object</em> is the object to store.<br />\n<br />\n<em>Memory Access</em> must be a <a href=\"#Memory_Access\">Memory Access</a> literal. If not present, it is the same as specifying <strong>None</strong>.",
      "DescriptionPlain": "OpStore\n\nStore through a pointer.\n\nPointer is the pointer to store through.  Its type must be an OpTypePointer whose Type operand is the same as the type of Object.\n\nObject is the object to store.\n\nMemory Access must be a Memory Access literal. If not present, it is the same as specifying None.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 62,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "MemoryAccess?"
        }
      ]
    },
    {
      "Name": "OpCopyMemory",
      "Description": "<a id=\"OpCopyMemory\"></a><strong>OpCopyMemory</strong><br />\n<br />\nCopy from the memory pointed to by <em>Source</em> to the memory pointed to by <em>Target</em>. Both operands must be non-void pointers of the same type.  Matching Storage Class is not required. The amount of memory copied is the size of the type pointed to.<br />\n<br />\n<em>Memory Access</em> must be a <a href=\"#Memory_Access\">Memory Access</a> literal. If not present, it is the same as specifying <strong>None</strong>.",
      "DescriptionPlain": "OpCopyMemory\n\nCopy from the memory pointed to by Source to the memory pointed to by Target. Both operands must be non-void pointers of the same type.  Matching Storage Class is not required. The amount of memory copied is the size of the type pointed to.\n\nMemory Access must be a Memory Access literal. If not present, it is the same as specifying None.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 63,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Target",
          "Type": "ID"
        },
        {
          "Name": "Source",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "MemoryAccess?"
        }
      ]
    },
    {
      "Name": "OpCopyMemorySized",
      "Description": "<a id=\"OpCopyMemorySized\"></a><strong>OpCopyMemorySized</strong><br />\n<br />\nCopy from the memory pointed to by <em>Source</em> to the memory pointed to by <em>Target</em>. <br />\n<br />\n<em>Size</em> is the number of bytes to copy. It must have a scalar <a href=\"#Integer\">integer type</a>. If it is a <a href=\"#ConstantInstruction\">constant instruction</a>, the constant value cannot be 0. It is invalid for both the constant&#8217;s type to have <em>Signedness</em> of 1 and to have the sign bit set. Otherwise, as a run-time value, <em>Size</em> is treated as unsigned, and if its value is 0, no memory access will be made.<br />\n<br />\n<em>Memory Access</em> must be a <a href=\"#Memory_Access\">Memory Access</a> literal. If not present, it is the same as specifying <strong>None</strong>.",
      "DescriptionPlain": "OpCopyMemorySized\n\nCopy from the memory pointed to by Source to the memory pointed to by Target. \n\nSize is the number of bytes to copy. It must have a scalar integer type. If it is a constant instruction, the constant value cannot be 0. It is invalid for both the constant&#8217;s type to have Signedness of 1 and to have the sign bit set. Otherwise, as a run-time value, Size is treated as unsigned, and if its value is 0, no memory access will be made.\n\nMemory Access must be a Memory Access literal. If not present, it is the same as specifying None.",
      "Category": "Memory",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 64,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Target",
          "Type": "ID"
        },
        {
          "Name": "Source",
          "Type": "ID"
        },
        {
          "Name": "Size",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "MemoryAccess?"
        }
      ]
    },
    {
      "Name": "OpAccessChain",
      "Description": "<a id=\"OpAccessChain\"></a><strong>OpAccessChain</strong><br />\n<br />\nCreate a pointer into a <a href=\"#CompositeType\"><em>composite</em></a> object that can be used with <a href=\"#OpLoad\"><strong>OpLoad</strong></a> and <a href=\"#OpStore\"><strong>OpStore</strong></a>. <br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <em>Type</em> operand must be the type reached by walking the <em>Base&#8217;s</em> type hierarchy down to the last provided index in <em>Indexes</em>, and its <em>Storage Class</em> operand must be the same as the Storage Class of <em>Base</em>.<br />\n<br />\n<em>Base</em> must be a pointer, pointing to the base of a composite object.<br />\n<br />\n<em>Indexes</em> walk the type hierarchy to the desired depth, potentially down to scalar granularity. The first index in <em>Indexes</em> will select the top-level member/element/component/element of the base composite. All composite constituents use zero-based numbering, as described by their <strong>OpType&#8230;</strong> instruction. The second index will apply similarly to that result, and so on. Once any non-composite type is reached, there must be no remaining (unused) indexes. Each of the <em>Indexes</em> must:<br />\n- be a scalar <a href=\"#Integer\">integer type</a>,<br />\n- be an <a href=\"#OpConstant\"><strong>OpConstant</strong></a> when indexing into a structure.",
      "DescriptionPlain": "OpAccessChain\n\nCreate a pointer into a composite object that can be used with OpLoad and OpStore. \n\n Result Type must be an OpTypePointer. Its Type operand must be the type reached by walking the Base&#8217;s type hierarchy down to the last provided index in Indexes, and its Storage Class operand must be the same as the Storage Class of Base.\n\nBase must be a pointer, pointing to the base of a composite object.\n\nIndexes walk the type hierarchy to the desired depth, potentially down to scalar granularity. The first index in Indexes will select the top-level member/element/component/element of the base composite. All composite constituents use zero-based numbering, as described by their OpType&#8230; instruction. The second index will apply similarly to that result, and so on. Once any non-composite type is reached, there must be no remaining (unused) indexes. Each of the Indexes must:\n- be a scalar integer type,\n- be an OpConstant when indexing into a structure.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 65,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Indexes",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpInBoundsAccessChain",
      "Description": "<a id=\"OpInBoundsAccessChain\"></a><strong>OpInBoundsAccessChain</strong><br />\n<br />\nHas the same semantics as <a href=\"#OpAccessChain\"><strong>OpAccessChain</strong></a>, with the addition that the resulting pointer is known to point within the base object.",
      "DescriptionPlain": "OpInBoundsAccessChain\n\nHas the same semantics as OpAccessChain, with the addition that the resulting pointer is known to point within the base object.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 66,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Indexes",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpPtrAccessChain",
      "Description": "<a id=\"OpPtrAccessChain\"></a><strong>OpPtrAccessChain</strong><br />\n<br />\nHas the same semantics as <a href=\"#OpAccessChain\"><strong>OpAccessChain</strong></a>, with the addition of the <em>Element</em> operand.<br />\n<br />\n<em>Element</em> is used to do the initial dereference of <em>Base</em>: <em>Base</em> is treated as the address of the first element of an array, and the <em>Element</em> element&#8217;s address is computed to be the base for the <em>Indexes</em>, as per <a href=\"#OpAccessChain\"><strong>OpAccessChain</strong></a>. The type of <em>Base</em> after being dereferenced with <em>Element</em> is still the same as the original type of <em>Base</em>.<br />\n<br />\nNote: If <em>Base</em> is originally typed to be a pointer an array, and the desired operation is to select an element of that array, <a href=\"#OpAccessChain\"><strong>OpAccessChain</strong></a> should be directly used, as its first <em>Index</em> will select the array element.",
      "DescriptionPlain": "OpPtrAccessChain\n\nHas the same semantics as OpAccessChain, with the addition of the Element operand.\n\nElement is used to do the initial dereference of Base: Base is treated as the address of the first element of an array, and the Element element&#8217;s address is computed to be the base for the Indexes, as per OpAccessChain. The type of Base after being dereferenced with Element is still the same as the original type of Base.\n\nNote: If Base is originally typed to be a pointer an array, and the desired operation is to select an element of that array, OpAccessChain should be directly used, as its first Index will select the array element.",
      "Category": "Memory",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 67,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Element",
          "Type": "ID"
        },
        {
          "Name": "Indexes",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpArrayLength",
      "Description": "<a id=\"OpArrayLength\"></a><strong>OpArrayLength</strong><br />\n<br />\nLength of a run-time array.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeInt\">OpTypeInt</a> with 32-bit <em>Width</em> and 0 <em>Signedness</em>.<br />\n<br />\n<em>Structure</em> must have a type of <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> whose last member is a run-time array.<br />\n<br />\n<em>Array member</em> is the last member number of <em>Structure</em> and must have a type from <a href=\"#OpTypeRuntimeArray\"><strong>OpTypeRuntimeArray</strong></a>.",
      "DescriptionPlain": "OpArrayLength\n\nLength of a run-time array.\n\nResult Type must be an OpTypeInt with 32-bit Width and 0 Signedness.\n\nStructure must have a type of OpTypeStruct whose last member is a run-time array.\n\nArray member is the last member number of Structure and must have a type from OpTypeRuntimeArray.",
      "Category": "Memory",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 68,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Structure",
          "Type": "ID"
        },
        {
          "Name": "ArrayMember",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpGenericPtrMemSemantics",
      "Description": "<a id=\"OpGenericPtrMemSemantics\"></a><strong>OpGenericPtrMemSemantics</strong><br />\n<br />\nResult is a valid <a href=\"#Memory_Semantics_-id-\"><strong>Memory Semantics</strong></a> which includes mask bits set for the Storage Class for the specific (non-Generic) Storage Class of <em>Pointer</em>. <br />\n<br />\n<em>Pointer</em> must point to <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeInt\">OpTypeInt</a> with 32-bit <em>Width</em> and 0 <em>Signedness</em>.",
      "DescriptionPlain": "OpGenericPtrMemSemantics\n\nResult is a valid Memory Semantics which includes mask bits set for the Storage Class for the specific (non-Generic) Storage Class of Pointer. \n\nPointer must point to Generic Storage Class.\n\nResult Type must be an OpTypeInt with 32-bit Width and 0 Signedness.",
      "Category": "Memory",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 69,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpInBoundsPtrAccessChain",
      "Description": "<a id=\"OpInBoundsPtrAccessChain\"></a><strong>OpInBoundsPtrAccessChain</strong><br />\n<br />\nHas the same semantics as <a href=\"#OpPtrAccessChain\"><strong>OpPtrAccessChain</strong></a>, with the addition that the resulting pointer is known to point within the base object.",
      "DescriptionPlain": "OpInBoundsPtrAccessChain\n\nHas the same semantics as OpPtrAccessChain, with the addition that the resulting pointer is known to point within the base object.",
      "Category": "Memory",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 70,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Element",
          "Type": "ID"
        },
        {
          "Name": "Indexes",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpFunction",
      "Description": "<a id=\"OpFunction\"></a><strong>OpFunction</strong><br />\n<br />\nAdd a function.  This instruction must be immediately followed by one <a href=\"#OpFunctionParameter\"><strong>OpFunctionParameter</strong></a> instruction per each formal parameter of this function. This function&#8217;s body or declaration will terminate with the next <a href=\"#OpFunctionEnd\"><strong>OpFunctionEnd</strong></a> instruction.<br />\n<br />\nThe <em>Result &lt;id&gt;</em> cannot be used generally by other instructions. It can only be used by <a href=\"#OpFunctionCall\"><strong>OpFunctionCall</strong></a>,  <a href=\"#OpEntryPoint\"><strong>OpEntryPoint</strong></a>, and decoration instructions.<br />\n<br />\n<em>Result Type</em> must be the same as the <em>Return Type</em> declared in <em>Function Type</em>.<br />\n<br />\n<em>Function Type</em> is the result of an <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a>, which declares the types of the return value and parameters of the function.",
      "DescriptionPlain": "OpFunction\n\nAdd a function.  This instruction must be immediately followed by one OpFunctionParameter instruction per each formal parameter of this function. This function&#8217;s body or declaration will terminate with the next OpFunctionEnd instruction.\n\nThe Result &lt;id&gt; cannot be used generally by other instructions. It can only be used by OpFunctionCall,  OpEntryPoint, and decoration instructions.\n\nResult Type must be the same as the Return Type declared in Function Type.\n\nFunction Type is the result of an OpTypeFunction, which declares the types of the return value and parameters of the function.",
      "Category": "Function",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 54,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "FunctionControl",
          "Type": "FunctionControl"
        },
        {
          "Name": "FunctionType",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFunctionParameter",
      "Description": "<a id=\"OpFunctionParameter\"></a><strong>OpFunctionParameter</strong><br />\n<br />\nDeclare a formal parameter of the current function.<br />\n<br />\n<em>Result Type</em> is the type of the parameter.<br />\n<br />\nThis instruction must immediately follow an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> or <a href=\"#OpFunctionParameter\"><strong>OpFunctionParameter</strong></a> instruction. The order of contiguous <strong>OpFunctionParameter</strong> instructions is the same order arguments will be listed in an <a href=\"#OpFunctionCall\"><strong>OpFunctionCall</strong></a> instruction to this function. It is also the same order in which <em>Parameter Type</em> operands are listed in the <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> of the <em>Function Type</em> operand for this function&#8217;s <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.",
      "DescriptionPlain": "OpFunctionParameter\n\nDeclare a formal parameter of the current function.\n\nResult Type is the type of the parameter.\n\nThis instruction must immediately follow an OpFunction or OpFunctionParameter instruction. The order of contiguous OpFunctionParameter instructions is the same order arguments will be listed in an OpFunctionCall instruction to this function. It is also the same order in which Parameter Type operands are listed in the OpTypeFunction of the Function Type operand for this function&#8217;s OpFunction instruction.",
      "Category": "Function",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 55,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFunctionEnd",
      "Description": "<a id=\"OpFunctionEnd\"></a><strong>OpFunctionEnd</strong><br />\n<br />\nLast instruction of a function.",
      "DescriptionPlain": "OpFunctionEnd\n\nLast instruction of a function.",
      "Category": "Function",
      "Capabilities": [],
      "WordCount": "1",
      "WordCountFix": 1,
      "OpCode": 56,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpFunctionCall",
      "Description": "<a id=\"OpFunctionCall\"></a><strong>OpFunctionCall</strong><br />\n<br />\nCall a function.<br />\n<br />\n<em>Result Type</em> is the type of the return value of the function. It must be the same as the <em>Return Type</em> operand of the <em>Function Type</em> operand of the <em>Function</em> operand.<br />\n<br />\n<em>Function</em> is an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.  This could be a forward reference.<br />\n<br />\n<em>Argument N</em> is the object to copy to parameter <em>N</em> of <em>Function</em>.<br />\n<br />\n<strong>Note:</strong> A forward call is possible because there is no missing type information: <em>Result Type</em> must match the <em>Return Type</em> of the function, and the calling argument types must match the formal parameter types.",
      "DescriptionPlain": "OpFunctionCall\n\nCall a function.\n\nResult Type is the type of the return value of the function. It must be the same as the Return Type operand of the Function Type operand of the Function operand.\n\nFunction is an OpFunction instruction.  This could be a forward reference.\n\nArgument N is the object to copy to parameter N of Function.\n\nNote: A forward call is possible because there is no missing type information: Result Type must match the Return Type of the function, and the calling argument types must match the formal parameter types.",
      "Category": "Function",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 57,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Function",
          "Type": "ID"
        },
        {
          "Name": "Arguments",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpSampledImage",
      "Description": "<a id=\"OpSampledImage\"></a><strong>OpSampledImage</strong><br />\n<br />\nCreate a <a href=\"#SampledImage\">sampled image</a>, containing both a <a href=\"#Sampler\">sampler</a> and an <a href=\"#ImageTerm\">image</a>.<br />\n<br />\n<em>Result Type</em> must be the <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a> type.<br />\n<br />\n<em>Image</em> is an object whose type is an <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>, whose <em>Sampled</em> operand is 0 or 1, and whose <a href=\"#Dim\"><em>Dim</em></a> operand is not <strong>SubpassData</strong>.<br />\n<br />\n<em>Sampler</em> must be an object whose type is <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.",
      "DescriptionPlain": "OpSampledImage\n\nCreate a sampled image, containing both a sampler and an image.\n\nResult Type must be the OpTypeSampledImage type.\n\nImage is an object whose type is an OpTypeImage, whose Sampled operand is 0 or 1, and whose Dim operand is not SubpassData.\n\nSampler must be an object whose type is OpTypeSampler.",
      "Category": "Image",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 86,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageSampleImplicitLod",
      "Description": "<a id=\"OpImageSampleImplicitLod\"></a><strong>OpImageSampleImplicitLod</strong><br />\n<br />\nSample an image with an implicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpImageSampleImplicitLod\n\nSample an image with an implicit level of detail.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 87,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSampleExplicitLod",
      "Description": "<a id=\"OpImageSampleExplicitLod\"></a><strong>OpImageSampleExplicitLod</strong><br />\n<br />\nSample an image using an explicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. Unless the <strong>Kernel</strong> <a href=\"#Capability\">capability</a> is being used, it must be floating point. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
      "DescriptionPlain": "OpImageSampleExplicitLod\n\nSample an image using an explicit level of detail.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. Unless the Kernel capability is being used, it must be floating point. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
      "Category": "Image",
      "Capabilities": [],
      "WordCount": "7 + variable",
      "WordCountFix": 7,
      "OpCode": 88,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "ImageOperands",
          "Type": "ImageOperands"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSampleDrefImplicitLod",
      "Description": "<a id=\"OpImageSampleDrefImplicitLod\"></a><strong>OpImageSampleDrefImplicitLod</strong><br />\n<br />\nSample an image doing depth-comparison with an implicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpImageSampleDrefImplicitLod\n\nSample an image doing depth-comparison with an implicit level of detail.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 89,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSampleDrefExplicitLod",
      "Description": "<a id=\"OpImageSampleDrefExplicitLod\"></a><strong>OpImageSampleDrefExplicitLod</strong><br />\n<br />\nSample an image doing depth-comparison using an explicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
      "DescriptionPlain": "OpImageSampleDrefExplicitLod\n\nSample an image doing depth-comparison using an explicit level of detail.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "8 + variable",
      "WordCountFix": 8,
      "OpCode": 90,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "ImageOperands",
          "Type": "ImageOperands"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSampleProjImplicitLod",
      "Description": "<a id=\"OpImageSampleProjImplicitLod\"></a><strong>OpImageSampleProjImplicitLod</strong><br />\n<br />\nSample an image with with a project coordinate and an implicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. The <a href=\"#Dim\"><em>Dim</em></a> operand of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must be <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>,  and the <em>Arrayed</em> and <em>MS</em> operands must be 0.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector containing (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definition of <em>Sampled Image</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpImageSampleProjImplicitLod\n\nSample an image with with a project coordinate and an implicit level of detail.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\n\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 91,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSampleProjExplicitLod",
      "Description": "<a id=\"OpImageSampleProjExplicitLod\"></a><strong>OpImageSampleProjExplicitLod</strong><br />\n<br />\nSample an image with a project coordinate using an explicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. The <a href=\"#Dim\"><em>Dim</em></a> operand of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must be <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>,  and the <em>Arrayed</em> and <em>MS</em> operands must be 0.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector containing (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definition of <em>Sampled Image</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
      "DescriptionPlain": "OpImageSampleProjExplicitLod\n\nSample an image with a project coordinate using an explicit level of detail.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\n\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7 + variable",
      "WordCountFix": 7,
      "OpCode": 92,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "ImageOperands",
          "Type": "ImageOperands"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSampleProjDrefImplicitLod",
      "Description": "<a id=\"OpImageSampleProjDrefImplicitLod\"></a><strong>OpImageSampleProjDrefImplicitLod</strong><br />\n<br />\nSample an image with a project coordinate, doing depth-comparison, with an implicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. The <a href=\"#Dim\"><em>Dim</em></a> operand of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must be <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>,  and the <em>Arrayed</em> and <em>MS</em> operands must be 0.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector containing (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definition of <em>Sampled Image</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> /<em>q</em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpImageSampleProjDrefImplicitLod\n\nSample an image with a project coordinate, doing depth-comparison, with an implicit level of detail.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\n\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref /q is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 93,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSampleProjDrefExplicitLod",
      "Description": "<a id=\"OpImageSampleProjDrefExplicitLod\"></a><strong>OpImageSampleProjDrefExplicitLod</strong><br />\n<br />\nSample an image with a project coordinate, doing depth-comparison, using an explicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. The <a href=\"#Dim\"><em>Dim</em></a> operand of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must be <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>,  and the <em>Arrayed</em> and <em>MS</em> operands must be 0.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector containing (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definition of <em>Sampled Image</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> /<em>q</em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
      "DescriptionPlain": "OpImageSampleProjDrefExplicitLod\n\nSample an image with a project coordinate, doing depth-comparison, using an explicit level of detail.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\n\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref /q is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "8 + variable",
      "WordCountFix": 8,
      "OpCode": 94,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "ImageOperands",
          "Type": "ImageOperands"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageFetch",
      "Description": "<a id=\"OpImageFetch\"></a><strong>OpImageFetch</strong><br />\n<br />\nFetch a single texel from a sampled image.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand cannot be <strong>Cube</strong>, and its <em>Sampled</em> operand must be 1.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
      "DescriptionPlain": "OpImageFetch\n\nFetch a single texel from a sampled image.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nImage must be an object whose type is OpTypeImage. Its Dim operand cannot be Cube, and its Sampled operand must be 1.\n\nCoordinate is an integer scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nImage Operands encodes what operands follow, as per Image Operands.",
      "Category": "Image",
      "Capabilities": [],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 95,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageGather",
      "Description": "<a id=\"OpImageGather\"></a><strong>OpImageGather</strong><br />\n<br />\nGathers the requested component from four texels.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>). It has one component per gathered texel.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must have a <a href=\"#Dim\"><em>Dim</em></a> of <strong>2D</strong>, <strong>Cube</strong>, or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>Component</em> is the component number that will be gathered from all four texels. It must be 0, 1, 2 or 3.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
      "DescriptionPlain": "OpImageGather\n\nGathers the requested component from four texels.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nComponent is the component number that will be gathered from all four texels. It must be 0, 1, 2 or 3.\n\nImage Operands encodes what operands follow, as per Image Operands.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 96,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Component",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageDrefGather",
      "Description": "<a id=\"OpImageDrefGather\"></a><strong>OpImageDrefGather</strong><br />\n<br />\nGathers the requested depth-comparison from four texels.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. It has one component per gathered texel.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must have a <a href=\"#Dim\"><em>Dim</em></a> of <strong>2D</strong>, <strong>Cube</strong>, or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
      "DescriptionPlain": "OpImageDrefGather\n\nGathers the requested depth-comparison from four texels.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage. It has one component per gathered texel.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 97,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageRead",
      "Description": "<a id=\"OpImageRead\"></a><strong>OpImageRead</strong><br />\n<br />\nRead a texel from an <a href=\"#ImageTerm\">image</a> without a <a href=\"#Sampler\">sampler</a>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its component type must be the same as <em>Sampled Type</em> of the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> with a <em>Sampled</em> operand of 0 or 2. If the <em>Sampled</em> operand is 2, then some <a href=\"#Dim\">dimensions</a> require a <a href=\"#Capability\">capability</a>; e.g., one of <strong>Image1D</strong>, <strong>ImageRect</strong>, <strong>ImageBuffer</strong>, <strong>ImageCubeArray</strong>, or <strong>ImageMSArray</strong>.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing non-normalized texel coordinates (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Image</em>. If the coordinates are outside the image, the memory location that is accessed is undefined.<br />\n<br />\n When the <em>Image</em> <a href=\"#Dim\"><em>Dim</em></a> operand is <strong>SubpassData</strong>, <em>Coordinate</em> is relative to the current fragment location. That is, the integer value (rounded down) of the current fragment&#8217;s window-relative <em>(x, y)</em> coordinate is added to <em>(u, v)</em>.<br />\n<br />\n When the <em>Image</em> <a href=\"#Dim\"><em>Dim</em></a> operand is not <strong>SubpassData</strong>, the <a href=\"#Image_Format\"><em>Image Format</em></a> must not be <strong>Unknown</strong>, unless the <strong>StorageImageReadWithoutFormat</strong> <a href=\"#Capability\">Capability</a> was declared.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
      "DescriptionPlain": "OpImageRead\n\nRead a texel from an image without a sampler.\n\n Result Type must be a scalar or vector of floating-point type or integer type.  Its component type must be the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).\n\nImage must be an object whose type is OpTypeImage with a Sampled operand of 0 or 2. If the Sampled operand is 2, then some dimensions require a capability; e.g., one of Image1D, ImageRect, ImageBuffer, ImageCubeArray, or ImageMSArray.\n\nCoordinate is an integer scalar or vector containing non-normalized texel coordinates (u[, v] &#8230; [, array layer]) as needed by the definition of Image. If the coordinates are outside the image, the memory location that is accessed is undefined.\n\n When the Image Dim operand is SubpassData, Coordinate is relative to the current fragment location. That is, the integer value (rounded down) of the current fragment&#8217;s window-relative (x, y) coordinate is added to (u, v).\n\n When the Image Dim operand is not SubpassData, the Image Format must not be Unknown, unless the StorageImageReadWithoutFormat Capability was declared.\n\nImage Operands encodes what operands follow, as per Image Operands.",
      "Category": "Image",
      "Capabilities": [],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 98,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageWrite",
      "Description": "<a id=\"OpImageWrite\"></a><strong>OpImageWrite</strong><br />\n<br />\nWrite a texel to an <a href=\"#ImageTerm\">image</a> without a <a href=\"#Sampler\">sampler</a>.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> with a <em>Sampled</em> operand of 0 or 2. If the <em>Sampled</em> operand is 2, then some <a href=\"#Dim\">dimensions</a> require a <a href=\"#Capability\">capability</a>; e.g., one of <strong>Image1D</strong>, <strong>ImageRect</strong>, <strong>ImageBuffer</strong>, <strong>ImageCubeArray</strong>, or <strong>ImageMSArray</strong>. Its <a href=\"#Dim\"><em>Dim</em></a> operand cannot be <strong>SubpassData</strong>.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing non-normalized texel coordinates (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Image</em>. If the coordinates are outside the image, the memory location that is accessed is undefined.<br />\n<br />\n<em>Texel</em> is the data to write. Its component type must be the same as <em>Sampled Type</em> of the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n The <a href=\"#Image_Format\"><em>Image Format</em></a> must not be <strong>Unknown</strong>, unless the <strong>StorageImageWriteWithoutFormat</strong> <a href=\"#Capability\">Capability</a> was declared.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
      "DescriptionPlain": "OpImageWrite\n\nWrite a texel to an image without a sampler.\n\nImage must be an object whose type is OpTypeImage with a Sampled operand of 0 or 2. If the Sampled operand is 2, then some dimensions require a capability; e.g., one of Image1D, ImageRect, ImageBuffer, ImageCubeArray, or ImageMSArray. Its Dim operand cannot be SubpassData.\n\nCoordinate is an integer scalar or vector containing non-normalized texel coordinates (u[, v] &#8230; [, array layer]) as needed by the definition of Image. If the coordinates are outside the image, the memory location that is accessed is undefined.\n\nTexel is the data to write. Its component type must be the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).\n\n The Image Format must not be Unknown, unless the StorageImageWriteWithoutFormat Capability was declared.\n\nImage Operands encodes what operands follow, as per Image Operands.",
      "Category": "Image",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 99,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Image",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Texel",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImage",
      "Description": "<a id=\"OpImage\"></a><strong>OpImage</strong><br />\n<br />\nExtract the image from a sampled image.<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must have type <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a> whose <em>Image Type</em> is the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpImage\n\nExtract the image from a sampled image.\n\nResult Type must be OpTypeImage.\n\nSampled Image must have type OpTypeSampledImage whose Image Type is the same as Result Type.",
      "Category": "Image",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 100,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageQueryFormat",
      "Description": "<a id=\"OpImageQueryFormat\"></a><strong>OpImageQueryFormat</strong><br />\n<br />\nQuery the image format of an image created with an <strong>Unknown</strong> <a href=\"#Image_Format\">Image Format</a>.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The resulting value is an enumerant from <a href=\"#Image_Channel_Data_Type\">Image Channel Data Type</a>.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.",
      "DescriptionPlain": "OpImageQueryFormat\n\nQuery the image format of an image created with an Unknown Image Format.\n\nResult Type must be a scalar integer type. The resulting value is an enumerant from Image Channel Data Type.\n\nImage must be an object whose type is OpTypeImage.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 101,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageQueryOrder",
      "Description": "<a id=\"OpImageQueryOrder\"></a><strong>OpImageQueryOrder</strong><br />\n<br />\nQuery the channel order of an image created with an <strong>Unknown</strong> <a href=\"#Image_Format\">Image Format</a>.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The resulting value is an enumerant from <a href=\"#Image_Channel_Order\">Image Channel Order</a>.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.",
      "DescriptionPlain": "OpImageQueryOrder\n\nQuery the channel order of an image created with an Unknown Image Format.\n\nResult Type must be a scalar integer type. The resulting value is an enumerant from Image Channel Order.\n\nImage must be an object whose type is OpTypeImage.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 102,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageQuerySizeLod",
      "Description": "<a id=\"OpImageQuerySizeLod\"></a><strong>OpImageQuerySizeLod</strong><br />\n<br />\nQuery the dimensions of <em>Image</em> for mipmap level for <em>Level of Detail</em>.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#Integer\">integer type</a> scalar or vector.  The number of components must be<br />\n1 for <strong>1D</strong> <a href=\"#Dim\"><em>Dim</em></a>,<br />\n2 for <strong>2D</strong>, and <strong>Cube</strong> <a href=\"#Dim\"><strong>Dimensionalities</strong></a>,<br />\n3 for <strong>3D</strong> <a href=\"#Dim\"><em>Dim</em></a>,<br />\nplus 1 more if the image type is arrayed. This vector is filled in with (<em>width</em> [, <em>height</em>] [, <em>depth</em>] [, <em>elements</em>]) where <em>elements</em> is the number of layers in an image array, or the number of cubes in a cube-map array.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>, and its <em>MS</em> must be 0. See <a href=\"#OpImageQuerySize\"><strong>OpImageQuerySize</strong></a> for querying image types without level of detail.<br />\n<br />\n<em>Level of Detail</em> is used to compute which mipmap level to query, as described in the API specification.",
      "DescriptionPlain": "OpImageQuerySizeLod\n\nQuery the dimensions of Image for mipmap level for Level of Detail.\n\nResult Type must be an integer type scalar or vector.  The number of components must be\n1 for 1D Dim,\n2 for 2D, and Cube Dimensionalities,\n3 for 3D Dim,\nplus 1 more if the image type is arrayed. This vector is filled in with (width [, height] [, depth] [, elements]) where elements is the number of layers in an image array, or the number of cubes in a cube-map array.\n\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube, and its MS must be 0. See OpImageQuerySize for querying image types without level of detail.\n\nLevel of Detail is used to compute which mipmap level to query, as described in the API specification.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 103,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        },
        {
          "Name": "LevelOfDetail",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageQuerySize",
      "Description": "<a id=\"OpImageQuerySize\"></a><strong>OpImageQuerySize</strong><br />\n<br />\nQuery the dimensions of <em>Image</em>, with no level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#Integer\">integer type</a> scalar or vector.  The number of components must be<br />\n1 for <strong>Buffer</strong> <a href=\"#Dim\"><em>Dim</em></a>,<br />\n2 for <strong>2D</strong> and <strong>Rect</strong> <a href=\"#Dim\"><strong>Dimensionalities</strong></a>,<br />\n3 for <strong>3D</strong> <a href=\"#Dim\"><em>Dim</em></a>,<br />\nplus 1 more if the image type is arrayed. This vector is filled in with (<em>width</em> [, <em>height</em>] [, <em>elements</em>]) where <em>elements</em> is the number of layers in an image array.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>Rect</strong> or <strong>Buffer</strong>, or if its <em>MS</em> is 1, it can be <strong>2D</strong>, or, if its <em>Sampled Type</em> is 0 or 2, it can be <strong>2D</strong> or <strong>3D</strong>. It cannot be an image with level of detail; there is no implicit level-of-detail consumed by this instruction. See <a href=\"#OpImageQuerySizeLod\"><strong>OpImageQuerySizeLod</strong></a> for querying images having level of detail.",
      "DescriptionPlain": "OpImageQuerySize\n\nQuery the dimensions of Image, with no level of detail.\n\nResult Type must be an integer type scalar or vector.  The number of components must be\n1 for Buffer Dim,\n2 for 2D and Rect Dimensionalities,\n3 for 3D Dim,\nplus 1 more if the image type is arrayed. This vector is filled in with (width [, height] [, elements]) where elements is the number of layers in an image array.\n\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of Rect or Buffer, or if its MS is 1, it can be 2D, or, if its Sampled Type is 0 or 2, it can be 2D or 3D. It cannot be an image with level of detail; there is no implicit level-of-detail consumed by this instruction. See OpImageQuerySizeLod for querying images having level of detail.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 104,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageQueryLod",
      "Description": "<a id=\"OpImageQueryLod\"></a><strong>OpImageQueryLod</strong><br />\n<br />\nQuery the mipmap level and the level of detail for a hypothetical sampling of <em>Image</em> at <em>Coordinate</em> using an implicit level of detail.<br />\n<br />\n<em>Result Type</em> must be a two-component <a href=\"#Floating\">floating-point type</a> vector.<br />\nThe first component of the result will contain the mipmap array layer.<br />\nThe second component of the result will contain the implicit level of detail relative to the base level.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; ) as needed by the definition of <em>Sampled Image</em>, not including any array layer index. Unless the <strong>Kernel</strong> <a href=\"#Capability\">capability</a> is being used, it must be floating point.<br />\n<br />\nIf called on an incomplete image, the results are undefined.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpImageQueryLod\n\nQuery the mipmap level and the level of detail for a hypothetical sampling of Image at Coordinate using an implicit level of detail.\n\nResult Type must be a two-component floating-point type vector.\nThe first component of the result will contain the mipmap array layer.\nThe second component of the result will contain the implicit level of detail relative to the base level.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube.\n\nCoordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] &#8230; ) as needed by the definition of Sampled Image, not including any array layer index. Unless the Kernel capability is being used, it must be floating point.\n\nIf called on an incomplete image, the results are undefined.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 105,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageQueryLevels",
      "Description": "<a id=\"OpImageQueryLevels\"></a><strong>OpImageQueryLevels</strong><br />\n<br />\nQuery the number of mipmap levels accessible through <em>Image</em>.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The result is the number of mipmap levels, as defined by the API specification.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>.",
      "DescriptionPlain": "OpImageQueryLevels\n\nQuery the number of mipmap levels accessible through Image.\n\nResult Type must be a scalar integer type. The result is the number of mipmap levels, as defined by the API specification.\n\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 106,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageQuerySamples",
      "Description": "<a id=\"OpImageQuerySamples\"></a><strong>OpImageQuerySamples</strong><br />\n<br />\nQuery the number of samples available per texel fetch in a multisample image.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The result is the number of samples.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>2D</strong> and <em>MS</em> of 1.",
      "DescriptionPlain": "OpImageQuerySamples\n\nQuery the number of samples available per texel fetch in a multisample image.\n\nResult Type must be a scalar integer type. The result is the number of samples.\n\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of 2D and MS of 1.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 107,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageSparseSampleImplicitLod",
      "Description": "<a id=\"OpImageSparseSampleImplicitLod\"></a><strong>OpImageSparseSampleImplicitLod</strong><br />\n<br />\nSample a sparse image with an implicit level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpImageSparseSampleImplicitLod\n\nSample a sparse image with an implicit level of detail.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 305,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseSampleExplicitLod",
      "Description": "<a id=\"OpImageSparseSampleExplicitLod\"></a><strong>OpImageSparseSampleExplicitLod</strong><br />\n<br />\nSample a sparse image using an explicit level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. Unless the <strong>Kernel</strong> <a href=\"#Capability\">capability</a> is being used, it must be floating point. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
      "DescriptionPlain": "OpImageSparseSampleExplicitLod\n\nSample a sparse image using an explicit level of detail.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. Unless the Kernel capability is being used, it must be floating point. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7 + variable",
      "WordCountFix": 7,
      "OpCode": 306,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "ImageOperands",
          "Type": "ImageOperands"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseSampleDrefImplicitLod",
      "Description": "<a id=\"OpImageSparseSampleDrefImplicitLod\"></a><strong>OpImageSparseSampleDrefImplicitLod</strong><br />\n<br />\nSample a sparse image doing depth-comparison with an implicit level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpImageSparseSampleDrefImplicitLod\n\nSample a sparse image doing depth-comparison with an implicit level of detail.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 307,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseSampleDrefExplicitLod",
      "Description": "<a id=\"OpImageSparseSampleDrefExplicitLod\"></a><strong>OpImageSparseSampleDrefExplicitLod</strong><br />\n<br />\nSample a sparse image doing depth-comparison using an explicit level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
      "DescriptionPlain": "OpImageSparseSampleDrefExplicitLod\n\nSample a sparse image doing depth-comparison using an explicit level of detail.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "8 + variable",
      "WordCountFix": 8,
      "OpCode": 308,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "ImageOperands",
          "Type": "ImageOperands"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseSampleProjImplicitLod",
      "Description": "<a id=\"OpImageSparseSampleProjImplicitLod\"></a><strong>OpImageSparseSampleProjImplicitLod</strong><br />\n<br />\nInstruction reserved for future use.  Use of this instruction is invalid.<br />\n<br />\n<span class=\"line-through\">Sample a sparse image with a projective coordinate and an implicit level of detail.</span>",
      "DescriptionPlain": "OpImageSparseSampleProjImplicitLod\n\nInstruction reserved for future use.  Use of this instruction is invalid.\n\nSample a sparse image with a projective coordinate and an implicit level of detail.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 309,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseSampleProjExplicitLod",
      "Description": "<a id=\"OpImageSparseSampleProjExplicitLod\"></a><strong>OpImageSparseSampleProjExplicitLod</strong><br />\n<br />\nInstruction reserved for future use.  Use of this instruction is invalid.<br />\n<br />\n<span class=\"line-through\">Sample a sparse image with a projective coordinate using an explicit level of detail.</span>",
      "DescriptionPlain": "OpImageSparseSampleProjExplicitLod\n\nInstruction reserved for future use.  Use of this instruction is invalid.\n\nSample a sparse image with a projective coordinate using an explicit level of detail.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7 + variable",
      "WordCountFix": 7,
      "OpCode": 310,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "ImageOperands",
          "Type": "ImageOperands"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseSampleProjDrefImplicitLod",
      "Description": "<a id=\"OpImageSparseSampleProjDrefImplicitLod\"></a><strong>OpImageSparseSampleProjDrefImplicitLod</strong><br />\n<br />\nInstruction reserved for future use.  Use of this instruction is invalid.<br />\n<br />\n<span class=\"line-through\">Sample a sparse image with a projective coordinate, doing depth-comparison, with an implicit level of detail.</span>",
      "DescriptionPlain": "OpImageSparseSampleProjDrefImplicitLod\n\nInstruction reserved for future use.  Use of this instruction is invalid.\n\nSample a sparse image with a projective coordinate, doing depth-comparison, with an implicit level of detail.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 311,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseSampleProjDrefExplicitLod",
      "Description": "<a id=\"OpImageSparseSampleProjDrefExplicitLod\"></a><strong>OpImageSparseSampleProjDrefExplicitLod</strong><br />\n<br />\nInstruction reserved for future use.  Use of this instruction is invalid.<br />\n<br />\n<span class=\"line-through\">Sample a sparse image with a projective coordinate, doing depth-comparison, using an explicit level of detail.</span>",
      "DescriptionPlain": "OpImageSparseSampleProjDrefExplicitLod\n\nInstruction reserved for future use.  Use of this instruction is invalid.\n\nSample a sparse image with a projective coordinate, doing depth-comparison, using an explicit level of detail.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "8 + variable",
      "WordCountFix": 8,
      "OpCode": 312,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "ImageOperands",
          "Type": "ImageOperands"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseFetch",
      "Description": "<a id=\"OpImageSparseFetch\"></a><strong>OpImageSparseFetch</strong><br />\n<br />\nFetch a single texel from a sampled sparse image.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand cannot be <strong>Cube</strong>.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
      "DescriptionPlain": "OpImageSparseFetch\n\nFetch a single texel from a sampled sparse image.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nImage must be an object whose type is OpTypeImage. Its Dim operand cannot be Cube.\n\nCoordinate is an integer scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nImage Operands encodes what operands follow, as per Image Operands.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 313,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseGather",
      "Description": "<a id=\"OpImageSparseGather\"></a><strong>OpImageSparseGather</strong><br />\n<br />\nGathers the requested component from four texels of a sparse image.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>). It has one component per gathered texel.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must have a <a href=\"#Dim\"><em>Dim</em></a> of <strong>2D</strong>, <strong>Cube</strong>, or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>Component</em> is the component number that will be gathered from all four texels. It must be 0, 1, 2 or 3.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
      "DescriptionPlain": "OpImageSparseGather\n\nGathers the requested component from four texels of a sparse image.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nComponent is the component number that will be gathered from all four texels. It must be 0, 1, 2 or 3.\n\nImage Operands encodes what operands follow, as per Image Operands.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 314,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Component",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseDrefGather",
      "Description": "<a id=\"OpImageSparseDrefGather\"></a><strong>OpImageSparseDrefGather</strong><br />\n<br />\nGathers the requested depth-comparison from four texels of a sparse image.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. It has one component per gathered texel.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must have a <a href=\"#Dim\"><em>Dim</em></a> of <strong>2D</strong>, <strong>Cube</strong>, or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
      "DescriptionPlain": "OpImageSparseDrefGather\n\nGathers the requested depth-comparison from four texels of a sparse image.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage. It has one component per gathered texel.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 315,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledImage",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpImageSparseTexelsResident",
      "Description": "<a id=\"OpImageSparseTexelsResident\"></a><strong>OpImageSparseTexelsResident</strong><br />\n<br />\nTranslates a <em>Resident Code</em> into a Boolean. Result is <strong>false</strong> if any of the texels were in uncommitted texture memory, and <strong>true</strong> otherwise.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar. <br />\n<br />\n<em>Resident Code</em> is a value from an <strong>OpImageSparse&#8230;</strong> instruction that returns a resident code.",
      "DescriptionPlain": "OpImageSparseTexelsResident\n\nTranslates a Resident Code into a Boolean. Result is false if any of the texels were in uncommitted texture memory, and true otherwise.\n\n Result Type must be a Boolean type scalar. \n\nResident Code is a value from an OpImageSparse&#8230; instruction that returns a resident code.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 316,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ResidentCode",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpImageSparseRead",
      "Description": "<a id=\"OpImageSparseRead\"></a><strong>OpImageSparseRead</strong><br />\n<br />\nRead a texel from a sparse <a href=\"#ImageTerm\">image</a> without a <a href=\"#Sampler\">sampler</a>.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its component type must be the same as <em>Sampled Type</em> of the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> with a <em>Sampled</em> operand of 2.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing non-normalized texel coordinates (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Image</em>. If the coordinates are outside the image, the memory location that is accessed is undefined.<br />\n<br />\n The <a href=\"#Image_Format\"><em>Image Format</em></a> must not be <strong>Unknown</strong>, unless the <strong>StorageImageReadWithoutFormat</strong> <a href=\"#Capability\">Capability</a> was declared.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
      "DescriptionPlain": "OpImageSparseRead\n\nRead a texel from a sparse image without a sampler.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar or vector of floating-point type or integer type.  Its component type must be the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).\n\nImage must be an object whose type is OpTypeImage with a Sampled operand of 2.\n\nCoordinate is an integer scalar or vector containing non-normalized texel coordinates (u[, v] &#8230; [, array layer]) as needed by the definition of Image. If the coordinates are outside the image, the memory location that is accessed is undefined.\n\n The Image Format must not be Unknown, unless the StorageImageReadWithoutFormat Capability was declared.\n\nImage Operands encodes what operands follow, as per Image Operands.",
      "Category": "Image",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 320,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Optional",
          "Type": "ImageOperands?"
        },
        {
          "Name": "Optional",
          "Type": "ID[]?"
        }
      ]
    },
    {
      "Name": "OpConvertFToU",
      "Description": "<a id=\"OpConvertFToU\"></a><strong>OpConvertFToU</strong><br />\n<br />\nConvert (value preserving) from floating point to unsigned integer, with round toward 0.0.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Float Value</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpConvertFToU\n\nConvert (value preserving) from floating point to unsigned integer, with round toward 0.0.\n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nFloat Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 109,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "FloatValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertFToS",
      "Description": "<a id=\"OpConvertFToS\"></a><strong>OpConvertFToS</strong><br />\n<br />\nConvert (value preserving) from floating point to signed integer, with round toward 0.0.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Float Value</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpConvertFToS\n\nConvert (value preserving) from floating point to signed integer, with round toward 0.0.\n\n Result Type must be a scalar or vector of integer type. \n\nFloat Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 110,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "FloatValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertSToF",
      "Description": "<a id=\"OpConvertSToF\"></a><strong>OpConvertSToF</strong><br />\n<br />\nConvert (value preserving) from signed integer to floating point.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Signed Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpConvertSToF\n\nConvert (value preserving) from signed integer to floating point.\n\n Result Type must be a scalar or vector of floating-point type. \n\nSigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 111,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertUToF",
      "Description": "<a id=\"OpConvertUToF\"></a><strong>OpConvertUToF</strong><br />\n<br />\nConvert (value preserving) from unsigned integer to floating point.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Unsigned Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpConvertUToF\n\nConvert (value preserving) from unsigned integer to floating point.\n\n Result Type must be a scalar or vector of floating-point type. \n\nUnsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 112,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "UnsignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUConvert",
      "Description": "<a id=\"OpUConvert\"></a><strong>OpUConvert</strong><br />\n<br />\nConvert (value preserving) unsigned width. This is either a truncate or a zero extend.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Unsigned Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width cannot equal the component width in <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpUConvert\n\nConvert (value preserving) unsigned width. This is either a truncate or a zero extend.\n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nUnsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width cannot equal the component width in Result Type. \n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 113,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "UnsignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSConvert",
      "Description": "<a id=\"OpSConvert\"></a><strong>OpSConvert</strong><br />\n<br />\nConvert (value preserving) signed width.  This is either a truncate or a sign extend.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Signed Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width cannot equal the component width in <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSConvert\n\nConvert (value preserving) signed width.  This is either a truncate or a sign extend.\n\n Result Type must be a scalar or vector of integer type. \n\nSigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width cannot equal the component width in Result Type. \n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 114,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFConvert",
      "Description": "<a id=\"OpFConvert\"></a><strong>OpFConvert</strong><br />\n<br />\nConvert (value preserving) floating-point width.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Float Value</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width cannot equal the component width in <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFConvert\n\nConvert (value preserving) floating-point width.\n\n Result Type must be a scalar or vector of floating-point type. \n\nFloat Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.  The component width cannot equal the component width in Result Type. \n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 115,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "FloatValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpQuantizeToF16",
      "Description": "<a id=\"OpQuantizeToF16\"></a><strong>OpQuantizeToF16</strong><br />\n<br />\nQuantize a floating-point value to what is expressible by a 16-bit floating-point value.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. The component width must be 32 bits.<br />\n<br />\n<em>Value</em> is the value to quantize. The type of <em>Value</em> must be the same as <em>Result Type</em>. <br />\n<br />\n If <em>Value</em> is an infinity, the result is the same infinity. If <em>Value</em> is a NaN, the result is a NaN, but not necessarily the same NaN. If <em>Value</em> is positive with a magnitude too large to represent as a 16-bit floating-point value, the result is positive infinity. If <em>Value</em> is negative with a magnitude too large to represent as a 16-bit floating-point value, the result is negative infinity. If the magnitude of <em>Value</em> is too small to represent as a normalized 16-bit floating-point value, the result is 0.<br />\n<br />\nThe <strong>RelaxedPrecision</strong> <a href=\"#Decoration\">Decoration</a> has no effect on this instruction.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpQuantizeToF16\n\nQuantize a floating-point value to what is expressible by a 16-bit floating-point value.\n\n Result Type must be a scalar or vector of floating-point type. The component width must be 32 bits.\n\nValue is the value to quantize. The type of Value must be the same as Result Type. \n\n If Value is an infinity, the result is the same infinity. If Value is a NaN, the result is a NaN, but not necessarily the same NaN. If Value is positive with a magnitude too large to represent as a 16-bit floating-point value, the result is positive infinity. If Value is negative with a magnitude too large to represent as a 16-bit floating-point value, the result is negative infinity. If the magnitude of Value is too small to represent as a normalized 16-bit floating-point value, the result is 0.\n\nThe RelaxedPrecision Decoration has no effect on this instruction.\n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 116,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertPtrToU",
      "Description": "<a id=\"OpConvertPtrToU\"></a><strong>OpConvertPtrToU</strong><br />\n<br />\nConvert a pointer to an unsigned integer type. A <em>Result Type</em> width larger than the width of <em>Pointer</em> will zero extend. A <em>Result Type</em> smaller than the width of <em>Pointer</em> will truncate. For same-width source and result, this is the same as <a href=\"#OpBitcast\"><strong>OpBitcast</strong></a>. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0.",
      "DescriptionPlain": "OpConvertPtrToU\n\nConvert a pointer to an unsigned integer type. A Result Type width larger than the width of Pointer will zero extend. A Result Type smaller than the width of Pointer will truncate. For same-width source and result, this is the same as OpBitcast. \n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0.",
      "Category": "Conversion",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 117,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSatConvertSToU",
      "Description": "<a id=\"OpSatConvertSToU\"></a><strong>OpSatConvertSToU</strong><br />\n<br />\nConvert a signed integer to unsigned integer. Converted values outside the representable range of <em>Result Type</em> are clamped to the nearest representable value of <em>Result Type</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Signed Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSatConvertSToU\n\nConvert a signed integer to unsigned integer. Converted values outside the representable range of Result Type are clamped to the nearest representable value of Result Type.\n\n Result Type must be a scalar or vector of integer type. \n\nSigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 118,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSatConvertUToS",
      "Description": "<a id=\"OpSatConvertUToS\"></a><strong>OpSatConvertUToS</strong><br />\n<br />\nConvert an unsigned integer to signed integer.  Converted values outside the representable range of <em>Result Type</em> are clamped to the nearest representable value of <em>Result Type</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Unsigned Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSatConvertUToS\n\nConvert an unsigned integer to signed integer.  Converted values outside the representable range of Result Type are clamped to the nearest representable value of Result Type.\n\n Result Type must be a scalar or vector of integer type. \n\nUnsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "Conversion",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 119,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "UnsignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertUToPtr",
      "Description": "<a id=\"OpConvertUToPtr\"></a><strong>OpConvertUToPtr</strong><br />\n<br />\nConvert an integer to pointer. A <em>Result Type</em> width smaller than the width of <em>Integer Value</em> pointer will truncate. A <em>Result Type</em> width larger than the width of <em>Integer Value</em> pointer will zero extend. <br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. For same-width source and result, this is the same as <a href=\"#OpBitcast\"><strong>OpBitcast</strong></a>.",
      "DescriptionPlain": "OpConvertUToPtr\n\nConvert an integer to pointer. A Result Type width smaller than the width of Integer Value pointer will truncate. A Result Type width larger than the width of Integer Value pointer will zero extend. \n\n Result Type must be an OpTypePointer. For same-width source and result, this is the same as OpBitcast.",
      "Category": "Conversion",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 120,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "IntegerValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpPtrCastToGeneric",
      "Description": "<a id=\"OpPtrCastToGeneric\"></a><strong>OpPtrCastToGeneric</strong><br />\n<br />\nConvert a pointer&#8217;s Storage Class to <strong>Generic</strong>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <a href=\"#Storage_Class\">Storage Class</a> must be <strong>Generic</strong>.<br />\n<br />\n<em>Pointer</em> must point to the <strong>Workgroup</strong>, <strong>CrossWorkgroup</strong>, or <strong>Function</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Result Type</em> and <em>Pointer</em> must point to the same type.",
      "DescriptionPlain": "OpPtrCastToGeneric\n\nConvert a pointer&#8217;s Storage Class to Generic.\n\n Result Type must be an OpTypePointer. Its Storage Class must be Generic.\n\nPointer must point to the Workgroup, CrossWorkgroup, or Function Storage Class.\n\nResult Type and Pointer must point to the same type.",
      "Category": "Conversion",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 121,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGenericCastToPtr",
      "Description": "<a id=\"OpGenericCastToPtr\"></a><strong>OpGenericCastToPtr</strong><br />\n<br />\nConvert a pointer&#8217;s Storage Class to a non-<strong>Generic</strong> class.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <a href=\"#Storage_Class\">Storage Class</a> must be <strong>Workgroup</strong>, <strong>CrossWorkgroup</strong>, or <strong>Function</strong>.<br />\n<br />\n<em>Pointer</em> must point to the <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Result Type</em> and <em>Pointer</em> must point to the same type.",
      "DescriptionPlain": "OpGenericCastToPtr\n\nConvert a pointer&#8217;s Storage Class to a non-Generic class.\n\n Result Type must be an OpTypePointer. Its Storage Class must be Workgroup, CrossWorkgroup, or Function.\n\nPointer must point to the Generic Storage Class.\n\nResult Type and Pointer must point to the same type.",
      "Category": "Conversion",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 122,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGenericCastToPtrExplicit",
      "Description": "<a id=\"OpGenericCastToPtrExplicit\"></a><strong>OpGenericCastToPtrExplicit</strong><br />\n<br />\nAttempts to explicitly convert <em>Pointer</em> to <em>Storage</em> storage-class pointer value. <br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <a href=\"#Storage_Class\">Storage Class</a> must be <em>Storage</em>.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose <em>Type</em> is the same as the <em>Type</em> of <em>Result Type</em>.<em>Pointer</em> must point to the <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>. If the cast fails, the instruction result is an <a href=\"#OpConstantNull\"><strong>OpConstantNull</strong></a> pointer in the <em>Storage</em> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Storage</em> must be one of the following literal values from <a href=\"#Storage_Class\">Storage Class</a>: <strong>Workgroup</strong>, <strong>CrossWorkgroup</strong>, or <strong>Function</strong>.",
      "DescriptionPlain": "OpGenericCastToPtrExplicit\n\nAttempts to explicitly convert Pointer to Storage storage-class pointer value. \n\n Result Type must be an OpTypePointer. Its Storage Class must be Storage.\n\nPointer must have a type of OpTypePointer whose Type is the same as the Type of Result Type.Pointer must point to the Generic Storage Class. If the cast fails, the instruction result is an OpConstantNull pointer in the Storage Storage Class.\n\nStorage must be one of the following literal values from Storage Class: Workgroup, CrossWorkgroup, or Function.",
      "Category": "Conversion",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 123,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Storage",
          "Type": "StorageClass"
        }
      ]
    },
    {
      "Name": "OpBitcast",
      "Description": "<a id=\"OpBitcast\"></a><strong>OpBitcast</strong><br />\n<br />\nBit pattern-preserving type conversion.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>, or a scalar or vector of <a href=\"#Numerical\"><em>numerical-type</em></a>.<br />\n<br />\n<em>Operand</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>, or a scalar or vector of <a href=\"#Numerical\"><em>numerical-type</em></a>. It must be a different type than <em>Result Type</em>.<br />\n<br />\n If <em>Result Type</em> is a pointer, <em>Operand</em> must be a pointer or integer scalar. If <em>Operand</em> is a pointer, <em>Result Type</em> must be a pointer or integer scalar.<br />\n<br />\nIf <em>Result Type</em> has the same number of components as <em>Operand</em>, they must also have the same component width, and results are computed per component.<br />\n<br />\nIf <em>Result Type</em> has a different number of components than <em>Operand</em>, the total number of bits in <em>Result Type</em> must equal the total number of bits in <em>Operand</em>. Let <em>L</em> be the type, either <em>Result Type</em> or <em>Operand&#8217;s</em> type, that has the larger number of components. Let <em>S</em> be the other type, with the smaller number of components. The number of components in <em>L</em> must be an integer multiple of the number of components in <em>S</em>. The first component (that is, the only or lowest-numbered component) of <em>S</em> maps to the first components of <em>L</em>, and so on,  up to the last component of <em>S</em> mapping to the last components of <em>L</em>. Within this mapping, any single component of <em>S</em> (mapping to multiple components of <em>L</em>) maps its lower-ordered bits to the lower-numbered components of <em>L</em>.",
      "DescriptionPlain": "OpBitcast\n\nBit pattern-preserving type conversion.\n\nResult Type must be an OpTypePointer, or a scalar or vector of numerical-type.\n\nOperand must have a type of OpTypePointer, or a scalar or vector of numerical-type. It must be a different type than Result Type.\n\n If Result Type is a pointer, Operand must be a pointer or integer scalar. If Operand is a pointer, Result Type must be a pointer or integer scalar.\n\nIf Result Type has the same number of components as Operand, they must also have the same component width, and results are computed per component.\n\nIf Result Type has a different number of components than Operand, the total number of bits in Result Type must equal the total number of bits in Operand. Let L be the type, either Result Type or Operand&#8217;s type, that has the larger number of components. Let S be the other type, with the smaller number of components. The number of components in L must be an integer multiple of the number of components in S. The first component (that is, the only or lowest-numbered component) of S maps to the first components of L, and so on,  up to the last component of S mapping to the last components of L. Within this mapping, any single component of S (mapping to multiple components of L) maps its lower-ordered bits to the lower-numbered components of L.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 124,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpVectorExtractDynamic",
      "Description": "<a id=\"OpVectorExtractDynamic\"></a><strong>OpVectorExtractDynamic</strong><br />\n<br />\nExtract a single, dynamically selected, component of a vector.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Scalar\">scalar</a> type.<br />\n<br />\n<em>Vector</em> must have a type <a href=\"#OpTypeVector\"><strong>OpTypeVector</strong></a> whose <em>Component Type</em> is <em>Result Type</em>.<br />\n<br />\n<em>Index</em> must be a scalar <a href=\"#Integer\">integer</a> 0-based index of which component of <em>Vector</em> to extract.<br />\n<br />\nThe value read is undefined if <em>Index&#8217;s</em> value is less than zero or greater than or equal to the number of components in <em>Vector</em>.",
      "DescriptionPlain": "OpVectorExtractDynamic\n\nExtract a single, dynamically selected, component of a vector.\n\nResult Type must be a scalar type.\n\nVector must have a type OpTypeVector whose Component Type is Result Type.\n\nIndex must be a scalar integer 0-based index of which component of Vector to extract.\n\nThe value read is undefined if Index&#8217;s value is less than zero or greater than or equal to the number of components in Vector.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 77,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        },
        {
          "Name": "Index",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpVectorInsertDynamic",
      "Description": "<a id=\"OpVectorInsertDynamic\"></a><strong>OpVectorInsertDynamic</strong><br />\n<br />\nMake a copy of a vector, with a single, variably selected, component modified.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeVector\"><strong>OpTypeVector</strong></a>.<br />\n<br />\n<em>Vector</em> must have the same type as <em>Result Type</em> and is the vector that the non-written components will be copied from.<br />\n<br />\n<em>Component</em> is the value that will be supplied for the component selected by <em>Index</em>. It must have the same type as the type of components in <em>Result Type</em>.<br />\n<br />\n<em>Index</em> must be a scalar <a href=\"#Integer\">integer</a> 0-based index of which component to modify.<br />\n<br />\nWhat is written is undefined if <em>Index&#8217;s</em> value is less than zero or greater than or equal to the number of components in <em>Vector</em>.",
      "DescriptionPlain": "OpVectorInsertDynamic\n\nMake a copy of a vector, with a single, variably selected, component modified.\n\nResult Type must be an OpTypeVector.\n\nVector must have the same type as Result Type and is the vector that the non-written components will be copied from.\n\nComponent is the value that will be supplied for the component selected by Index. It must have the same type as the type of components in Result Type.\n\nIndex must be a scalar integer 0-based index of which component to modify.\n\nWhat is written is undefined if Index&#8217;s value is less than zero or greater than or equal to the number of components in Vector.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 78,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        },
        {
          "Name": "Component",
          "Type": "ID"
        },
        {
          "Name": "Index",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpVectorShuffle",
      "Description": "<a id=\"OpVectorShuffle\"></a><strong>OpVectorShuffle</strong><br />\n<br />\nSelect arbitrary components from two vectors to make a new vector.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeVector\"><strong>OpTypeVector</strong></a>. The number of components in <em>Result Type</em> must be the same as the number of <em>Component</em> operands.<br />\n<br />\n<em>Vector 1</em> and <em>Vector 2</em> must both have vector types, with the same <em>Component Type</em> as <em>Result Type</em>. They do not have to have the same number of components as <em>Result Type</em> or with each other. They are logically concatenated, forming a single vector with <em>Vector 1&#8217;s</em> components appearing before <em>Vector 2&#8217;s</em>. The components of this logical vector are logically numbered with a single consecutive set of numbers from 0 to <em>N</em> - 1, where <em>N</em> is the total number of components.<br />\n<br />\n<em>Components</em> are these logical numbers (see above), selecting which of the logically numbered components form the result. They can select the components in any order and can repeat components. The first component of the result is selected by the first <em>Component</em> operand,  the second component of the result is selected by the second <em>Component</em> operand, etc. A <em>Component literal</em> may also be FFFFFFFF, which means the corresponding result component has no source and is undefined. All <em>Component literals</em> must either be FFFFFFFF or in [0, <em>N</em> - 1] (<a href=\"#Inclusive\">inclusive</a>).<br />\n<br />\n<strong>Note:</strong> A vector &#8220;swizzle&#8221; can be done by using the vector for both <em>Vector</em> operands, or using an <a href=\"#OpUndef\"><strong>OpUndef</strong></a> for one of the <em>Vector</em> operands.",
      "DescriptionPlain": "OpVectorShuffle\n\nSelect arbitrary components from two vectors to make a new vector.\n\nResult Type must be an OpTypeVector. The number of components in Result Type must be the same as the number of Component operands.\n\nVector 1 and Vector 2 must both have vector types, with the same Component Type as Result Type. They do not have to have the same number of components as Result Type or with each other. They are logically concatenated, forming a single vector with Vector 1&#8217;s components appearing before Vector 2&#8217;s. The components of this logical vector are logically numbered with a single consecutive set of numbers from 0 to N - 1, where N is the total number of components.\n\nComponents are these logical numbers (see above), selecting which of the logically numbered components form the result. They can select the components in any order and can repeat components. The first component of the result is selected by the first Component operand,  the second component of the result is selected by the second Component operand, etc. A Component literal may also be FFFFFFFF, which means the corresponding result component has no source and is undefined. All Component literals must either be FFFFFFFF or in [0, N - 1] (inclusive).\n\nNote: A vector &#8220;swizzle&#8221; can be done by using the vector for both Vector operands, or using an OpUndef for one of the Vector operands.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 79,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector1",
          "Type": "ID"
        },
        {
          "Name": "Vector2",
          "Type": "ID"
        },
        {
          "Name": null,
          "Type": null
        }
      ]
    },
    {
      "Name": "OpCompositeConstruct",
      "Description": "<a id=\"OpCompositeConstruct\"></a><strong>OpCompositeConstruct</strong><br />\n<br />\nConstruct a new <a href=\"#CompositeType\"><em>composite</em></a> object from a set of constituent objects that will fully form it.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#CompositeType\"><em>composite</em></a> type, whose top-level members/elements/components/columns have the same type as the types of the operands, with one exception. The exception is that for constructing a vector, the operands may also be vectors with the same component type as the <em>Result Type</em> component type. When constructing a vector, the total number of components in all the operands must equal the number of components in <em>Result Type</em>.<br />\n<br />\n<em>Constituents</em> will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one <em>Constituent</em> for each top-level member/element/component/column of the result, with one exception. The exception is that for constructing a vector, a contiguous subset of the scalars consumed can be represented by a vector operand instead. The <em>Constituents</em> must appear in the order needed by the definition of the type of the result. When constructing a vector, there must be at least two <em>Constituent</em> operands.",
      "DescriptionPlain": "OpCompositeConstruct\n\nConstruct a new composite object from a set of constituent objects that will fully form it.\n\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the operands, with one exception. The exception is that for constructing a vector, the operands may also be vectors with the same component type as the Result Type component type. When constructing a vector, the total number of components in all the operands must equal the number of components in Result Type.\n\nConstituents will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result, with one exception. The exception is that for constructing a vector, a contiguous subset of the scalars consumed can be represented by a vector operand instead. The Constituents must appear in the order needed by the definition of the type of the result. When constructing a vector, there must be at least two Constituent operands.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 80,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Constituents",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpCompositeExtract",
      "Description": "<a id=\"OpCompositeExtract\"></a><strong>OpCompositeExtract</strong><br />\n<br />\nExtract a part of a <a href=\"#CompositeType\"><em>composite</em></a> object. <br />\n<br />\n<em>Result Type</em> must be the type of object selected by the last provided index.  The instruction result is the extracted object.<br />\n<br />\n<em>Composite</em> is the composite to extract from.<br />\n<br />\n<em>Indexes</em> walk the type hierarchy, potentially down to component granularity, to select the part to extract. All indexes must be in bounds.  All composite constituents use zero-based numbering, as described by their <strong>OpType&#8230;</strong> instruction.",
      "DescriptionPlain": "OpCompositeExtract\n\nExtract a part of a composite object. \n\nResult Type must be the type of object selected by the last provided index.  The instruction result is the extracted object.\n\nComposite is the composite to extract from.\n\nIndexes walk the type hierarchy, potentially down to component granularity, to select the part to extract. All indexes must be in bounds.  All composite constituents use zero-based numbering, as described by their OpType&#8230; instruction.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 81,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Composite",
          "Type": "ID"
        },
        {
          "Name": null,
          "Type": null
        }
      ]
    },
    {
      "Name": "OpCompositeInsert",
      "Description": "<a id=\"OpCompositeInsert\"></a><strong>OpCompositeInsert</strong><br />\n<br />\nMake a copy of a <a href=\"#CompositeType\"><em>composite</em></a> object, while modifying one part of it.<br />\n<br />\n<em>Result Type</em> must be the same type as <em>Composite</em>.<br />\n<br />\n<em>Object</em> is the object to use as the modified part.<br />\n<br />\n<em>Composite</em> is the composite to copy all but the modified part from.<br />\n<br />\n<em>Indexes</em> walk the type hierarchy of <em>Composite</em> to the desired depth, potentially down to component granularity, to select the part to modify. All indexes must be in bounds. All composite constituents use zero-based numbering, as described by their <strong>OpType&#8230;</strong> instruction. The type of the part selected to modify must match the type of <em>Object</em>.",
      "DescriptionPlain": "OpCompositeInsert\n\nMake a copy of a composite object, while modifying one part of it.\n\nResult Type must be the same type as Composite.\n\nObject is the object to use as the modified part.\n\nComposite is the composite to copy all but the modified part from.\n\nIndexes walk the type hierarchy of Composite to the desired depth, potentially down to component granularity, to select the part to modify. All indexes must be in bounds. All composite constituents use zero-based numbering, as described by their OpType&#8230; instruction. The type of the part selected to modify must match the type of Object.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 82,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Composite",
          "Type": "ID"
        },
        {
          "Name": null,
          "Type": null
        }
      ]
    },
    {
      "Name": "OpCopyObject",
      "Description": "<a id=\"OpCopyObject\"></a><strong>OpCopyObject</strong><br />\n<br />\nMake a copy of <em>Operand</em>. There are no dereferences involved.<br />\n<br />\n<em>Result Type</em> must match <em>Operand</em> type.  There are no other restrictions on the types.",
      "DescriptionPlain": "OpCopyObject\n\nMake a copy of Operand. There are no dereferences involved.\n\nResult Type must match Operand type.  There are no other restrictions on the types.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 83,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTranspose",
      "Description": "<a id=\"OpTranspose\"></a><strong>OpTranspose</strong><br />\n<br />\nTranspose a matrix.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a>, where the number of columns and the column size is the reverse of those of the type of <em>Matrix</em>.<br />\n<br />\n<em>Matrix</em> must have of type of <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a>.",
      "DescriptionPlain": "OpTranspose\n\nTranspose a matrix.\n\nResult Type must be an OpTypeMatrix, where the number of columns and the column size is the reverse of those of the type of Matrix.\n\nMatrix must have of type of OpTypeMatrix.",
      "Category": "Composite",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 84,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Matrix",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSNegate",
      "Description": "<a id=\"OpSNegate\"></a><strong>OpSNegate</strong><br />\n<br />\nSigned-integer subtract of <em>Operand</em> from zero.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n <em>Operand&#8217;s</em> type  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width must equal the component width in <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSNegate\n\nSigned-integer subtract of Operand from zero.\n\n Result Type must be a scalar or vector of integer type. \n\n Operand&#8217;s type  must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must equal the component width in Result Type. \n\n Results are computed per component.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 126,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFNegate",
      "Description": "<a id=\"OpFNegate\"></a><strong>OpFNegate</strong><br />\n<br />\nFloating-point subtract of <em>Operand</em> from zero.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>Operand</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFNegate\n\nFloating-point subtract of Operand from zero.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of Operand must be the same as Result Type. \n\n Results are computed per component.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 127,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIAdd",
      "Description": "<a id=\"OpIAdd\"></a><strong>OpIAdd</strong><br />\n<br />\nInteger addition of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpIAdd\n\nInteger addition of Operand 1 and Operand 2.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 128,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFAdd",
      "Description": "<a id=\"OpFAdd\"></a><strong>OpFAdd</strong><br />\n<br />\nFloating-point addition of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFAdd\n\nFloating-point addition of Operand 1 and Operand 2.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 129,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpISub",
      "Description": "<a id=\"OpISub\"></a><strong>OpISub</strong><br />\n<br />\nInteger subtraction of <em>Operand 2</em> from <em>Operand 1</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpISub\n\nInteger subtraction of Operand 2 from Operand 1.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 130,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFSub",
      "Description": "<a id=\"OpFSub\"></a><strong>OpFSub</strong><br />\n<br />\nFloating-point subtraction of <em>Operand 2</em> from <em>Operand 1</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFSub\n\nFloating-point subtraction of Operand 2 from Operand 1.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 131,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIMul",
      "Description": "<a id=\"OpIMul\"></a><strong>OpIMul</strong><br />\n<br />\nInteger multiplication of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpIMul\n\nInteger multiplication of Operand 1 and Operand 2.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 132,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFMul",
      "Description": "<a id=\"OpFMul\"></a><strong>OpFMul</strong><br />\n<br />\nFloating-point multiplication of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFMul\n\nFloating-point multiplication of Operand 1 and Operand 2.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 133,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUDiv",
      "Description": "<a id=\"OpUDiv\"></a><strong>OpUDiv</strong><br />\n<br />\nUnsigned-integer division of <em>Operand 1</em> divided by <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpUDiv\n\nUnsigned-integer division of Operand 1 divided by Operand 2.\n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 134,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSDiv",
      "Description": "<a id=\"OpSDiv\"></a><strong>OpSDiv</strong><br />\n<br />\nSigned-integer division of <em>Operand 1</em> divided by <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpSDiv\n\nSigned-integer division of Operand 1 divided by Operand 2.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 135,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFDiv",
      "Description": "<a id=\"OpFDiv\"></a><strong>OpFDiv</strong><br />\n<br />\nFloating-point division of <em>Operand 1</em> divided by <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpFDiv\n\nFloating-point division of Operand 1 divided by Operand 2.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 136,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUMod",
      "Description": "<a id=\"OpUMod\"></a><strong>OpUMod</strong><br />\n<br />\nUnsigned modulo operation of <em>Operand 1</em> modulo <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpUMod\n\nUnsigned modulo operation of Operand 1 modulo Operand 2.\n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 137,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSRem",
      "Description": "<a id=\"OpSRem\"></a><strong>OpSRem</strong><br />\n<br />\nSigned remainder operation of <em>Operand 1</em> divided by <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 1</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpSRem\n\nSigned remainder operation of Operand 1 divided by Operand 2.  The sign of a non-0 result comes from Operand 1.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 138,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSMod",
      "Description": "<a id=\"OpSMod\"></a><strong>OpSMod</strong><br />\n<br />\nSigned modulo operation of <em>Operand 1</em> modulo <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpSMod\n\nSigned modulo operation of Operand 1 modulo Operand 2.  The sign of a non-0 result comes from Operand 2.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 139,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFRem",
      "Description": "<a id=\"OpFRem\"></a><strong>OpFRem</strong><br />\n<br />\nFloating-point remainder operation of <em>Operand 1</em> divided by <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 1</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpFRem\n\nFloating-point remainder operation of Operand 1 divided by Operand 2.  The sign of a non-0 result comes from Operand 1.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 140,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFMod",
      "Description": "<a id=\"OpFMod\"></a><strong>OpFMod</strong><br />\n<br />\nFloating-point remainder operation of <em>Operand 1</em> divided by <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpFMod\n\nFloating-point remainder operation of Operand 1 divided by Operand 2.  The sign of a non-0 result comes from Operand 2.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 141,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpVectorTimesScalar",
      "Description": "<a id=\"OpVectorTimesScalar\"></a><strong>OpVectorTimesScalar</strong><br />\n<br />\nScale a floating-point vector.<br />\n<br />\n <em>Result Type</em> must be a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>Vector</em> must be the same as <em>Result Type</em>. Each component of <em>Vector</em> is multiplied by <em>Scalar</em>.<br />\n<br />\n<em>Scalar</em> must have the same type as the <em>Component Type</em> in <em>Result Type</em>.",
      "DescriptionPlain": "OpVectorTimesScalar\n\nScale a floating-point vector.\n\n Result Type must be a vector of floating-point type. \n\n The type of Vector must be the same as Result Type. Each component of Vector is multiplied by Scalar.\n\nScalar must have the same type as the Component Type in Result Type.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 142,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        },
        {
          "Name": "Scalar",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpMatrixTimesScalar",
      "Description": "<a id=\"OpMatrixTimesScalar\"></a><strong>OpMatrixTimesScalar</strong><br />\n<br />\nScale a floating-point matrix.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> whose <em>Column Type</em> is a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>Matrix</em> must be the same as <em>Result Type</em>. Each component in each column in <em>Matrix</em> is multiplied by <em>Scalar</em>.<br />\n<br />\n<em>Scalar</em> must have the same type as the <em>Component Type</em> in <em>Result Type</em>.",
      "DescriptionPlain": "OpMatrixTimesScalar\n\nScale a floating-point matrix.\n\n Result Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type. \n\n The type of Matrix must be the same as Result Type. Each component in each column in Matrix is multiplied by Scalar.\n\nScalar must have the same type as the Component Type in Result Type.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 143,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Matrix",
          "Type": "ID"
        },
        {
          "Name": "Scalar",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpVectorTimesMatrix",
      "Description": "<a id=\"OpVectorTimesMatrix\"></a><strong>OpVectorTimesMatrix</strong><br />\n<br />\nLinear-algebraic <em>Vector X Matrix</em>.<br />\n<br />\n <em>Result Type</em> must be a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Vector</em> must be a vector with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of components must equal the number of components in each column in <em>Matrix</em>.<br />\n<br />\n<em>Matrix</em> must be a matrix with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of columns must equal the number of components in <em>Result Type</em>.",
      "DescriptionPlain": "OpVectorTimesMatrix\n\nLinear-algebraic Vector X Matrix.\n\n Result Type must be a vector of floating-point type. \n\nVector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of components in each column in Matrix.\n\nMatrix must be a matrix with the same Component Type as the Component Type in Result Type. Its number of columns must equal the number of components in Result Type.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 144,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        },
        {
          "Name": "Matrix",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpMatrixTimesVector",
      "Description": "<a id=\"OpMatrixTimesVector\"></a><strong>OpMatrixTimesVector</strong><br />\n<br />\nLinear-algebraic <em>Vector X Matrix</em>.<br />\n<br />\n <em>Result Type</em> must be a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Matrix</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> whose <em>Column Type</em> is <em>Result Type</em>.<br />\n<br />\n<em>Vector</em> must be a vector with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of components must equal the number of columns in <em>Matrix</em>.",
      "DescriptionPlain": "OpMatrixTimesVector\n\nLinear-algebraic Vector X Matrix.\n\n Result Type must be a vector of floating-point type. \n\nMatrix must be an OpTypeMatrix whose Column Type is Result Type.\n\nVector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Matrix.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 145,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Matrix",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpMatrixTimesMatrix",
      "Description": "<a id=\"OpMatrixTimesMatrix\"></a><strong>OpMatrixTimesMatrix</strong><br />\n<br />\nLinear-algebraic multiply of <em>LeftMatrix</em> X <em>RightMatrix</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> whose <em>Column Type</em> is a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>LeftMatrix</em> must be a matrix whose <em>Column Type</em> is the same as the <em>Column Type</em> in <em>Result Type</em>.<br />\n<br />\n<em>RightMatrix</em> must be a matrix with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of columns must equal the number of columns in <em>Result Type</em>. Its columns must have the same number of components as the number of columns in <em>LeftMatrix</em>.",
      "DescriptionPlain": "OpMatrixTimesMatrix\n\nLinear-algebraic multiply of LeftMatrix X RightMatrix.\n\n Result Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type. \n\nLeftMatrix must be a matrix whose Column Type is the same as the Column Type in Result Type.\n\nRightMatrix must be a matrix with the same Component Type as the Component Type in Result Type. Its number of columns must equal the number of columns in Result Type. Its columns must have the same number of components as the number of columns in LeftMatrix.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 146,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "LeftMatrix",
          "Type": "ID"
        },
        {
          "Name": "RightMatrix",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpOuterProduct",
      "Description": "<a id=\"OpOuterProduct\"></a><strong>OpOuterProduct</strong><br />\n<br />\nLinear-algebraic outer product of <em>Vector 1</em> and <em>Vector 2</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> whose <em>Column Type</em> is a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Vector 1</em> must have the same type as the <em>Column Type</em> in <em>Result Type</em>.<br />\n<br />\n<em>Vector 2</em> must be a vector with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of components must equal the number of columns in <em>Result Type</em>.",
      "DescriptionPlain": "OpOuterProduct\n\nLinear-algebraic outer product of Vector 1 and Vector 2.\n\n Result Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type. \n\nVector 1 must have the same type as the Column Type in Result Type.\n\nVector 2 must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Result Type.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 147,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector1",
          "Type": "ID"
        },
        {
          "Name": "Vector2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDot",
      "Description": "<a id=\"OpDot\"></a><strong>OpDot</strong><br />\n<br />\nDot product of <em>Vector 1</em> and <em>Vector 2</em>.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Floating\"><em>floating-point type</em></a> scalar. <br />\n<br />\n<em>Vector 1</em> and <em>Vector 2</em> must have the same type, and their component type must be <em>Result Type</em>.",
      "DescriptionPlain": "OpDot\n\nDot product of Vector 1 and Vector 2.\n\n Result Type must be a floating-point type scalar. \n\nVector 1 and Vector 2 must have the same type, and their component type must be Result Type.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 148,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector1",
          "Type": "ID"
        },
        {
          "Name": "Vector2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIAddCarry",
      "Description": "<a id=\"OpIAddCarry\"></a><strong>OpIAddCarry</strong><br />\n<br />\nResult is the unsigned integer addition of <em>Operand 1</em> and <em>Operand 2</em>, including its carry.<br />\n<br />\n<em>Result Type</em> must be from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Operand 1</em> and <em>Operand 2</em> must have the same type as the members of <em>Result Type</em>. These are consumed as unsigned integers.<br />\n<br />\n Results are computed per component. <br />\n<br />\nMember 0 of the result gets the low-order bits (full component width) of the addition.<br />\n<br />\nMember 1 of the result gets the high-order (carry) bit of the result of the addition. That is, it gets the value 1 if the addition overflowed the component width, and 0 otherwise.",
      "DescriptionPlain": "OpIAddCarry\n\nResult is the unsigned integer addition of Operand 1 and Operand 2, including its carry.\n\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.\n\n Results are computed per component. \n\nMember 0 of the result gets the low-order bits (full component width) of the addition.\n\nMember 1 of the result gets the high-order (carry) bit of the result of the addition. That is, it gets the value 1 if the addition overflowed the component width, and 0 otherwise.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 149,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpISubBorrow",
      "Description": "<a id=\"OpISubBorrow\"></a><strong>OpISubBorrow</strong><br />\n<br />\nResult is the unsigned integer subtraction of <em>Operand 2</em> from <em>Operand 1</em>, and what it needed to borrow.<br />\n<br />\n<em>Result Type</em> must be from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Operand 1</em> and <em>Operand 2</em> must have the same type as the members of <em>Result Type</em>. These are consumed as unsigned integers.<br />\n<br />\n Results are computed per component. <br />\n<br />\nMember 0 of the result gets the low-order bits (full component width) of the subtraction. That is, if <em>Operand 1</em> is larger than <em>Operand 2</em>, member 0 gets the full value of the subtraction;  if <em>Operand 2</em> is larger than <em>Operand 1</em>, member 0 gets <em>2<sup>w</sup></em> + <em>Operand 1</em> - <em>Operand 2</em>, where <em>w</em> is the component width.<br />\n<br />\nMember 1 of the result gets 0 if <em>Operand 1</em> &ge; <em>Operand 2</em>, and gets 1 otherwise.",
      "DescriptionPlain": "OpISubBorrow\n\nResult is the unsigned integer subtraction of Operand 2 from Operand 1, and what it needed to borrow.\n\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.\n\n Results are computed per component. \n\nMember 0 of the result gets the low-order bits (full component width) of the subtraction. That is, if Operand 1 is larger than Operand 2, member 0 gets the full value of the subtraction;  if Operand 2 is larger than Operand 1, member 0 gets 2w + Operand 1 - Operand 2, where w is the component width.\n\nMember 1 of the result gets 0 if Operand 1 &ge; Operand 2, and gets 1 otherwise.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 150,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUMulExtended",
      "Description": "<a id=\"OpUMulExtended\"></a><strong>OpUMulExtended</strong><br />\n<br />\nResult is the full value of the unsigned integer multiplication of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n<em>Result Type</em> must be from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Operand 1</em> and <em>Operand 2</em> must have the same type as the members of <em>Result Type</em>. These are consumed as unsigned integers.<br />\n<br />\n Results are computed per component. <br />\n<br />\nMember 0 of the result gets the low-order bits of the multiplication.<br />\n<br />\nMember 1 of the result gets the high-order bits of the multiplication.",
      "DescriptionPlain": "OpUMulExtended\n\nResult is the full value of the unsigned integer multiplication of Operand 1 and Operand 2.\n\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.\n\n Results are computed per component. \n\nMember 0 of the result gets the low-order bits of the multiplication.\n\nMember 1 of the result gets the high-order bits of the multiplication.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 151,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSMulExtended",
      "Description": "<a id=\"OpSMulExtended\"></a><strong>OpSMulExtended</strong><br />\n<br />\nResult is the full value of the signed integer multiplication of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n<em>Result Type</em> must be from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Operand 1</em> and <em>Operand 2</em> must have the same type as the members of <em>Result Type</em>. These are consumed as signed integers.<br />\n<br />\n Results are computed per component. <br />\n<br />\nMember 0 of the result gets the low-order bits of the multiplication.<br />\n<br />\nMember 1 of the result gets the high-order bits of the multiplication.",
      "DescriptionPlain": "OpSMulExtended\n\nResult is the full value of the signed integer multiplication of Operand 1 and Operand 2.\n\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type. \n\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as signed integers.\n\n Results are computed per component. \n\nMember 0 of the result gets the low-order bits of the multiplication.\n\nMember 1 of the result gets the high-order bits of the multiplication.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 152,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpShiftRightLogical",
      "Description": "<a id=\"OpShiftRightLogical\"></a><strong>OpShiftRightLogical</strong><br />\n<br />\nShift the bits in <em>Base</em> right by the number of bits specified in <em>Shift</em>.  The most-significant bits will be zero filled. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of each <em>Base</em> and <em>Shift</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <em>Base</em> and <em>Shift</em> must have the same number of components.  The number of components and bit width of the type of <em>Base</em> must be the same as in <em>Result Type</em>. <br />\n<br />\n<em>Shift</em> is consumed as an unsigned integer. The result is undefined if <em>Shift</em> is greater than the bit width of the components of <em>Base</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpShiftRightLogical\n\nShift the bits in Base right by the number of bits specified in Shift.  The most-significant bits will be zero filled. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type. \n\nShift is consumed as an unsigned integer. The result is undefined if Shift is greater than the bit width of the components of Base.\n\n Results are computed per component.",
      "Category": "Bit",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 194,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Shift",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpShiftRightArithmetic",
      "Description": "<a id=\"OpShiftRightArithmetic\"></a><strong>OpShiftRightArithmetic</strong><br />\n<br />\nShift the bits in <em>Base</em> right by the number of bits specified in <em>Shift</em>. The most-significant bits will be filled with the sign bit from <em>Base</em>. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of each <em>Base</em> and <em>Shift</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <em>Base</em> and <em>Shift</em> must have the same number of components.  The number of components and bit width of the type of <em>Base</em> must be the same as in <em>Result Type</em>. <br />\n<br />\n<em>Shift</em> is treated as unsigned.  The result is undefined if <em>Shift</em> is greater than the bit width of the components of <em>Base</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpShiftRightArithmetic\n\nShift the bits in Base right by the number of bits specified in Shift. The most-significant bits will be filled with the sign bit from Base. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type. \n\nShift is treated as unsigned.  The result is undefined if Shift is greater than the bit width of the components of Base. \n\n Results are computed per component.",
      "Category": "Bit",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 195,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Shift",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpShiftLeftLogical",
      "Description": "<a id=\"OpShiftLeftLogical\"></a><strong>OpShiftLeftLogical</strong><br />\n<br />\nShift the bits in <em>Base</em> left by the number of bits specified in <em>Shift</em>. The least-significant bits will be zero filled. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of each <em>Base</em> and <em>Shift</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <em>Base</em> and <em>Shift</em> must have the same number of components.  The number of components and bit width of the type of <em>Base</em> must be the same as in <em>Result Type</em>. <br />\n<br />\n<em>Shift</em> is treated as unsigned.  The result is undefined if <em>Shift</em> is greater than the bit width of the components of <em>Base</em>. <br />\n<br />\nThe number of components and bit width of <em>Result Type</em> must match those <em>Base</em> type. All types must be integer types.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpShiftLeftLogical\n\nShift the bits in Base left by the number of bits specified in Shift. The least-significant bits will be zero filled. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type. \n\nShift is treated as unsigned.  The result is undefined if Shift is greater than the bit width of the components of Base. \n\nThe number of components and bit width of Result Type must match those Base type. All types must be integer types.\n\n Results are computed per component.",
      "Category": "Bit",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 196,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Shift",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitwiseOr",
      "Description": "<a id=\"OpBitwiseOr\"></a><strong>OpBitwiseOr</strong><br />\n<br />\nResult is 1 if either <em>Operand 1</em> or <em>Operand 2</em> is 1. Result is 0 if both <em>Operand 1</em> and <em>Operand 2</em> are 0.<br />\n<br />\n Results are computed per component, and within each component, per bit. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>.",
      "DescriptionPlain": "OpBitwiseOr\n\nResult is 1 if either Operand 1 or Operand 2 is 1. Result is 0 if both Operand 1 and Operand 2 are 0.\n\n Results are computed per component, and within each component, per bit. \n\n Result Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.",
      "Category": "Bit",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 197,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitwiseXor",
      "Description": "<a id=\"OpBitwiseXor\"></a><strong>OpBitwiseXor</strong><br />\n<br />\nResult is 1 if exactly one of <em>Operand 1</em> or <em>Operand 2</em> is 1. Result is 0 if <em>Operand 1</em> and <em>Operand 2</em> have the same value.<br />\n<br />\n Results are computed per component, and within each component, per bit. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>.",
      "DescriptionPlain": "OpBitwiseXor\n\nResult is 1 if exactly one of Operand 1 or Operand 2 is 1. Result is 0 if Operand 1 and Operand 2 have the same value.\n\n Results are computed per component, and within each component, per bit. \n\n Result Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.",
      "Category": "Bit",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 198,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitwiseAnd",
      "Description": "<a id=\"OpBitwiseAnd\"></a><strong>OpBitwiseAnd</strong><br />\n<br />\nResult is 1 if both <em>Operand 1</em> and <em>Operand 2</em> are 1. Result is 0 if either <em>Operand 1</em> or <em>Operand 2</em> are 0.<br />\n<br />\n Results are computed per component, and within each component, per bit. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>.",
      "DescriptionPlain": "OpBitwiseAnd\n\nResult is 1 if both Operand 1 and Operand 2 are 1. Result is 0 if either Operand 1 or Operand 2 are 0.\n\n Results are computed per component, and within each component, per bit. \n\n Result Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.",
      "Category": "Bit",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 199,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpNot",
      "Description": "<a id=\"OpNot\"></a><strong>OpNot</strong><br />\n<br />\nComplement the bits of <em>Operand</em>.<br />\n<br />\n Results are computed per component, and within each component, per bit. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n <em>Operand&#8217;s</em> type  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width must equal the component width in <em>Result Type</em>.",
      "DescriptionPlain": "OpNot\n\nComplement the bits of Operand.\n\n Results are computed per component, and within each component, per bit. \n\n Result Type must be a scalar or vector of integer type. \n\n Operand&#8217;s type  must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must equal the component width in Result Type.",
      "Category": "Bit",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 200,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitFieldInsert",
      "Description": "<a id=\"OpBitFieldInsert\"></a><strong>OpBitFieldInsert</strong><br />\n<br />\nMake a copy of an object, with a modified bit field that comes from another object.<br />\n<br />\n Results are computed per component. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Base</em> and <em>Insert</em> must be the same as <em>Result Type</em>. <br />\n<br />\nAny result bits numbered outside [<em>Offset</em>, <em>Offset</em> + <em>Count</em> -  1] (<a href=\"#Inclusive\">inclusive</a>) will come from the corresponding bits in <em>Base</em>.<br />\n<br />\nAny result bits numbered in [<em>Offset</em>, <em>Offset</em> + <em>Count</em> -  1] come, in order, from the bits numbered [0, <em>Count</em> - 1] of <em>Insert</em>.<br />\n<br />\n<em>Count</em>  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <em>Count</em> is the number of bits taken from <em>Insert</em>. It will be consumed as an unsigned value. <em>Count</em> can be 0, in which case the result will be <em>Base</em>.<br />\n<br />\n<em>Offset</em>  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <em>Offset</em> is the lowest-order bit of the bit field.  It will be consumed as an unsigned value.<br />\n<br />\nThe resulting value is undefined if <em>Count</em> or <em>Offset</em> or their sum is greater than the number of bits in the result.",
      "DescriptionPlain": "OpBitFieldInsert\n\nMake a copy of an object, with a modified bit field that comes from another object.\n\n Results are computed per component. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of Base and Insert must be the same as Result Type. \n\nAny result bits numbered outside [Offset, Offset + Count -  1] (inclusive) will come from the corresponding bits in Base.\n\nAny result bits numbered in [Offset, Offset + Count -  1] come, in order, from the bits numbered [0, Count - 1] of Insert.\n\nCount  must be an integer type scalar. Count is the number of bits taken from Insert. It will be consumed as an unsigned value. Count can be 0, in which case the result will be Base.\n\nOffset  must be an integer type scalar. Offset is the lowest-order bit of the bit field.  It will be consumed as an unsigned value.\n\nThe resulting value is undefined if Count or Offset or their sum is greater than the number of bits in the result.",
      "Category": "Bit",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 201,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Insert",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        },
        {
          "Name": "Count",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitFieldSExtract",
      "Description": "<a id=\"OpBitFieldSExtract\"></a><strong>OpBitFieldSExtract</strong><br />\n<br />\nExtract a bit field from an object, with sign extension.<br />\n<br />\n Results are computed per component. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Base</em> must be the same as <em>Result Type</em>. <br />\n<br />\nIf <em>Count</em> is greater than 0: The bits of <em>Base</em> numbered in [<em>Offset</em>, <em>Offset</em> + <em>Count</em> -  1] (<a href=\"#Inclusive\">inclusive</a>) become the bits numbered [0, <em>Count</em> - 1] of the result. The remaining bits of the result will all be the same as bit <em>Offset + Count -  1</em> of <em>Base</em>.<br />\n<br />\n<em>Count</em>  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <em>Count</em> is the number of bits extracted from <em>Base</em>. It will be consumed as an unsigned value. <em>Count</em> can be 0, in which case the result will be 0.<br />\n<br />\n<em>Offset</em>  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <em>Offset</em> is the lowest-order bit of the bit field to extract from <em>Base</em>.  It will be consumed as an unsigned value.<br />\n<br />\nThe resulting value is undefined if <em>Count</em> or <em>Offset</em> or their sum is greater than the number of bits in the result.",
      "DescriptionPlain": "OpBitFieldSExtract\n\nExtract a bit field from an object, with sign extension.\n\n Results are computed per component. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of Base must be the same as Result Type. \n\nIf Count is greater than 0: The bits of Base numbered in [Offset, Offset + Count -  1] (inclusive) become the bits numbered [0, Count - 1] of the result. The remaining bits of the result will all be the same as bit Offset + Count -  1 of Base.\n\nCount  must be an integer type scalar. Count is the number of bits extracted from Base. It will be consumed as an unsigned value. Count can be 0, in which case the result will be 0.\n\nOffset  must be an integer type scalar. Offset is the lowest-order bit of the bit field to extract from Base.  It will be consumed as an unsigned value.\n\nThe resulting value is undefined if Count or Offset or their sum is greater than the number of bits in the result.",
      "Category": "Bit",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 202,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        },
        {
          "Name": "Count",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitFieldUExtract",
      "Description": "<a id=\"OpBitFieldUExtract\"></a><strong>OpBitFieldUExtract</strong><br />\n<br />\nExtract a bit field from an object, without sign extension.<br />\n<br />\nThe semantics are the same as with <a href=\"#OpBitFieldSExtract\"><strong>OpBitFieldSExtract</strong></a> with the exception that there is no sign extension. The remaining bits of the result will all be 0.",
      "DescriptionPlain": "OpBitFieldUExtract\n\nExtract a bit field from an object, without sign extension.\n\nThe semantics are the same as with OpBitFieldSExtract with the exception that there is no sign extension. The remaining bits of the result will all be 0.",
      "Category": "Bit",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 203,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        },
        {
          "Name": "Count",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitReverse",
      "Description": "<a id=\"OpBitReverse\"></a><strong>OpBitReverse</strong><br />\n<br />\nReverse the bits in an object.<br />\n<br />\n Results are computed per component. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Base</em> must be the same as <em>Result Type</em>. <br />\n<br />\nThe bit-number <em>n</em> of the result will be taken from bit-number <em>Width - 1 - n</em> of <em>Base</em>, where <em>Width</em> is the <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> operand of the <em>Result Type</em>.",
      "DescriptionPlain": "OpBitReverse\n\nReverse the bits in an object.\n\n Results are computed per component. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of Base must be the same as Result Type. \n\nThe bit-number n of the result will be taken from bit-number Width - 1 - n of Base, where Width is the OpTypeInt operand of the Result Type.",
      "Category": "Bit",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 204,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitCount",
      "Description": "<a id=\"OpBitCount\"></a><strong>OpBitCount</strong><br />\n<br />\nCount the number of set bits in an object.<br />\n<br />\n Results are computed per component. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  The components must be wide enough to hold the unsigned <em>Width</em> of <em>Base</em> as an unsigned value. That is, no sign bit is needed or counted when checking for a wide enough result width.<br />\n<br />\n<em>Base</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\nThe result is the unsigned value that is the number of bits in <em>Base</em> that are 1.",
      "DescriptionPlain": "OpBitCount\n\nCount the number of set bits in an object.\n\n Results are computed per component. \n\n Result Type must be a scalar or vector of integer type.  The components must be wide enough to hold the unsigned Width of Base as an unsigned value. That is, no sign bit is needed or counted when checking for a wide enough result width.\n\nBase must be a scalar or vector of integer type.  It must have the same number of components as Result Type.\n\nThe result is the unsigned value that is the number of bits in Base that are 1.",
      "Category": "Bit",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 205,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAny",
      "Description": "<a id=\"OpAny\"></a><strong>OpAny</strong><br />\n<br />\nResult is <strong>true</strong> if any component of <em>Vector</em> is <strong>true</strong>, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar. <br />\n<br />\n<em>Vector</em> must be a vector of <a href=\"#Boolean\"><em>Boolean type</em></a>.",
      "DescriptionPlain": "OpAny\n\nResult is true if any component of Vector is true, otherwise result is false.\n\n Result Type must be a Boolean type scalar. \n\nVector must be a vector of Boolean type.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 154,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAll",
      "Description": "<a id=\"OpAll\"></a><strong>OpAll</strong><br />\n<br />\nResult is <strong>true</strong> if all components of <em>Vector</em> are <strong>true</strong>, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar. <br />\n<br />\n<em>Vector</em> must be a vector of <a href=\"#Boolean\"><em>Boolean type</em></a>.",
      "DescriptionPlain": "OpAll\n\nResult is true if all components of Vector are true, otherwise result is false.\n\n Result Type must be a Boolean type scalar. \n\nVector must be a vector of Boolean type.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 155,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsNan",
      "Description": "<a id=\"OpIsNan\"></a><strong>OpIsNan</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE NaN, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpIsNan\n\nResult is true if x is an IEEE NaN, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 156,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsInf",
      "Description": "<a id=\"OpIsInf\"></a><strong>OpIsInf</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE Inf, otherwise result is <strong>false</strong><br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpIsInf\n\nResult is true if x is an IEEE Inf, otherwise result is false\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 157,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsFinite",
      "Description": "<a id=\"OpIsFinite\"></a><strong>OpIsFinite</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE finite number, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpIsFinite\n\nResult is true if x is an IEEE finite number, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 158,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsNormal",
      "Description": "<a id=\"OpIsNormal\"></a><strong>OpIsNormal</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE normal number, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpIsNormal\n\nResult is true if x is an IEEE normal number, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 159,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSignBitSet",
      "Description": "<a id=\"OpSignBitSet\"></a><strong>OpSignBitSet</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> has its sign bit set, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSignBitSet\n\nResult is true if x has its sign bit set, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 160,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLessOrGreater",
      "Description": "<a id=\"OpLessOrGreater\"></a><strong>OpLessOrGreater</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> &lt; <em>y</em> or <em>x</em> &gt; <em>y</em>, where IEEE comparisons are used, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n<em>y</em> must have the same type as <em>x</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpLessOrGreater\n\nResult is true if x &lt; y or x &gt; y, where IEEE comparisons are used, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\ny must have the same type as x.\n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 161,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        },
        {
          "Name": "Y",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpOrdered",
      "Description": "<a id=\"OpOrdered\"></a><strong>OpOrdered</strong><br />\n<br />\nResult is <strong>true</strong> if both <em>x</em> == <em>x</em> and <em>y</em> == <em>y</em> are <strong>true</strong>, where IEEE comparison is used, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n<em>y</em> must have the same type as <em>x</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpOrdered\n\nResult is true if both x == x and y == y are true, where IEEE comparison is used, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\ny must have the same type as x.\n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 162,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        },
        {
          "Name": "Y",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUnordered",
      "Description": "<a id=\"OpUnordered\"></a><strong>OpUnordered</strong><br />\n<br />\nResult is <strong>true</strong> if either <em>x</em> or <em>y</em> is an IEEE NaN, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n<em>y</em> must have the same type as <em>x</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpUnordered\n\nResult is true if either x or y is an IEEE NaN, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\ny must have the same type as x.\n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 163,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        },
        {
          "Name": "Y",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLogicalEqual",
      "Description": "<a id=\"OpLogicalEqual\"></a><strong>OpLogicalEqual</strong><br />\n<br />\nResult is <strong>true</strong> if <em>Operand 1</em> and <em>Operand 2</em> have the same value. Result is <strong>false</strong> if <em>Operand 1</em> and <em>Operand 2</em> have different values.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> must be the same as <em>Result Type</em>. <br />\n<br />\n The type of <em>Operand 2</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpLogicalEqual\n\nResult is true if Operand 1 and Operand 2 have the same value. Result is false if Operand 1 and Operand 2 have different values.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 must be the same as Result Type. \n\n The type of Operand 2 must be the same as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 164,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLogicalNotEqual",
      "Description": "<a id=\"OpLogicalNotEqual\"></a><strong>OpLogicalNotEqual</strong><br />\n<br />\nResult is <strong>true</strong> if <em>Operand 1</em> and <em>Operand 2</em> have different values. Result is <strong>false</strong> if <em>Operand 1</em> and <em>Operand 2</em> have the same value.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> must be the same as <em>Result Type</em>. <br />\n<br />\n The type of <em>Operand 2</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpLogicalNotEqual\n\nResult is true if Operand 1 and Operand 2 have different values. Result is false if Operand 1 and Operand 2 have the same value.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 must be the same as Result Type. \n\n The type of Operand 2 must be the same as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 165,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLogicalOr",
      "Description": "<a id=\"OpLogicalOr\"></a><strong>OpLogicalOr</strong><br />\n<br />\nResult is <strong>true</strong> if either <em>Operand 1</em> or <em>Operand 2</em> is <strong>true</strong>. Result is <strong>false</strong> if both <em>Operand 1</em> and <em>Operand 2</em> are <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> must be the same as <em>Result Type</em>. <br />\n<br />\n The type of <em>Operand 2</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpLogicalOr\n\nResult is true if either Operand 1 or Operand 2 is true. Result is false if both Operand 1 and Operand 2 are false.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 must be the same as Result Type. \n\n The type of Operand 2 must be the same as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 166,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLogicalAnd",
      "Description": "<a id=\"OpLogicalAnd\"></a><strong>OpLogicalAnd</strong><br />\n<br />\nResult is <strong>true</strong> if both <em>Operand 1</em> and <em>Operand 2</em> are <strong>true</strong>. Result is <strong>false</strong> if either <em>Operand 1</em> or <em>Operand 2</em> are <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> must be the same as <em>Result Type</em>. <br />\n<br />\n The type of <em>Operand 2</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpLogicalAnd\n\nResult is true if both Operand 1 and Operand 2 are true. Result is false if either Operand 1 or Operand 2 are false.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 must be the same as Result Type. \n\n The type of Operand 2 must be the same as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 167,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLogicalNot",
      "Description": "<a id=\"OpLogicalNot\"></a><strong>OpLogicalNot</strong><br />\n<br />\nResult is <strong>true</strong> if <em>Operand</em> is <strong>false</strong>.  Result is <strong>false</strong> if <em>Operand</em> is <strong>true</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpLogicalNot\n\nResult is true if Operand is false.  Result is false if Operand is true.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand must be the same as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 168,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSelect",
      "Description": "<a id=\"OpSelect\"></a><strong>OpSelect</strong><br />\n<br />\nSelect between two objects.<br />\n<br />\n<em>Result Type</em> must be a scalar or vector.<br />\n<br />\n The type of <em>Object 1</em> must be the same as <em>Result Type</em>. <em>Object 1</em> is selected as the result if <em>Condition</em> is <strong>true</strong>.<br />\n<br />\n The type of <em>Object 2</em> must be the same as <em>Result Type</em>. <em>Object 2</em> is selected as the result if <em>Condition</em> is <strong>false</strong>.<br />\n<br />\n<em>Condition</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSelect\n\nSelect between two objects.\n\nResult Type must be a scalar or vector.\n\n The type of Object 1 must be the same as Result Type. Object 1 is selected as the result if Condition is true.\n\n The type of Object 2 must be the same as Result Type. Object 2 is selected as the result if Condition is false.\n\nCondition must be a scalar or vector of Boolean type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 169,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Condition",
          "Type": "ID"
        },
        {
          "Name": "Object1",
          "Type": "ID"
        },
        {
          "Name": "Object2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIEqual",
      "Description": "<a id=\"OpIEqual\"></a><strong>OpIEqual</strong><br />\n<br />\nInteger comparison for equality.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpIEqual\n\nInteger comparison for equality.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 170,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpINotEqual",
      "Description": "<a id=\"OpINotEqual\"></a><strong>OpINotEqual</strong><br />\n<br />\nInteger comparison for inequality.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpINotEqual\n\nInteger comparison for inequality.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 171,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUGreaterThan",
      "Description": "<a id=\"OpUGreaterThan\"></a><strong>OpUGreaterThan</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpUGreaterThan\n\nUnsigned-integer comparison if Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 172,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSGreaterThan",
      "Description": "<a id=\"OpSGreaterThan\"></a><strong>OpSGreaterThan</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSGreaterThan\n\nSigned-integer comparison if Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 173,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUGreaterThanEqual",
      "Description": "<a id=\"OpUGreaterThanEqual\"></a><strong>OpUGreaterThanEqual</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpUGreaterThanEqual\n\nUnsigned-integer comparison if Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 174,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSGreaterThanEqual",
      "Description": "<a id=\"OpSGreaterThanEqual\"></a><strong>OpSGreaterThanEqual</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSGreaterThanEqual\n\nSigned-integer comparison if Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 175,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpULessThan",
      "Description": "<a id=\"OpULessThan\"></a><strong>OpULessThan</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpULessThan\n\nUnsigned-integer comparison if Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 176,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSLessThan",
      "Description": "<a id=\"OpSLessThan\"></a><strong>OpSLessThan</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSLessThan\n\nSigned-integer comparison if Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 177,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpULessThanEqual",
      "Description": "<a id=\"OpULessThanEqual\"></a><strong>OpULessThanEqual</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpULessThanEqual\n\nUnsigned-integer comparison if Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 178,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSLessThanEqual",
      "Description": "<a id=\"OpSLessThanEqual\"></a><strong>OpSLessThanEqual</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpSLessThanEqual\n\nSigned-integer comparison if Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 179,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdEqual",
      "Description": "<a id=\"OpFOrdEqual\"></a><strong>OpFOrdEqual</strong><br />\n<br />\nFloating-point comparison for being ordered and equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFOrdEqual\n\nFloating-point comparison for being ordered and equal.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 180,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordEqual",
      "Description": "<a id=\"OpFUnordEqual\"></a><strong>OpFUnordEqual</strong><br />\n<br />\nFloating-point comparison for being unordered or equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFUnordEqual\n\nFloating-point comparison for being unordered or equal.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 181,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdNotEqual",
      "Description": "<a id=\"OpFOrdNotEqual\"></a><strong>OpFOrdNotEqual</strong><br />\n<br />\nFloating-point comparison for being ordered and not equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFOrdNotEqual\n\nFloating-point comparison for being ordered and not equal.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 182,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordNotEqual",
      "Description": "<a id=\"OpFUnordNotEqual\"></a><strong>OpFUnordNotEqual</strong><br />\n<br />\nFloating-point comparison for being unordered or not equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFUnordNotEqual\n\nFloating-point comparison for being unordered or not equal.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 183,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdLessThan",
      "Description": "<a id=\"OpFOrdLessThan\"></a><strong>OpFOrdLessThan</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFOrdLessThan\n\nFloating-point comparison if operands are ordered and Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 184,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordLessThan",
      "Description": "<a id=\"OpFUnordLessThan\"></a><strong>OpFUnordLessThan</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFUnordLessThan\n\nFloating-point comparison if operands are unordered or Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 185,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdGreaterThan",
      "Description": "<a id=\"OpFOrdGreaterThan\"></a><strong>OpFOrdGreaterThan</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFOrdGreaterThan\n\nFloating-point comparison if operands are ordered and Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 186,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordGreaterThan",
      "Description": "<a id=\"OpFUnordGreaterThan\"></a><strong>OpFUnordGreaterThan</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFUnordGreaterThan\n\nFloating-point comparison if operands are unordered or Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 187,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdLessThanEqual",
      "Description": "<a id=\"OpFOrdLessThanEqual\"></a><strong>OpFOrdLessThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFOrdLessThanEqual\n\nFloating-point comparison if operands are ordered and Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 188,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordLessThanEqual",
      "Description": "<a id=\"OpFUnordLessThanEqual\"></a><strong>OpFUnordLessThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFUnordLessThanEqual\n\nFloating-point comparison if operands are unordered or Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 189,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdGreaterThanEqual",
      "Description": "<a id=\"OpFOrdGreaterThanEqual\"></a><strong>OpFOrdGreaterThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFOrdGreaterThanEqual\n\nFloating-point comparison if operands are ordered and Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 190,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordGreaterThanEqual",
      "Description": "<a id=\"OpFUnordGreaterThanEqual\"></a><strong>OpFUnordGreaterThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
      "DescriptionPlain": "OpFUnordGreaterThanEqual\n\nFloating-point comparison if operands are unordered or Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 191,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdx",
      "Description": "<a id=\"OpDPdx\"></a><strong>OpDPdx</strong><br />\n<br />\nSame result as either <a href=\"#OpDPdxFine\"><strong>OpDPdxFine</strong></a> or <a href=\"#OpDPdxCoarse\"><strong>OpDPdxCoarse</strong></a> on <em>P</em>. Selection of which one is based on external factors.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpDPdx\n\nSame result as either OpDPdxFine or OpDPdxCoarse on P. Selection of which one is based on external factors.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Derivative",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 207,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdy",
      "Description": "<a id=\"OpDPdy\"></a><strong>OpDPdy</strong><br />\n<br />\nSame result as either <a href=\"#OpDPdyFine\"><strong>OpDPdyFine</strong></a> or <a href=\"#OpDPdyCoarse\"><strong>OpDPdyCoarse</strong></a> on <em>P</em>. Selection of which one is based on external factors.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpDPdy\n\nSame result as either OpDPdyFine or OpDPdyCoarse on P. Selection of which one is based on external factors.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Derivative",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 208,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFwidth",
      "Description": "<a id=\"OpFwidth\"></a><strong>OpFwidth</strong><br />\n<br />\nResult is the same as computing the sum of the absolute values of <a href=\"#OpDPdx\"><strong>OpDPdx</strong></a> and <a href=\"#OpDPdy\"><strong>OpDPdy</strong></a> on <em>P</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpFwidth\n\nResult is the same as computing the sum of the absolute values of OpDPdx and OpDPdy on P.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Derivative",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 209,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdxFine",
      "Description": "<a id=\"OpDPdxFine\"></a><strong>OpDPdxFine</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>x</em> coordinate.Will use local differencing based on the value of <em>P</em> for the current fragment and its immediate neighbor(s).<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpDPdxFine\n\nResult is the partial derivative of P with respect to the window x coordinate.Will use local differencing based on the value of P for the current fragment and its immediate neighbor(s).\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Derivative",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 210,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdyFine",
      "Description": "<a id=\"OpDPdyFine\"></a><strong>OpDPdyFine</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>y</em> coordinate.Will use local differencing based on the value of <em>P</em> for the current fragment and its immediate neighbor(s).<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpDPdyFine\n\nResult is the partial derivative of P with respect to the window y coordinate.Will use local differencing based on the value of P for the current fragment and its immediate neighbor(s).\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Derivative",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 211,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFwidthFine",
      "Description": "<a id=\"OpFwidthFine\"></a><strong>OpFwidthFine</strong><br />\n<br />\nResult is the same as computing the sum of the absolute values of <a href=\"#OpDPdxFine\"><strong>OpDPdxFine</strong></a> and <a href=\"#OpDPdyFine\"><strong>OpDPdyFine</strong></a> on <em>P</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpFwidthFine\n\nResult is the same as computing the sum of the absolute values of OpDPdxFine and OpDPdyFine on P.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Derivative",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 212,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdxCoarse",
      "Description": "<a id=\"OpDPdxCoarse\"></a><strong>OpDPdxCoarse</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>x</em> coordinate. Will use local differencing based on the value of <em>P</em> for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of <em>P</em> for the current fragment. That is, over a given area, the implementation can compute <em>x</em> derivatives in fewer unique locations than would be allowed for <a href=\"#OpDPdxFine\"><strong>OpDPdxFine</strong></a>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpDPdxCoarse\n\nResult is the partial derivative of P with respect to the window x coordinate. Will use local differencing based on the value of P for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of P for the current fragment. That is, over a given area, the implementation can compute x derivatives in fewer unique locations than would be allowed for OpDPdxFine.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Derivative",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 213,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdyCoarse",
      "Description": "<a id=\"OpDPdyCoarse\"></a><strong>OpDPdyCoarse</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>y</em> coordinate. Will use local differencing based on the value of <em>P</em> for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of <em>P</em> for the current fragment. That is, over a given area, the implementation can compute <em>y</em> derivatives in fewer unique locations than would be allowed for <a href=\"#OpDPdyFine\"><strong>OpDPdyFine</strong></a>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpDPdyCoarse\n\nResult is the partial derivative of P with respect to the window y coordinate. Will use local differencing based on the value of P for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of P for the current fragment. That is, over a given area, the implementation can compute y derivatives in fewer unique locations than would be allowed for OpDPdyFine.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Derivative",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 214,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFwidthCoarse",
      "Description": "<a id=\"OpFwidthCoarse\"></a><strong>OpFwidthCoarse</strong><br />\n<br />\nResult is the same as computing the sum of the absolute values of <a href=\"#OpDPdxCoarse\"><strong>OpDPdxCoarse</strong></a> and <a href=\"#OpDPdyCoarse\"><strong>OpDPdyCoarse</strong></a> on <em>P</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpFwidthCoarse\n\nResult is the same as computing the sum of the absolute values of OpDPdxCoarse and OpDPdyCoarse on P.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Derivative",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 215,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpPhi",
      "Description": "<a id=\"OpPhi\"></a><strong>OpPhi</strong><br />\n<br />\nThe SSA phi function.<br />\n<br />\nThe result is selected based on control flow: If control reached the current block from <em>Parent i</em>, <em>Result Id</em> gets the value that <em>Variable i</em> had at the end of <em>Parent i</em>.<br />\n<br />\n<em>Result Type</em> can be any type.<br />\n<br />\nOperands are a sequence of pairs: (<em>Variable 1</em>, <em>Parent 1</em> block), (<em>Variable 2</em>, <em>Parent 2</em> block), &#8230; Each <em>Parent i</em> block is the label of an immediate predecessor in the CFG of the current block. A <em>Parent i</em> block must not appear more than once in the operand sequence. All <em>Variables</em> must have a type matching <em>Result Type</em>.<br />\n<br />\nWithin a block, this instruction must appear before all non-<strong>OpPhi</strong> instructions (except for <a href=\"#OpLine\"><strong>OpLine</strong></a>, which can be mixed with <strong>OpPhi</strong>).",
      "DescriptionPlain": "OpPhi\n\nThe SSA phi function.\n\nThe result is selected based on control flow: If control reached the current block from Parent i, Result Id gets the value that Variable i had at the end of Parent i.\n\nResult Type can be any type.\n\nOperands are a sequence of pairs: (Variable 1, Parent 1 block), (Variable 2, Parent 2 block), &#8230; Each Parent i block is the label of an immediate predecessor in the CFG of the current block. A Parent i block must not appear more than once in the operand sequence. All Variables must have a type matching Result Type.\n\nWithin a block, this instruction must appear before all non-OpPhi instructions (except for OpLine, which can be mixed with OpPhi).",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 245,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Variables",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpLoopMerge",
      "Description": "<a id=\"OpLoopMerge\"></a><strong>OpLoopMerge</strong><br />\n<br />\nDeclare a structured loop.<br />\n<br />\nThis instruction must immediately precede either an <a href=\"#OpBranch\"><strong>OpBranch</strong></a> or <a href=\"#OpBranchConditional\"><strong>OpBranchConditional</strong></a> instruction. That is, it must be the second-to-last instruction in its block.<br />\n<br />\n<em>Merge Block</em> is the label of the merge block for this structured loop.<br />\n<br />\n<em>Continue Target</em> is the label of a block targeted for processing a loop \"continue\".<br />\n<br />\n<em>Loop Control Parameters</em> appear in <a href=\"#Loop_Control\">Loop Control</a>-table order for any <em>Loop Control</em> setting that requires such a parameter.<br />\n<br />\nSee <a href=\"#StructuredControlFlow\">Structured Control Flow</a> for more detail.",
      "DescriptionPlain": "OpLoopMerge\n\nDeclare a structured loop.\n\nThis instruction must immediately precede either an OpBranch or OpBranchConditional instruction. That is, it must be the second-to-last instruction in its block.\n\nMerge Block is the label of the merge block for this structured loop.\n\nContinue Target is the label of a block targeted for processing a loop \"continue\".\n\nLoop Control Parameters appear in Loop Control-table order for any Loop Control setting that requires such a parameter.\n\nSee Structured Control Flow for more detail.",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 246,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "MergeBlock",
          "Type": "ID"
        },
        {
          "Name": "ContinueTarget",
          "Type": "ID"
        },
        {
          "Name": "LoopControl",
          "Type": "LoopControl"
        },
        {
          "Name": null,
          "Type": null
        }
      ]
    },
    {
      "Name": "OpSelectionMerge",
      "Description": "<a id=\"OpSelectionMerge\"></a><strong>OpSelectionMerge</strong><br />\n<br />\nDeclare a structured selection.<br />\n<br />\nThis instruction must immediately precede either an <a href=\"#OpBranchConditional\"><strong>OpBranchConditional</strong></a> or <a href=\"#OpSwitch\"><strong>OpSwitch</strong></a> instruction. That is, it must be the second-to-last instruction in its block.<br />\n<br />\n<em>Merge Block</em> is the label of the merge block for this structured selection.<br />\n<br />\nSee <a href=\"#StructuredControlFlow\">Structured Control Flow</a> for more detail.",
      "DescriptionPlain": "OpSelectionMerge\n\nDeclare a structured selection.\n\nThis instruction must immediately precede either an OpBranchConditional or OpSwitch instruction. That is, it must be the second-to-last instruction in its block.\n\nMerge Block is the label of the merge block for this structured selection.\n\nSee Structured Control Flow for more detail.",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 247,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "MergeBlock",
          "Type": "ID"
        },
        {
          "Name": "SelectionControl",
          "Type": "SelectionControl"
        }
      ]
    },
    {
      "Name": "OpLabel",
      "Description": "<a id=\"OpLabel\"></a><strong>OpLabel</strong><br />\n<br />\nThe block label instruction: Any reference to a block is through the <em>Result &lt;id&gt;</em> of its label.<br />\n<br />\nMust be the first instruction of any block, and appears only as the first instruction of a block.",
      "DescriptionPlain": "OpLabel\n\nThe block label instruction: Any reference to a block is through the Result &lt;id&gt; of its label.\n\nMust be the first instruction of any block, and appears only as the first instruction of a block.",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 248,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBranch",
      "Description": "<a id=\"OpBranch\"></a><strong>OpBranch</strong><br />\n<br />\nUnconditional branch to <em>Target Label</em>.<br />\n<br />\n<em>Target Label</em> must be the <em>Result &lt;id&gt;</em> of an <a href=\"#OpLabel\"><strong>OpLabel</strong></a> instruction in the current function.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpBranch\n\nUnconditional branch to Target Label.\n\nTarget Label must be the Result &lt;id&gt; of an OpLabel instruction in the current function.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 249,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "TargetLabel",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBranchConditional",
      "Description": "<a id=\"OpBranchConditional\"></a><strong>OpBranchConditional</strong><br />\n<br />\nIf <em>Condition</em> is <strong>true</strong>, branch to <em>True Label</em>, otherwise branch to <em>False Label</em>.<br />\n<br />\n<em>Condition</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar.<br />\n<br />\n<em>True Label</em> must be an <a href=\"#OpLabel\"><strong>OpLabel</strong></a> in the current function.<br />\n<br />\n<em>False Label</em> must be an <a href=\"#OpLabel\"><strong>OpLabel</strong></a> in the current function.<br />\n<br />\n<em>Branch weights</em> are unsigned 32-bit integer literals. There must be either no <em>Branch Weights</em> or exactly two branch weights. If present, the first is the weight for branching to <em>True Label</em>, and the second is the weight for branching to <em>False Label</em>. The implied probability that a branch is taken is its weight divided by the sum of the two <em>Branch weights</em>.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpBranchConditional\n\nIf Condition is true, branch to True Label, otherwise branch to False Label.\n\nCondition must be a Boolean type scalar.\n\nTrue Label must be an OpLabel in the current function.\n\nFalse Label must be an OpLabel in the current function.\n\nBranch weights are unsigned 32-bit integer literals. There must be either no Branch Weights or exactly two branch weights. If present, the first is the weight for branching to True Label, and the second is the weight for branching to False Label. The implied probability that a branch is taken is its weight divided by the sum of the two Branch weights.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 250,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Condition",
          "Type": "ID"
        },
        {
          "Name": "TrueLabel",
          "Type": "ID"
        },
        {
          "Name": "FalseLabel",
          "Type": "ID"
        },
        {
          "Name": null,
          "Type": null
        }
      ]
    },
    {
      "Name": "OpSwitch",
      "Description": "<a id=\"OpSwitch\"></a><strong>OpSwitch</strong><br />\n<br />\nMulti-way branch to one of the operand label <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Selector</em> must have a type of <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>. <em>Selector</em> will be compared for equality to the <em>Target</em> literals.<br />\n<br />\n<em>Default</em> must be the <em>&lt;id&gt;</em> of a label.  If <em>Selector</em> does not equal any of the <em>Target</em> literals, control flow will branch to the <em>Default</em> label <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Target</em> must be alternating scalar integer <em>literals</em> and the <em>&lt;id&gt;</em> of a label.  If <em>Selector</em> equals a <em>literal</em>, control flow will branch to the following <em>label &lt;id&gt;</em>. It is invalid for any two <em>literal</em> to be equal to each other. If <em>Selector</em> does not equal any <em>literal</em>, control flow will branch to the <em>Default</em> label <em>&lt;id&gt;</em>. Each <em>literal</em> is interpreted with the type of <em>Selector</em>: The bit width of <em>Selector&#8217;s</em> type will be the width of each <em>literal&#8217;s</em> type. If this width is not a multiple of 32-bits, the literals must be sign extended when the <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> <em>Signedness</em> is set to 1. (See <a href=\"#Literal_Number\"><em>Literal Number</em></a>.)<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpSwitch\n\nMulti-way branch to one of the operand label &lt;id&gt;.\n\nSelector must have a type of OpTypeInt. Selector will be compared for equality to the Target literals.\n\nDefault must be the &lt;id&gt; of a label.  If Selector does not equal any of the Target literals, control flow will branch to the Default label &lt;id&gt;.\n\nTarget must be alternating scalar integer literals and the &lt;id&gt; of a label.  If Selector equals a literal, control flow will branch to the following label &lt;id&gt;. It is invalid for any two literal to be equal to each other. If Selector does not equal any literal, control flow will branch to the Default label &lt;id&gt;. Each literal is interpreted with the type of Selector: The bit width of Selector&#8217;s type will be the width of each literal&#8217;s type. If this width is not a multiple of 32-bits, the literals must be sign extended when the OpTypeInt Signedness is set to 1. (See Literal Number.)\n\nThis instruction must be the last instruction in a block.",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 251,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Selector",
          "Type": "ID"
        },
        {
          "Name": "Default",
          "Type": "ID"
        },
        {
          "Name": "Target",
          "Type": "Pair<LiteralNumber,ID>[]"
        }
      ]
    },
    {
      "Name": "OpKill",
      "Description": "<a id=\"OpKill\"></a><strong>OpKill</strong><br />\n<br />\nFragment-shader discard.<br />\n<br />\nCeases all further processing in any <a href=\"#Invocation\">invocation</a> that executes it: Only instructions these invocations executed before <strong>OpKill</strong> will have observable side effects. If this instruction is executed in non-<a href=\"#UniformControlFlow\">uniform control flow</a>, all subsequent control flow is non-uniform (for invocations that continue to execute).<br />\n<br />\nThis instruction must be the last instruction in a block.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
      "DescriptionPlain": "OpKill\n\nFragment-shader discard.\n\nCeases all further processing in any invocation that executes it: Only instructions these invocations executed before OpKill will have observable side effects. If this instruction is executed in non-uniform control flow, all subsequent control flow is non-uniform (for invocations that continue to execute).\n\nThis instruction must be the last instruction in a block.\n\nThis instruction is only valid in the Fragment Execution Model.",
      "Category": "Control-Flow",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "1",
      "WordCountFix": 1,
      "OpCode": 252,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpReturn",
      "Description": "<a id=\"OpReturn\"></a><strong>OpReturn</strong><br />\n<br />\nReturn with no value from a function with void return type.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpReturn\n\nReturn with no value from a function with void return type.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "1",
      "WordCountFix": 1,
      "OpCode": 253,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpReturnValue",
      "Description": "<a id=\"OpReturnValue\"></a><strong>OpReturnValue</strong><br />\n<br />\nReturn a value from a function.<br />\n<br />\n<em>Value</em> is the value returned, by copy, and must match the <em>Return Type</em> operand of the <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> type of the <a href=\"#OpFunction\"><strong>OpFunction</strong></a> body this return instruction is in.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpReturnValue\n\nReturn a value from a function.\n\nValue is the value returned, by copy, and must match the Return Type operand of the OpTypeFunction type of the OpFunction body this return instruction is in.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 254,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUnreachable",
      "Description": "<a id=\"OpUnreachable\"></a><strong>OpUnreachable</strong><br />\n<br />\nDeclares that this block is not reachable in the CFG.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpUnreachable\n\nDeclares that this block is not reachable in the CFG.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Control-Flow",
      "Capabilities": [],
      "WordCount": "1",
      "WordCountFix": 1,
      "OpCode": 255,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpLifetimeStart",
      "Description": "<a id=\"OpLifetimeStart\"></a><strong>OpLifetimeStart</strong><br />\n<br />\nDeclare that an object was not defined before this instruction.<br />\n<br />\n<em>Pointer</em> is a pointer to the object whose lifetime is starting. Its type must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage_Class\">Storage Class</a> <strong>Function</strong>.<br />\n<br />\n<em>Size</em> must be 0 if <em>Pointer</em> is a pointer to a non-void type or the <strong>Addresses</strong> <a href=\"#Capability\">capability</a> is not being used. If <em>Size</em> is non-zero, it is the number of bytes of memory whose lifetime is starting.  Its type  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It is treated as unsigned; if its type has <em>Signedness</em> of 1, its sign bit cannot be set.",
      "DescriptionPlain": "OpLifetimeStart\n\nDeclare that an object was not defined before this instruction.\n\nPointer is a pointer to the object whose lifetime is starting. Its type must be an OpTypePointer with Storage Class Function.\n\nSize must be 0 if Pointer is a pointer to a non-void type or the Addresses capability is not being used. If Size is non-zero, it is the number of bytes of memory whose lifetime is starting.  Its type  must be an integer type scalar.  It is treated as unsigned; if its type has Signedness of 1, its sign bit cannot be set.",
      "Category": "Control-Flow",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 256,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Size",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpLifetimeStop",
      "Description": "<a id=\"OpLifetimeStop\"></a><strong>OpLifetimeStop</strong><br />\n<br />\nDeclare that an object is dead after this instruction.<br />\n<br />\n<em>Pointer</em> is a pointer to the object whose lifetime is ending. Its type must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage_Class\">Storage Class</a> <strong>Function</strong>.<br />\n<br />\n<em>Size</em> must be 0 if <em>Pointer</em> is a pointer to a non-void type or the <strong>Addresses</strong> <a href=\"#Capability\">capability</a> is not being used. If <em>Size</em> is non-zero, it is the number of bytes of memory whose lifetime is ending.  Its type  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It is treated as unsigned; if its type has <em>Signedness</em> of 1, its sign bit cannot be set.",
      "DescriptionPlain": "OpLifetimeStop\n\nDeclare that an object is dead after this instruction.\n\nPointer is a pointer to the object whose lifetime is ending. Its type must be an OpTypePointer with Storage Class Function.\n\nSize must be 0 if Pointer is a pointer to a non-void type or the Addresses capability is not being used. If Size is non-zero, it is the number of bytes of memory whose lifetime is ending.  Its type  must be an integer type scalar.  It is treated as unsigned; if its type has Signedness of 1, its sign bit cannot be set.",
      "Category": "Control-Flow",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 257,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Size",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpAtomicLoad",
      "Description": "<a id=\"OpAtomicLoad\"></a><strong>OpAtomicLoad</strong><br />\n<br />\nAtomically load through <em>Pointer</em> using the given <em>Semantics</em>. All subparts of the value that is loaded will be read atomically with respect to all other atomic accesses to it within <em>Scope</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Pointer</em> is the pointer to the memory to read. The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicLoad\n\nAtomically load through Pointer using the given Semantics. All subparts of the value that is loaded will be read atomically with respect to all other atomic accesses to it within Scope.\n\n Result Type must be a scalar of integer type or floating-point type. \n\nPointer is the pointer to the memory to read. The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 227,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicStore",
      "Description": "<a id=\"OpAtomicStore\"></a><strong>OpAtomicStore</strong><br />\n<br />\nAtomically store through <em>Pointer</em> using the given <em>Semantics</em>. All subparts of <em>Value</em> will be written atomically with respect to all other atomic accesses to it within <em>Scope</em>.<br />\n<br />\n<em>Pointer</em> is the pointer to the memory to write. The type it points to  must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Value</em> is the value to write. The type of <em>Value</em> and the type pointed to by <em>Pointer</em> must be the same type.",
      "DescriptionPlain": "OpAtomicStore\n\nAtomically store through Pointer using the given Semantics. All subparts of Value will be written atomically with respect to all other atomic accesses to it within Scope.\n\nPointer is the pointer to the memory to write. The type it points to  must be a scalar of integer type or floating-point type. \n\nValue is the value to write. The type of Value and the type pointed to by Pointer must be the same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 228,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicExchange",
      "Description": "<a id=\"OpAtomicExchange\"></a><strong>OpAtomicExchange</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> from copying <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicExchange\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value from copying Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be a scalar of integer type or floating-point type. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 229,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicCompareExchange",
      "Description": "<a id=\"OpAtomicCompareExchange\"></a><strong>OpAtomicCompareExchange</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by selecting <em>Value</em> if <em>Original Value</em> equals <em>Comparator</em> or selecting <em>Original Value</em> otherwise, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\nUse <em>Equal</em> for the memory semantics of this instruction when <em>Value</em> and <em>Original Value</em> compare equal.<br />\n<br />\nUse <em>Unequal</em> for the memory semantics of this instruction when <em>Value</em> and <em>Original Value</em> compare unequal. <em>Unequal</em> cannot be set to <strong>Release</strong> or <strong>Acquire and Release</strong>. In addition, <em>Unequal</em> cannot be set to a stronger memory-order then <em>Equal</em>.<br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.  This type must also match the type of <em>Comparator</em>.",
      "DescriptionPlain": "OpAtomicCompareExchange\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by selecting Value if Original Value equals Comparator or selecting Original Value otherwise, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\nUse Equal for the memory semantics of this instruction when Value and Original Value compare equal.\n\nUse Unequal for the memory semantics of this instruction when Value and Original Value compare unequal. Unequal cannot be set to Release or Acquire and Release. In addition, Unequal cannot be set to a stronger memory-order then Equal.\n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.  This type must also match the type of Comparator.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "9",
      "WordCountFix": 9,
      "OpCode": 230,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsEqual",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsUnequal",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        },
        {
          "Name": "Comparator",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicCompareExchangeWeak",
      "Description": "<a id=\"OpAtomicCompareExchangeWeak\"></a><strong>OpAtomicCompareExchangeWeak</strong><br />\n<br />\nAttempts to do the following:<br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by selecting <em>Value</em> if <em>Original Value</em> equals <em>Comparator</em> or selecting <em>Original Value</em> otherwise, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\nThe weak compare-and-exchange operations may fail spuriously. That is, even when <em>Original Value</em> equals <em>Comparator</em> the comparison can fail and store back the <em>Original Value</em> through <em>Pointer</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\nUse <em>Equal</em> for the memory semantics of this instruction when <em>Value</em> and <em>Original Value</em> compare equal.<br />\n<br />\nUse <em>Unequal</em> for the memory semantics of this instruction when <em>Value</em> and <em>Original Value</em> compare unequal. <em>Unequal</em> cannot be set to <strong>Release</strong> or <strong>Acquire and Release</strong>. In addition, <em>Unequal</em> cannot be set to a stronger memory-order then <em>Equal</em>.<br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.  This type must also match the type of <em>Comparator</em>.",
      "DescriptionPlain": "OpAtomicCompareExchangeWeak\n\nAttempts to do the following:\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by selecting Value if Original Value equals Comparator or selecting Original Value otherwise, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nThe weak compare-and-exchange operations may fail spuriously. That is, even when Original Value equals Comparator the comparison can fail and store back the Original Value through Pointer.\n\n Result Type must be an integer type scalar. \n\nUse Equal for the memory semantics of this instruction when Value and Original Value compare equal.\n\nUse Unequal for the memory semantics of this instruction when Value and Original Value compare unequal. Unequal cannot be set to Release or Acquire and Release. In addition, Unequal cannot be set to a stronger memory-order then Equal.\n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.  This type must also match the type of Comparator.",
      "Category": "Atomic",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "9",
      "WordCountFix": 9,
      "OpCode": 231,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsEqual",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsUnequal",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        },
        {
          "Name": "Comparator",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicIIncrement",
      "Description": "<a id=\"OpAtomicIIncrement\"></a><strong>OpAtomicIIncrement</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> through integer addition of <em>1</em> to <em>Original Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicIIncrement\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value through integer addition of 1 to Original Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 232,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicIDecrement",
      "Description": "<a id=\"OpAtomicIDecrement\"></a><strong>OpAtomicIDecrement</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> through integer subtraction of <em>1</em> from <em>Original Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicIDecrement\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value through integer subtraction of 1 from Original Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 233,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicIAdd",
      "Description": "<a id=\"OpAtomicIAdd\"></a><strong>OpAtomicIAdd</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by integer addition of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicIAdd\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by integer addition of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 234,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicISub",
      "Description": "<a id=\"OpAtomicISub\"></a><strong>OpAtomicISub</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by integer subtraction of <em>Value</em> from <em>Original Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicISub\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by integer subtraction of Value from Original Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 235,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicSMin",
      "Description": "<a id=\"OpAtomicSMin\"></a><strong>OpAtomicSMin</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the smallest signed integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicSMin\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the smallest signed integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 236,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicUMin",
      "Description": "<a id=\"OpAtomicUMin\"></a><strong>OpAtomicUMin</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the smallest unsigned integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicUMin\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the smallest unsigned integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 237,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicSMax",
      "Description": "<a id=\"OpAtomicSMax\"></a><strong>OpAtomicSMax</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the largest signed integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicSMax\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the largest signed integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 238,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicUMax",
      "Description": "<a id=\"OpAtomicUMax\"></a><strong>OpAtomicUMax</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the largest unsigned integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicUMax\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the largest unsigned integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 239,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicAnd",
      "Description": "<a id=\"OpAtomicAnd\"></a><strong>OpAtomicAnd</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by the bitwise AND of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicAnd\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise AND of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 240,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicOr",
      "Description": "<a id=\"OpAtomicOr\"></a><strong>OpAtomicOr</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by the bitwise OR of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicOr\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise OR of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 241,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicXor",
      "Description": "<a id=\"OpAtomicXor\"></a><strong>OpAtomicXor</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by the bitwise exclusive OR of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpAtomicXor\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise exclusive OR of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 242,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicFlagTestAndSet",
      "Description": "<a id=\"OpAtomicFlagTestAndSet\"></a><strong>OpAtomicFlagTestAndSet</strong><br />\n<br />\nAtomically sets the flag value pointed to by <em>Pointer</em> to the set state.<br />\n<br />\n<em>Pointer</em> must be a pointer to a 32-bit integer type representing an atomic flag.<br />\n<br />\nThe instruction&#8217;s result is true if the flag was in the set state or false if the flag was in the clear state immediately before the operation.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\nResults are undefined if an atomic flag is modified  by an instruction other than <a href=\"#OpAtomicFlagTestAndSet\"><strong>OpAtomicFlagTestAndSet</strong></a> or <a href=\"#OpAtomicFlagClear\"><strong>OpAtomicFlagClear</strong></a>",
      "DescriptionPlain": "OpAtomicFlagTestAndSet\n\nAtomically sets the flag value pointed to by Pointer to the set state.\n\nPointer must be a pointer to a 32-bit integer type representing an atomic flag.\n\nThe instruction&#8217;s result is true if the flag was in the set state or false if the flag was in the clear state immediately before the operation.\n\nResult Type must be a Boolean type.\n\nResults are undefined if an atomic flag is modified  by an instruction other than OpAtomicFlagTestAndSet or OpAtomicFlagClear",
      "Category": "Atomic",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 318,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicFlagClear",
      "Description": "<a id=\"OpAtomicFlagClear\"></a><strong>OpAtomicFlagClear</strong><br />\n<br />\nAtomically sets the flag value pointed to by <em>Pointer</em> to the clear state.<br />\n<br />\n<em>Pointer</em> must be a pointer to a 32-bit integer type representing an atomic flag.<br />\n<br />\nMemory Semantics cannot be <a href=\"#Memory_Semantics\"><strong>Acquire</strong></a> or <a href=\"#Memory_Semantics\"><strong>AcquireRelease</strong></a><br />\n<br />\nResults are undefined if an atomic flag is modified  by an instruction other than <a href=\"#OpAtomicFlagTestAndSet\"><strong>OpAtomicFlagTestAndSet</strong></a> or <a href=\"#OpAtomicFlagClear\"><strong>OpAtomicFlagClear</strong></a>",
      "DescriptionPlain": "OpAtomicFlagClear\n\nAtomically sets the flag value pointed to by Pointer to the clear state.\n\nPointer must be a pointer to a 32-bit integer type representing an atomic flag.\n\nMemory Semantics cannot be Acquire or AcquireRelease\n\nResults are undefined if an atomic flag is modified  by an instruction other than OpAtomicFlagTestAndSet or OpAtomicFlagClear",
      "Category": "Atomic",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 319,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "ScopeScope",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpEmitVertex",
      "Description": "<a id=\"OpEmitVertex\"></a><strong>OpEmitVertex</strong><br />\n<br />\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.<br />\n<br />\nThis instruction can only be used when only one stream is present.",
      "DescriptionPlain": "OpEmitVertex\n\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.\n\nThis instruction can only be used when only one stream is present.",
      "Category": "Primitive",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "1",
      "WordCountFix": 1,
      "OpCode": 218,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpEndPrimitive",
      "Description": "<a id=\"OpEndPrimitive\"></a><strong>OpEndPrimitive</strong><br />\n<br />\nFinish the current primitive and start a new one.  No vertex is emitted.<br />\n<br />\nThis instruction can only be used when only one stream is present.",
      "DescriptionPlain": "OpEndPrimitive\n\nFinish the current primitive and start a new one.  No vertex is emitted.\n\nThis instruction can only be used when only one stream is present.",
      "Category": "Primitive",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "1",
      "WordCountFix": 1,
      "OpCode": 219,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpEmitStreamVertex",
      "Description": "<a id=\"OpEmitStreamVertex\"></a><strong>OpEmitStreamVertex</strong><br />\n<br />\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.<br />\n<br />\n<em>Stream</em> must be an <em>&lt;id&gt;</em> of a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> with a scalar integer type. That constant is the output-primitive stream number.<br />\n<br />\nThis instruction can only be used when multiple streams are present.",
      "DescriptionPlain": "OpEmitStreamVertex\n\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.\n\nStream must be an &lt;id&gt; of a constant instruction with a scalar integer type. That constant is the output-primitive stream number.\n\nThis instruction can only be used when multiple streams are present.",
      "Category": "Primitive",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 220,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Stream",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpEndStreamPrimitive",
      "Description": "<a id=\"OpEndStreamPrimitive\"></a><strong>OpEndStreamPrimitive</strong><br />\n<br />\nFinish the current primitive and start a new one.  No vertex is emitted.<br />\n<br />\n<em>Stream</em> must be an <em>&lt;id&gt;</em> of a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> with a scalar integer type. That constant is the output-primitive stream number.<br />\n<br />\nThis instruction can only be used when multiple streams are present.",
      "DescriptionPlain": "OpEndStreamPrimitive\n\nFinish the current primitive and start a new one.  No vertex is emitted.\n\nStream must be an &lt;id&gt; of a constant instruction with a scalar integer type. That constant is the output-primitive stream number.\n\nThis instruction can only be used when multiple streams are present.",
      "Category": "Primitive",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 221,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Stream",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpControlBarrier",
      "Description": "<a id=\"OpControlBarrier\"></a><strong>OpControlBarrier</strong><br />\n<br />\nWait for other invocations of this module to reach the current point of execution.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> scope must reach this point of execution before any invocation will proceed beyond it.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\nIf <em>Semantics</em> is not <strong>None</strong>, this instruction also serves as an <a href=\"#OpMemoryBarrier\"><strong>OpMemoryBarrier</strong></a> instruction, and must also perform and adhere to the description and semantics of an <strong>OpMemoryBarrier</strong> instruction with the same <em>Memory</em> and <em>Semantics</em> operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If <em>Semantics</em> is <strong>None</strong>, <em>Memory</em> is ignored.<br />\n<br />\nIt is only valid to use this instruction with <strong>TessellationControl</strong>, <strong>GLCompute</strong>, or <strong>Kernel</strong> <a href=\"#Execution_Model\">execution models</a>.<br />\n<br />\nWhen used with the <strong>TessellationControl</strong> <a href=\"#Execution_Model\">execution model</a>, it also implicitly synchronizes the <strong>Output</strong> <a href=\"#Storage_Class\">Storage Class</a>:  Writes to <strong>Output</strong> variables performed by any invocation executed prior to a <strong>OpControlBarrier</strong> will be visible to any other invocation after return from that <strong>OpControlBarrier</strong>.",
      "DescriptionPlain": "OpControlBarrier\n\nWait for other invocations of this module to reach the current point of execution.\n\nAll invocations of this module within Execution scope must reach this point of execution before any invocation will proceed beyond it.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nIf Semantics is not None, this instruction also serves as an OpMemoryBarrier instruction, and must also perform and adhere to the description and semantics of an OpMemoryBarrier instruction with the same Memory and Semantics operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If Semantics is None, Memory is ignored.\n\nIt is only valid to use this instruction with TessellationControl, GLCompute, or Kernel execution models.\n\nWhen used with the TessellationControl execution model, it also implicitly synchronizes the Output Storage Class:  Writes to Output variables performed by any invocation executed prior to a OpControlBarrier will be visible to any other invocation after return from that OpControlBarrier.",
      "Category": "Barrier",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 224,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "ScopeMemory",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpMemoryBarrier",
      "Description": "<a id=\"OpMemoryBarrier\"></a><strong>OpMemoryBarrier</strong><br />\n<br />\nControl the order that memory accesses are observed.<br />\n<br />\nEnsures that memory accesses issued before this instruction will be observed before memory accesses issued after this instruction. This control is ensured only for memory accesses issued by this <a href=\"#Invocation\">invocation</a> and observed by another invocation executing within <em>Memory</em> scope.<br />\n<br />\n<em>Semantics</em> declares what kind of memory is being controlled and what kind of control to apply.<br />\n<br />\nTo execute both a memory barrier and a control barrier, see <a href=\"#OpControlBarrier\"><strong>OpControlBarrier</strong></a>.",
      "DescriptionPlain": "OpMemoryBarrier\n\nControl the order that memory accesses are observed.\n\nEnsures that memory accesses issued before this instruction will be observed before memory accesses issued after this instruction. This control is ensured only for memory accesses issued by this invocation and observed by another invocation executing within Memory scope.\n\nSemantics declares what kind of memory is being controlled and what kind of control to apply.\n\nTo execute both a memory barrier and a control barrier, see OpControlBarrier.",
      "Category": "Barrier",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 225,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "ScopeMemory",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpNamedBarrierInitialize",
      "Description": "<a id=\"OpNamedBarrierInitialize\"></a><strong>OpNamedBarrierInitialize</strong><br />\n<br />\nDeclare a new named-barrier object.<br />\n<br />\n<em>Result Type</em> must be the type <a href=\"#OpTypeNamedBarrier\"><strong>OpTypeNamedBarrier</strong></a>.<br />\n<br />\n<em>Subgroup Count</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar representing the number of subgroups that must reach the current point of execution.",
      "DescriptionPlain": "OpNamedBarrierInitialize\n\nDeclare a new named-barrier object.\n\nResult Type must be the type OpTypeNamedBarrier.\n\nSubgroup Count must be a 32-bit integer type scalar representing the number of subgroups that must reach the current point of execution.",
      "Category": "Barrier",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 328,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SubgroupCount",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpMemoryNamedBarrier",
      "Description": "<a id=\"OpMemoryNamedBarrier\"></a><strong>OpMemoryNamedBarrier</strong><br />\n<br />\nWait for other invocations of this module to reach the current point of execution.<br />\n<br />\n<em>Named Barrier</em> must be the type <a href=\"#OpTypeNamedBarrier\"><strong>OpTypeNamedBarrier</strong></a>.<br />\n<br />\nIf <em>Semantics</em> is not <strong>None</strong>, this instruction also serves as an <a href=\"#OpMemoryBarrier\"><strong>OpMemoryBarrier</strong></a> instruction, and must also perform and adhere to the description and semantics of an <strong>OpMemoryBarrier</strong> instruction with the same <em>Memory</em> and <em>Semantics</em> operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If <em>Semantics</em> <strong>None</strong>, <em>Memory</em> is ignored.",
      "DescriptionPlain": "OpMemoryNamedBarrier\n\nWait for other invocations of this module to reach the current point of execution.\n\nNamed Barrier must be the type OpTypeNamedBarrier.\n\nIf Semantics is not None, this instruction also serves as an OpMemoryBarrier instruction, and must also perform and adhere to the description and semantics of an OpMemoryBarrier instruction with the same Memory and Semantics operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If Semantics None, Memory is ignored.",
      "Category": "Barrier",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 329,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "NamedBarrier",
          "Type": "ID"
        },
        {
          "Name": "ScopeMemory",
          "Type": "ID"
        },
        {
          "Name": "MemorySemanticsSemantics",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupAsyncCopy",
      "Description": "<a id=\"OpGroupAsyncCopy\"></a><strong>OpGroupAsyncCopy</strong><br />\n<br />\nPerform an asynchronous group copy of <em>Num Elements</em> elements from <em>Source</em> to <em>Destination</em>. The asynchronous copy is performed by all work-items in a group.<br />\n<br />\nThis instruction returns an event object that can be used by <a href=\"#OpGroupWaitEvents\"><strong>OpGroupWaitEvents</strong></a> to wait for the async copy to finish.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeEvent\"><strong>OpTypeEvent</strong></a> object.<br />\n<br />\n<em>Destination</em> must be a pointer to a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Destination</em> pointer <a href=\"#Storage_Class\">Storage Class</a> must be <strong>Workgroup</strong> or <strong>CrossWorkgroup</strong>.<br />\n<br />\n The type of <em>Source</em> must be the same as <em>Destination</em>. <br />\n<br />\nWhen <em>Destination</em> pointer <a href=\"#Storage_Class\">Storage Class</a> is <strong>Workgroup</strong>, the <em>Source</em> pointer Storage Class must be <strong>CrossWorkgroup</strong>. In this case <em>Stride</em> defines the stride in elements when reading from <em>Source</em> pointer.<br />\n<br />\nWhen <em>Destination</em> pointer <a href=\"#Storage_Class\">Storage Class</a> is <strong>CrossWorkgroup</strong>, the <em>Source</em> pointer Storage Class must be <strong>Workgroup</strong>. In this case <em>Stride</em> defines the stride in elements when writing each element to <em>Destination</em> pointer.<br />\n<br />\n<em>Stride</em> and <em>NumElements</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\">addressing model</a> is <em>Physical32</em> and 64 bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <em>Addressing Model</em> is <em>Physical64</em>.<br />\n<br />\n<em>Event</em> must have a type of <a href=\"#OpTypeEvent\"><strong>OpTypeEvent</strong></a>.<br />\n<br />\n<em>Event</em> can be used to associate the copy with a previous copy allowing an event to be shared by multiple copies. Otherwise <em>Event</em> should be an <a href=\"#OpConstantNull\"><strong>OpConstantNull</strong></a>.<br />\n<br />\nIf <em>Event</em> argument is not <a href=\"#OpConstantNull\"><strong>OpConstantNull</strong></a>, the event object supplied in event argument will be returned.",
      "DescriptionPlain": "OpGroupAsyncCopy\n\nPerform an asynchronous group copy of Num Elements elements from Source to Destination. The asynchronous copy is performed by all work-items in a group.\n\nThis instruction returns an event object that can be used by OpGroupWaitEvents to wait for the async copy to finish.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be an OpTypeEvent object.\n\nDestination must be a pointer to a scalar or vector of floating-point type or integer type. \n\nDestination pointer Storage Class must be Workgroup or CrossWorkgroup.\n\n The type of Source must be the same as Destination. \n\nWhen Destination pointer Storage Class is Workgroup, the Source pointer Storage Class must be CrossWorkgroup. In this case Stride defines the stride in elements when reading from Source pointer.\n\nWhen Destination pointer Storage Class is CrossWorkgroup, the Source pointer Storage Class must be Workgroup. In this case Stride defines the stride in elements when writing each element to Destination pointer.\n\nStride and NumElements must be a 32-bit integer type scalar when the addressing model is Physical32 and 64 bit integer type scalar when the Addressing Model is Physical64.\n\nEvent must have a type of OpTypeEvent.\n\nEvent can be used to associate the copy with a previous copy allowing an event to be shared by multiple copies. Otherwise Event should be an OpConstantNull.\n\nIf Event argument is not OpConstantNull, the event object supplied in event argument will be returned.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "9",
      "WordCountFix": 9,
      "OpCode": 259,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Destination",
          "Type": "ID"
        },
        {
          "Name": "Source",
          "Type": "ID"
        },
        {
          "Name": "NumElements",
          "Type": "ID"
        },
        {
          "Name": "Stride",
          "Type": "ID"
        },
        {
          "Name": "Event",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupWaitEvents",
      "Description": "<a id=\"OpGroupWaitEvents\"></a><strong>OpGroupWaitEvents</strong><br />\n<br />\nWait for events generated by <a href=\"#OpGroupAsyncCopy\"><strong>OpGroupAsyncCopy</strong></a> operations to complete. <em>Events List</em> points to <em>Num Events</em> event objects, which will be released after the wait is performed.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Num Events</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Events List</em> must be a pointer to <a href=\"#OpTypeEvent\"><strong>OpTypeEvent</strong></a>.",
      "DescriptionPlain": "OpGroupWaitEvents\n\nWait for events generated by OpGroupAsyncCopy operations to complete. Events List points to Num Events event objects, which will be released after the wait is performed.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nExecution must be Workgroup or Subgroup Scope.\n\nNum Events must be a 32-bit integer type scalar.\n\nEvents List must be a pointer to OpTypeEvent.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 260,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "NumEvents",
          "Type": "ID"
        },
        {
          "Name": "EventsList",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupAll",
      "Description": "<a id=\"OpGroupAll\"></a><strong>OpGroupAll</strong><br />\n<br />\nEvaluates a predicate for all invocations in the group,resulting in <strong>true</strong> if predicate evaluates to <strong>true</strong> for all <a href=\"#Invocation\">invocations</a> in the group, otherwise the result is <strong>false</strong>.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Predicate</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.",
      "DescriptionPlain": "OpGroupAll\n\nEvaluates a predicate for all invocations in the group,resulting in true if predicate evaluates to true for all invocations in the group, otherwise the result is false.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a Boolean type.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPredicate must be a Boolean type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 261,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Predicate",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupAny",
      "Description": "<a id=\"OpGroupAny\"></a><strong>OpGroupAny</strong><br />\n<br />\nEvaluates a predicate for all invocations in the group,resulting in <strong>true</strong> if predicate evaluates to <strong>true</strong> for any <a href=\"#Invocation\">invocation</a> in the group, otherwise the result is <strong>false</strong>.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Predicate</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.",
      "DescriptionPlain": "OpGroupAny\n\nEvaluates a predicate for all invocations in the group,resulting in true if predicate evaluates to true for any invocation in the group, otherwise the result is false.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a Boolean type.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPredicate must be a Boolean type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 262,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Predicate",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupBroadcast",
      "Description": "<a id=\"OpGroupBroadcast\"></a><strong>OpGroupBroadcast</strong><br />\n<br />\nReturn the <em>Value</em> of the <a href=\"#Invocation\">invocation</a> identified by the local id <em>LocalId</em> to all invocations in the group.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> or a 16, 32 or 64 <a href=\"#Float\"><em>float type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>. <br />\n<br />\n<em>LocalId</em> must be an integer datatype. It can be a scalar, or a vector with 2 components or a vector with 3 components. <em>LocalId</em> must be the same for all <a href=\"#Invocation\">invocations</a> in the group.",
      "DescriptionPlain": "OpGroupBroadcast\n\nReturn the Value of the invocation identified by the local id LocalId to all invocations in the group.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type or a 16, 32 or 64 float type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of Value must be the same as Result Type. \n\nLocalId must be an integer datatype. It can be a scalar, or a vector with 2 components or a vector with 3 components. LocalId must be the same for all invocations in the group.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 263,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        },
        {
          "Name": "LocalId",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupIAdd",
      "Description": "<a id=\"OpGroupIAdd\"></a><strong>OpGroupIAdd</strong><br />\n<br />\nAn integer add group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is 0.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpGroupIAdd\n\nAn integer add group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is 0.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 264,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupFAdd",
      "Description": "<a id=\"OpGroupFAdd\"></a><strong>OpGroupFAdd</strong><br />\n<br />\nA floating-point add group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is 0.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 16-bit, 32-bit, or 64-bit <a href=\"#Floating\"><em>floating-point type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpGroupFAdd\n\nA floating-point add group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is 0.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 16-bit, 32-bit, or 64-bit floating-point type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 265,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupFMin",
      "Description": "<a id=\"OpGroupFMin\"></a><strong>OpGroupFMin</strong><br />\n<br />\nA floating-point minimum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is +INF.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 16-bit, 32-bit, or 64-bit <a href=\"#Floating\"><em>floating-point type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpGroupFMin\n\nA floating-point minimum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is +INF.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 16-bit, 32-bit, or 64-bit floating-point type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 266,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupUMin",
      "Description": "<a id=\"OpGroupUMin\"></a><strong>OpGroupUMin</strong><br />\n<br />\nAn unsigned integer minimum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is UINT_MAX when <em>X</em> is 32 bits wide and ULONG_MAX when <em>X</em> is 64 bits wide.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpGroupUMin\n\nAn unsigned integer minimum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is UINT_MAX when X is 32 bits wide and ULONG_MAX when X is 64 bits wide.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 267,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupSMin",
      "Description": "<a id=\"OpGroupSMin\"></a><strong>OpGroupSMin</strong><br />\n<br />\nA signed integer minimum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is INT_MAX when <em>X</em> is 32 bits wide and LONG_MAX when <em>X</em> is 64 bits wide.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpGroupSMin\n\nA signed integer minimum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is INT_MAX when X is 32 bits wide and LONG_MAX when X is 64 bits wide.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 268,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupFMax",
      "Description": "<a id=\"OpGroupFMax\"></a><strong>OpGroupFMax</strong><br />\n<br />\nA floating-point maximum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is -INF.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 16-bit, 32-bit, or 64-bit <a href=\"#Floating\"><em>floating-point type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpGroupFMax\n\nA floating-point maximum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is -INF.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 16-bit, 32-bit, or 64-bit floating-point type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 269,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupUMax",
      "Description": "<a id=\"OpGroupUMax\"></a><strong>OpGroupUMax</strong><br />\n<br />\nAn unsigned integer maximum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is 0.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpGroupUMax\n\nAn unsigned integer maximum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is 0.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 270,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupSMax",
      "Description": "<a id=\"OpGroupSMax\"></a><strong>OpGroupSMax</strong><br />\n<br />\nA signed integer maximum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is INT_MIN when <em>X</em> is 32 bits wide and LONG_MIN when <em>X</em> is 64 bits wide.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>X</em> and <em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> data type.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
      "DescriptionPlain": "OpGroupSMax\n\nA signed integer maximum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is INT_MIN when X is 32 bits wide and LONG_MIN when X is 64 bits wide.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nX and Result Type must be a 32-bit or 64-bit OpTypeInt data type.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 271,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSubgroupBallotKHR",
      "Description": "<a id=\"OpSubgroupBallotKHR\"></a><strong>OpSubgroupBallotKHR</strong><br />\n<br />\nSee extension SPV_KHR_shader_ballot",
      "DescriptionPlain": "OpSubgroupBallotKHR\n\nSee extension SPV_KHR_shader_ballot",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 4421,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Predicate",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSubgroupFirstInvocationKHR",
      "Description": "<a id=\"OpSubgroupFirstInvocationKHR\"></a><strong>OpSubgroupFirstInvocationKHR</strong><br />\n<br />\nSee extension SPV_KHR_shader_ballot",
      "DescriptionPlain": "OpSubgroupFirstInvocationKHR\n\nSee extension SPV_KHR_shader_ballot",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 4422,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSubgroupReadInvocationKHR",
      "Description": "<a id=\"OpSubgroupReadInvocationKHR\"></a><strong>OpSubgroupReadInvocationKHR</strong><br />\n<br />\nSee extension SPV_KHR_shader_ballot",
      "DescriptionPlain": "OpSubgroupReadInvocationKHR\n\nSee extension SPV_KHR_shader_ballot",
      "Category": "Group",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 4432,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        },
        {
          "Name": "Index",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpEnqueueMarker",
      "Description": "<a id=\"OpEnqueueMarker\"></a><strong>OpEnqueueMarker</strong><br />\n<br />\nEnqueue a marker command to the queue object specified by <em>Queue</em>. The marker command waits for a list of events to complete, or if the list is empty it waits for all previously enqueued commands in <em>Queue</em> to complete before the marker completes.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.<br />\n<br />\n<em>Queue</em> must be of the type <a href=\"#OpTypeQueue\"><strong>OpTypeQueue</strong></a>.<br />\n<br />\n<em>Num Events</em> specifies the number of event objects in the wait list pointed to by <em>Wait Events</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Wait Events</em> specifies the list of wait event objects and must be a pointer to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.<br />\n<br />\n<em>Ret Event</em> is a pointer to a device event which gets implicitly retained by this instruction.  It must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>. If <em>Ret Event</em> is set to null this instruction becomes a no-op.",
      "DescriptionPlain": "OpEnqueueMarker\n\nEnqueue a marker command to the queue object specified by Queue. The marker command waits for a list of events to complete, or if the list is empty it waits for all previously enqueued commands in Queue to complete before the marker completes.\n\nResult Type must be a 32-bit integer type scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.\n\nQueue must be of the type OpTypeQueue.\n\nNum Events specifies the number of event objects in the wait list pointed to by Wait Events and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nWait Events specifies the list of wait event objects and must be a pointer to OpTypeDeviceEvent.\n\nRet Event is a pointer to a device event which gets implicitly retained by this instruction.  It must have a type of OpTypePointer to OpTypeDeviceEvent. If Ret Event is set to null this instruction becomes a no-op.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 291,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Queue",
          "Type": "ID"
        },
        {
          "Name": "NumEvents",
          "Type": "ID"
        },
        {
          "Name": "WaitEvents",
          "Type": "ID"
        },
        {
          "Name": "RetEvent",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpEnqueueKernel",
      "Description": "<a id=\"OpEnqueueKernel\"></a><strong>OpEnqueueKernel</strong><br />\n<br />\nEnqueue the function specified by <em>Invoke</em> and the NDRange specified by <em>ND Range</em> for execution to the queue object specified by <em>Queue</em>. <br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.<br />\n<br />\n<em>Queue</em> must be of the type <a href=\"#OpTypeQueue\"><strong>OpTypeQueue</strong></a>.<br />\n<br />\n<em>Flags</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  The content of <em>Flags</em> is interpreted as <a href=\"#Kernel_Enqueue_Flags\"><em>Kernel Enqueue Flags</em></a> mask.<br />\n<br />\n<em>ND Range</em> must have a type of <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> created by <a href=\"#OpBuildNDRange\"><strong>OpBuildNDRange</strong></a>.<br />\n<br />\n<em>Num Events</em> specifies the number of event objects in the wait list pointed to by <em>Wait Events</em> and must be 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Wait Events</em> specifies the list of wait event objects and must be a pointer to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.<br />\n<br />\n<em>Ret Event</em> must be a pointer to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> which gets implicitly retained by this instruction. <br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\nEach <em>Local Size</em> operand corresponds (in order) to one <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a> parameter to the <em>Invoke</em> function, and specifies the number of bytes of <strong>Workgroup</strong> storage used to back the pointer during the execution of the <em>Invoke</em> function.",
      "DescriptionPlain": "OpEnqueueKernel\n\nEnqueue the function specified by Invoke and the NDRange specified by ND Range for execution to the queue object specified by Queue. \n\nResult Type must be a 32-bit integer type scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.\n\nQueue must be of the type OpTypeQueue.\n\nFlags must be an integer type scalar.  The content of Flags is interpreted as Kernel Enqueue Flags mask.\n\nND Range must have a type of OpTypeStruct created by OpBuildNDRange.\n\nNum Events specifies the number of event objects in the wait list pointed to by Wait Events and must be 32-bit integer type scalar, which is treated as an unsigned integer.\n\nWait Events specifies the list of wait event objects and must be a pointer to OpTypeDeviceEvent.\n\nRet Event must be a pointer to OpTypeDeviceEvent which gets implicitly retained by this instruction. \n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nEach Local Size operand corresponds (in order) to one OpTypePointer to Workgroup Storage Class parameter to the Invoke function, and specifies the number of bytes of Workgroup storage used to back the pointer during the execution of the Invoke function.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "13 + variable",
      "WordCountFix": 13,
      "OpCode": 292,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Queue",
          "Type": "ID"
        },
        {
          "Name": "Flags",
          "Type": "ID"
        },
        {
          "Name": "NDRange",
          "Type": "ID"
        },
        {
          "Name": "NumEvents",
          "Type": "ID"
        },
        {
          "Name": "WaitEvents",
          "Type": "ID"
        },
        {
          "Name": "RetEvent",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        },
        {
          "Name": "Param",
          "Type": "ID"
        },
        {
          "Name": "ParamSize",
          "Type": "ID"
        },
        {
          "Name": "ParamAlign",
          "Type": "ID"
        },
        {
          "Name": "Locals",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpGetKernelNDrangeSubGroupCount",
      "Description": "<a id=\"OpGetKernelNDrangeSubGroupCount\"></a><strong>OpGetKernelNDrangeSubGroupCount</strong><br />\n<br />\nReturns the number of subgroups in each workgroup of the dispatch (except for the last in cases where the global size does not divide cleanly into work-groups) given the combination of the passed NDRange descriptor specified by <em>ND Range</em> and the function specified by <em>Invoke</em>.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>ND Range</em> must have a type of <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> created by <a href=\"#OpBuildNDRange\"><strong>OpBuildNDRange</strong></a>.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
      "DescriptionPlain": "OpGetKernelNDrangeSubGroupCount\n\nReturns the number of subgroups in each workgroup of the dispatch (except for the last in cases where the global size does not divide cleanly into work-groups) given the combination of the passed NDRange descriptor specified by ND Range and the function specified by Invoke.\n\nResult Type must be a 32-bit integer type scalar.\n\nND Range must have a type of OpTypeStruct created by OpBuildNDRange.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "8",
      "WordCountFix": 8,
      "OpCode": 293,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "NDRange",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        },
        {
          "Name": "Param",
          "Type": "ID"
        },
        {
          "Name": "ParamSize",
          "Type": "ID"
        },
        {
          "Name": "ParamAlign",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetKernelNDrangeMaxSubGroupSize",
      "Description": "<a id=\"OpGetKernelNDrangeMaxSubGroupSize\"></a><strong>OpGetKernelNDrangeMaxSubGroupSize</strong><br />\n<br />\nReturns the maximum sub-group size for the function specified by <em>Invoke</em> and the NDRange specified by <em>ND Range</em>. <br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>ND Range</em> must have a type of <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> created by <a href=\"#OpBuildNDRange\"><strong>OpBuildNDRange</strong></a>.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
      "DescriptionPlain": "OpGetKernelNDrangeMaxSubGroupSize\n\nReturns the maximum sub-group size for the function specified by Invoke and the NDRange specified by ND Range. \n\nResult Type must be a 32-bit integer type scalar.\n\nND Range must have a type of OpTypeStruct created by OpBuildNDRange.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "8",
      "WordCountFix": 8,
      "OpCode": 294,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "NDRange",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        },
        {
          "Name": "Param",
          "Type": "ID"
        },
        {
          "Name": "ParamSize",
          "Type": "ID"
        },
        {
          "Name": "ParamAlign",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetKernelWorkGroupSize",
      "Description": "<a id=\"OpGetKernelWorkGroupSize\"></a><strong>OpGetKernelWorkGroupSize</strong><br />\n<br />\nReturns the maximum work-group size that can be used to execute the function specified by <em>Invoke</em> on the device.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
      "DescriptionPlain": "OpGetKernelWorkGroupSize\n\nReturns the maximum work-group size that can be used to execute the function specified by Invoke on the device.\n\nResult Type must be a 32-bit integer type scalar.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 295,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        },
        {
          "Name": "Param",
          "Type": "ID"
        },
        {
          "Name": "ParamSize",
          "Type": "ID"
        },
        {
          "Name": "ParamAlign",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetKernelPreferredWorkGroupSizeMultiple",
      "Description": "<a id=\"OpGetKernelPreferredWorkGroupSizeMultiple\"></a><strong>OpGetKernelPreferredWorkGroupSizeMultiple</strong><br />\n<br />\nReturns the preferred multiple of work-group size for the function specified by <em>Invoke</em>. This is a performance hint. Specifying a work-group size that is not a multiple of the value returned by this query as the value of the local work size will not fail to enqueue <em>Invoke</em> for execution unless the work-group size specified is larger than the device maximum.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
      "DescriptionPlain": "OpGetKernelPreferredWorkGroupSizeMultiple\n\nReturns the preferred multiple of work-group size for the function specified by Invoke. This is a performance hint. Specifying a work-group size that is not a multiple of the value returned by this query as the value of the local work size will not fail to enqueue Invoke for execution unless the work-group size specified is larger than the device maximum.\n\nResult Type must be a 32-bit integer type scalar.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 296,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        },
        {
          "Name": "Param",
          "Type": "ID"
        },
        {
          "Name": "ParamSize",
          "Type": "ID"
        },
        {
          "Name": "ParamAlign",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpRetainEvent",
      "Description": "<a id=\"OpRetainEvent\"></a><strong>OpRetainEvent</strong><br />\n<br />\nIncrements the reference count of the event object specified by <em>Event</em>.<br />\n<br />\n<em>Event</em> must be an event that was produced by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a>, <a href=\"#OpEnqueueMarker\"><strong>OpEnqueueMarker</strong></a> or <a href=\"#OpCreateUserEvent\"><strong>OpCreateUserEvent</strong></a>.",
      "DescriptionPlain": "OpRetainEvent\n\nIncrements the reference count of the event object specified by Event.\n\nEvent must be an event that was produced by OpEnqueueKernel, OpEnqueueMarker or OpCreateUserEvent.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 297,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Event",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReleaseEvent",
      "Description": "<a id=\"OpReleaseEvent\"></a><strong>OpReleaseEvent</strong><br />\n<br />\nDecrements the reference count of the event object specified by <em>Event</em>. The event object is deleted once the event reference count is zero, the specific command identified by this event has completed (or terminated) and there are no commands in any device command queue that require a wait for this event to complete.<br />\n<br />\n<em>Event</em> must be an event that was produced by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a>, <a href=\"#OpEnqueueMarker\"><strong>OpEnqueueMarker</strong></a> or <a href=\"#OpCreateUserEvent\"><strong>OpCreateUserEvent</strong></a>.",
      "DescriptionPlain": "OpReleaseEvent\n\nDecrements the reference count of the event object specified by Event. The event object is deleted once the event reference count is zero, the specific command identified by this event has completed (or terminated) and there are no commands in any device command queue that require a wait for this event to complete.\n\nEvent must be an event that was produced by OpEnqueueKernel, OpEnqueueMarker or OpCreateUserEvent.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 298,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Event",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpCreateUserEvent",
      "Description": "<a id=\"OpCreateUserEvent\"></a><strong>OpCreateUserEvent</strong><br />\n<br />\nCreate a user event. The execution status of the created event is set to a value of 2 (CL_SUBMITTED).<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.",
      "DescriptionPlain": "OpCreateUserEvent\n\nCreate a user event. The execution status of the created event is set to a value of 2 (CL_SUBMITTED).\n\nResult Type must be OpTypeDeviceEvent.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 299,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsValidEvent",
      "Description": "<a id=\"OpIsValidEvent\"></a><strong>OpIsValidEvent</strong><br />\n<br />\nReturns <strong>true</strong> if the event specified by <em>Event</em> is a valid event, otherwise result is <strong>false</strong>.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n<em>Event</em> must have a type of <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>",
      "DescriptionPlain": "OpIsValidEvent\n\nReturns true if the event specified by Event is a valid event, otherwise result is false.\n\nResult Type must be a Boolean type.\n\nEvent must have a type of OpTypeDeviceEvent",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 300,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Event",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSetUserEventStatus",
      "Description": "<a id=\"OpSetUserEventStatus\"></a><strong>OpSetUserEventStatus</strong><br />\n<br />\nSets the execution status of a user event specified by <em>Event</em>.<em>Status</em> can be either 0 (CL_COMPLETE) to indicate that this kernel and all its child kernels finished execution successfully, or a negative integer value indicating an error.<br />\n<br />\n<em>Event</em> must have a type of <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> that was produced by <a href=\"#OpCreateUserEvent\"><strong>OpCreateUserEvent</strong></a>.<br />\n<br />\n<em>Status</em> must have a type of 32-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> treated as a signed integer.",
      "DescriptionPlain": "OpSetUserEventStatus\n\nSets the execution status of a user event specified by Event.Status can be either 0 (CL_COMPLETE) to indicate that this kernel and all its child kernels finished execution successfully, or a negative integer value indicating an error.\n\nEvent must have a type of OpTypeDeviceEvent that was produced by OpCreateUserEvent.\n\nStatus must have a type of 32-bit OpTypeInt treated as a signed integer.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 301,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Event",
          "Type": "ID"
        },
        {
          "Name": "Status",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpCaptureEventProfilingInfo",
      "Description": "<a id=\"OpCaptureEventProfilingInfo\"></a><strong>OpCaptureEventProfilingInfo</strong><br />\n<br />\nCaptures the profiling information specified by <em>Profiling Info</em> for the command associated with the event specified by <em>Event</em> in the memory pointed to by <em>Value</em>.The profiling information will be available in the memory pointed to by <em>Value</em> once the command identified by <em>Event</em> has completed.<br />\n<br />\n<em>Event</em> must have a type of <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> that was produced by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a> or <a href=\"#OpEnqueueMarker\"><strong>OpEnqueueMarker</strong></a>. <br />\n<br />\n<em>Profiling Info</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  The content of <em>Profiling Info</em> is interpreted as <a href=\"#Kernel_Profiling_Info\"><em>Kernel Profiling Info</em></a> mask.<br />\n<br />\n<em>Value</em> must be a pointer to a scalar 8-bit <a href=\"#Integer\"><em>integer type</em></a> in the <strong>CrossWorkgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\nWhen <em>Profiling Info</em> is <strong>CmdExecTime</strong>, <em>Value</em> must point to 128-bit memory range.<br />\n The first 64 bits contain the elapsed time CL_PROFILING_COMMAND_END - CL_PROFILING_COMMAND_START for the command identified by <em>Event</em> in nanoseconds.<br />\n The second 64 bits contain the elapsed time CL_PROFILING_COMMAND_COMPLETE - CL_PROFILING_COMMAND_START for the command identified by <em>Event</em> in nanoseconds.<br />\n<br />\n<strong>Note:</strong> The behavior of this instruction is undefined when called multiple times for the same event.",
      "DescriptionPlain": "OpCaptureEventProfilingInfo\n\nCaptures the profiling information specified by Profiling Info for the command associated with the event specified by Event in the memory pointed to by Value.The profiling information will be available in the memory pointed to by Value once the command identified by Event has completed.\n\nEvent must have a type of OpTypeDeviceEvent that was produced by OpEnqueueKernel or OpEnqueueMarker. \n\nProfiling Info must be an integer type scalar.  The content of Profiling Info is interpreted as Kernel Profiling Info mask.\n\nValue must be a pointer to a scalar 8-bit integer type in the CrossWorkgroup Storage Class.\n\nWhen Profiling Info is CmdExecTime, Value must point to 128-bit memory range.\n The first 64 bits contain the elapsed time CL_PROFILING_COMMAND_END - CL_PROFILING_COMMAND_START for the command identified by Event in nanoseconds.\n The second 64 bits contain the elapsed time CL_PROFILING_COMMAND_COMPLETE - CL_PROFILING_COMMAND_START for the command identified by Event in nanoseconds.\n\nNote: The behavior of this instruction is undefined when called multiple times for the same event.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 302,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Event",
          "Type": "ID"
        },
        {
          "Name": "ProfilingInfo",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetDefaultQueue",
      "Description": "<a id=\"OpGetDefaultQueue\"></a><strong>OpGetDefaultQueue</strong><br />\n<br />\nReturns the default device queue. If a default device queue has not been created, a null queue object is returned.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeQueue\"><strong>OpTypeQueue</strong></a>.",
      "DescriptionPlain": "OpGetDefaultQueue\n\nReturns the default device queue. If a default device queue has not been created, a null queue object is returned.\n\nResult Type must be an OpTypeQueue.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 303,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBuildNDRange",
      "Description": "<a id=\"OpBuildNDRange\"></a><strong>OpBuildNDRange</strong><br />\n<br />\nGiven the global work size specified by <em>GlobalWorkSize</em>, local work size specified by <em>LocalWorkSize</em> and global work offset specified by <em>GlobalWorkOffset</em>, builds a 1D, 2D or 3D ND-range descriptor structure and returns it.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with the following ordered list of members, starting from the first to last:<br />\n<br />\n   1) 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, that specifies the number of dimensions used to specify the global work-items and work-items in the work-group. <br />\n<br />\n   2) <a href=\"#OpTypeArray\"><strong>OpTypeArray</strong></a> with 3 elements, where each element is 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical32</strong> and 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical64</strong>. This member is an array of per-dimension unsigned values that describe the offset used to calculate the global ID of a work-item.<br />\n<br />\n   3) <a href=\"#OpTypeArray\"><strong>OpTypeArray</strong></a> with 3 elements, where each element is 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical32</strong> and 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical64</strong>. This member is an array of per-dimension unsigned values that describe the number of global work-items in the dimensions that will execute the kernel function.<br />\n<br />\n   4) <a href=\"#OpTypeArray\"><strong>OpTypeArray</strong></a> with 3 elements, where each element is 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical32</strong> and 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical64</strong>. This member is an array of per-dimension unsigned values that describe the number of work-items that make up a work-group.<br />\n<br />\n<em>GlobalWorkSize</em> must be a scalar or an array with 2 or 3 components. Where the type of each element in the array is 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical32</strong> or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical64</strong>.<br />\n<br />\nThe type of <em>LocalWorkSize</em> must be the same as <em>GlobalWorkSize</em>.<br />\n<br />\nThe type of <em>GlobalWorkOffset</em> must be the same as <em>GlobalWorkSize</em>.",
      "DescriptionPlain": "OpBuildNDRange\n\nGiven the global work size specified by GlobalWorkSize, local work size specified by LocalWorkSize and global work offset specified by GlobalWorkOffset, builds a 1D, 2D or 3D ND-range descriptor structure and returns it.\n\nResult Type must be an OpTypeStruct with the following ordered list of members, starting from the first to last:\n\n   1) 32-bit integer type scalar, that specifies the number of dimensions used to specify the global work-items and work-items in the work-group. \n\n   2) OpTypeArray with 3 elements, where each element is 32-bit integer type scalar when the addressing model is Physical32 and 64-bit integer type scalar when the addressing model is Physical64. This member is an array of per-dimension unsigned values that describe the offset used to calculate the global ID of a work-item.\n\n   3) OpTypeArray with 3 elements, where each element is 32-bit integer type scalar when the addressing model is Physical32 and 64-bit integer type scalar when the addressing model is Physical64. This member is an array of per-dimension unsigned values that describe the number of global work-items in the dimensions that will execute the kernel function.\n\n   4) OpTypeArray with 3 elements, where each element is 32-bit integer type scalar when the addressing model is Physical32 and 64-bit integer type scalar when the addressing model is Physical64. This member is an array of per-dimension unsigned values that describe the number of work-items that make up a work-group.\n\nGlobalWorkSize must be a scalar or an array with 2 or 3 components. Where the type of each element in the array is 32-bit integer type scalar when the addressing model is Physical32 or 64-bit integer type scalar when the addressing model is Physical64.\n\nThe type of LocalWorkSize must be the same as GlobalWorkSize.\n\nThe type of GlobalWorkOffset must be the same as GlobalWorkSize.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 304,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "GlobalWorkSize",
          "Type": "ID"
        },
        {
          "Name": "LocalWorkSize",
          "Type": "ID"
        },
        {
          "Name": "GlobalWorkOffset",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetKernelLocalSizeForSubgroupCount",
      "Description": "<a id=\"OpGetKernelLocalSizeForSubgroupCount\"></a><strong>OpGetKernelLocalSizeForSubgroupCount</strong><br />\n<br />\nReturns the 1D local size to enqueue <em>Invoke</em> with <em>Subgroup Count</em> subgroups per workgroup.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Subgroup Count</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
      "DescriptionPlain": "OpGetKernelLocalSizeForSubgroupCount\n\nReturns the 1D local size to enqueue Invoke with Subgroup Count subgroups per workgroup.\n\nResult Type must be a 32-bit integer type scalar.\n\nSubgroup Count must be a 32-bit integer type scalar.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "8",
      "WordCountFix": 8,
      "OpCode": 325,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SubgroupCount",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        },
        {
          "Name": "Param",
          "Type": "ID"
        },
        {
          "Name": "ParamSize",
          "Type": "ID"
        },
        {
          "Name": "ParamAlign",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetKernelMaxNumSubgroups",
      "Description": "<a id=\"OpGetKernelMaxNumSubgroups\"></a><strong>OpGetKernelMaxNumSubgroups</strong><br />\n<br />\nReturns the maximum number of subgroups that can be used to execute <em>Invoke</em> on the devce.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
      "DescriptionPlain": "OpGetKernelMaxNumSubgroups\n\nReturns the maximum number of subgroups that can be used to execute Invoke on the devce.\n\nResult Type must be a 32-bit integer type scalar.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 326,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        },
        {
          "Name": "Param",
          "Type": "ID"
        },
        {
          "Name": "ParamSize",
          "Type": "ID"
        },
        {
          "Name": "ParamAlign",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReadPipe",
      "Description": "<a id=\"OpReadPipe\"></a><strong>OpReadPipe</strong><br />\n<br />\nRead a packet from the pipe object specified by <em>Pipe</em> into <em>Pointer</em>. Result is 0 if the operation is successful and a negative value if the pipe is empty.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>Pipe</em> and a <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpReadPipe\n\nRead a packet from the pipe object specified by Pipe into Pointer. Result is 0 if the operation is successful and a negative value if the pipe is empty.\n\nResult Type must be a 32-bit integer type scalar.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 274,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpWritePipe",
      "Description": "<a id=\"OpWritePipe\"></a><strong>OpWritePipe</strong><br />\n<br />\nWrite a packet from <em>Pointer</em> to the pipe object specified by <em>Pipe</em>. Result is 0 if the operation is successful and a negative value if the pipe is full.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>Pipe</em> and a <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpWritePipe\n\nWrite a packet from Pointer to the pipe object specified by Pipe. Result is 0 if the operation is successful and a negative value if the pipe is full.\n\nResult Type must be a 32-bit integer type scalar.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 275,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReservedReadPipe",
      "Description": "<a id=\"OpReservedReadPipe\"></a><strong>OpReservedReadPipe</strong><br />\n<br />\nRead a packet from the reserved area specified by <em>Reserve Id</em> and <em>Index</em> of the pipe object specified by <em>Pipe</em> into <em>Pointer</em>. The reserved pipe entries are referred to by indices that go from 0 &#8230; <em>Num Packets</em> - 1. Result is 0 if the operation is successful and a negative value otherwise.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Index</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>Pipe</em> and a <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpReservedReadPipe\n\nRead a packet from the reserved area specified by Reserve Id and Index of the pipe object specified by Pipe into Pointer. The reserved pipe entries are referred to by indices that go from 0 &#8230; Num Packets - 1. Result is 0 if the operation is successful and a negative value otherwise.\n\nResult Type must be a 32-bit integer type scalar.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nIndex must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "9",
      "WordCountFix": 9,
      "OpCode": 276,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "ReserveId",
          "Type": "ID"
        },
        {
          "Name": "Index",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReservedWritePipe",
      "Description": "<a id=\"OpReservedWritePipe\"></a><strong>OpReservedWritePipe</strong><br />\n<br />\nWrite a packet from <em>Pointer</em> into the reserved area specified by <em>Reserve Id</em> and <em>Index</em> of the pipe object specified by <em>Pipe</em>. The reserved pipe entries are referred to by indices that go from 0 &#8230; <em>Num Packets</em> - 1. Result is 0 if the operation is successful and a negative value otherwise.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Index</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>Pipe</em> and a <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpReservedWritePipe\n\nWrite a packet from Pointer into the reserved area specified by Reserve Id and Index of the pipe object specified by Pipe. The reserved pipe entries are referred to by indices that go from 0 &#8230; Num Packets - 1. Result is 0 if the operation is successful and a negative value otherwise.\n\nResult Type must be a 32-bit integer type scalar.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nIndex must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "9",
      "WordCountFix": 9,
      "OpCode": 277,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "ReserveId",
          "Type": "ID"
        },
        {
          "Name": "Index",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReserveReadPipePackets",
      "Description": "<a id=\"OpReserveReadPipePackets\"></a><strong>OpReserveReadPipePackets</strong><br />\n<br />\nReserve <em>Num Packets</em> entries for reading from the pipe object specified by <em>Pipe</em>. Result is a valid reservation ID if the reservation is successful.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Num Packets</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpReserveReadPipePackets\n\nReserve Num Packets entries for reading from the pipe object specified by Pipe. Result is a valid reservation ID if the reservation is successful.\n\nResult Type must be an OpTypeReserveId.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nNum Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 278,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "NumPackets",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReserveWritePipePackets",
      "Description": "<a id=\"OpReserveWritePipePackets\"></a><strong>OpReserveWritePipePackets</strong><br />\n<br />\nReserve <em>num_packets</em> entries for writing to the pipe object specified by <em>Pipe</em>. Result is a valid reservation ID if the reservation is successful.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Num Packets</em> must be a 32-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> which is treated as an unsigned value.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpReserveWritePipePackets\n\nReserve num_packets entries for writing to the pipe object specified by Pipe. Result is a valid reservation ID if the reservation is successful.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nNum Packets must be a 32-bit OpTypeInt which is treated as an unsigned value.\n\nResult Type must be an OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 279,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "NumPackets",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpCommitReadPipe",
      "Description": "<a id=\"OpCommitReadPipe\"></a><strong>OpCommitReadPipe</strong><br />\n<br />\nIndicates that all reads to <em>Num Packets</em> associated with the reservation specified by <em>Reserve Id</em> and the pipe object specified by <em>Pipe</em> are completed.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpCommitReadPipe\n\nIndicates that all reads to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe are completed.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 280,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "ReserveId",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpCommitWritePipe",
      "Description": "<a id=\"OpCommitWritePipe\"></a><strong>OpCommitWritePipe</strong><br />\n<br />\nIndicates that all writes to <em>Num Packets</em> associated with the reservation specified by <em>Reserve Id</em> and the pipe object specified by <em>Pipe</em> are completed.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpCommitWritePipe\n\nIndicates that all writes to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe are completed.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 281,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "ReserveId",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsValidReserveId",
      "Description": "<a id=\"OpIsValidReserveId\"></a><strong>OpIsValidReserveId</strong><br />\n<br />\nReturn <strong>true</strong> if <em>Reserve Id</em> is a valid reservation id and <strong>false</strong> otherwise.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.",
      "DescriptionPlain": "OpIsValidReserveId\n\nReturn true if Reserve Id is a valid reservation id and false otherwise.\n\nResult Type must be a Boolean type.\n\nReserve Id must have a type of OpTypeReserveId.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 282,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ReserveId",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetNumPipePackets",
      "Description": "<a id=\"OpGetNumPipePackets\"></a><strong>OpGetNumPipePackets</strong><br />\n<br />\nResult is the number of available entries in the pipe object specified by <em>Pipe</em>. The number of available entries in a pipe is a dynamic value.  The value returned should be considered immediately stale.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which should be treated as an unsigned value.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> or <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpGetNumPipePackets\n\nResult is the number of available entries in the pipe object specified by Pipe. The number of available entries in a pipe is a dynamic value.  The value returned should be considered immediately stale.\n\nResult Type must be a 32-bit integer type scalar, which should be treated as an unsigned value.\n\nPipe must have a type of OpTypePipe with ReadOnly or WriteOnly access qualifier.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 283,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetMaxPipePackets",
      "Description": "<a id=\"OpGetMaxPipePackets\"></a><strong>OpGetMaxPipePackets</strong><br />\n<br />\nResult is the maximum number of packets specified when the pipe object specified by <em>Pipe</em> was created.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which should be treated as an unsigned value.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> or <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpGetMaxPipePackets\n\nResult is the maximum number of packets specified when the pipe object specified by Pipe was created.\n\nResult Type must be a 32-bit integer type scalar, which should be treated as an unsigned value.\n\nPipe must have a type of OpTypePipe with ReadOnly or WriteOnly access qualifier.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 284,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupReserveReadPipePackets",
      "Description": "<a id=\"OpGroupReserveReadPipePackets\"></a><strong>OpGroupReserveReadPipePackets</strong><br />\n<br />\nReserve <em>Num Packets</em> entries for reading from the pipe object specified by <em>Pipe</em> at group level. Result is a valid reservation id if the reservation is successful.<br />\n<br />\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; <em>Num Packets</em> - 1.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Num Packets</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpGroupReserveReadPipePackets\n\nReserve Num Packets entries for reading from the pipe object specified by Pipe at group level. Result is a valid reservation id if the reservation is successful.\n\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; Num Packets - 1.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be an OpTypeReserveId.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nNum Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "8",
      "WordCountFix": 8,
      "OpCode": 285,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "NumPackets",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupReserveWritePipePackets",
      "Description": "<a id=\"OpGroupReserveWritePipePackets\"></a><strong>OpGroupReserveWritePipePackets</strong><br />\n<br />\nReserve <em>Num Packets</em> entries for writing to the pipe object specified by <em>Pipe</em> at group level. Result is a valid reservation ID if the reservation is successful.<br />\n<br />\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; <em>Num Packets</em> - 1.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Num Packets</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpGroupReserveWritePipePackets\n\nReserve Num Packets entries for writing to the pipe object specified by Pipe at group level. Result is a valid reservation ID if the reservation is successful.\n\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; Num Packets - 1.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be an OpTypeReserveId.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nNum Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "8",
      "WordCountFix": 8,
      "OpCode": 286,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "NumPackets",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupCommitReadPipe",
      "Description": "<a id=\"OpGroupCommitReadPipe\"></a><strong>OpGroupCommitReadPipe</strong><br />\n<br />\nA group level indication that all reads to <em>Num Packets</em> associated with the reservation specified by <em>Reserve Id</em> to the pipe object specified by <em>Pipe</em> are completed.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpGroupCommitReadPipe\n\nA group level indication that all reads to Num Packets associated with the reservation specified by Reserve Id to the pipe object specified by Pipe are completed.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 287,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "ReserveId",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupCommitWritePipe",
      "Description": "<a id=\"OpGroupCommitWritePipe\"></a><strong>OpGroupCommitWritePipe</strong><br />\n<br />\nA group level indication that all writes to <em>Num Packets</em> associated with the reservation specified by <em>Reserve Id</em> to the pipe object specified by <em>Pipe</em> are completed.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
      "DescriptionPlain": "OpGroupCommitWritePipe\n\nA group level indication that all writes to Num Packets associated with the reservation specified by Reserve Id to the pipe object specified by Pipe are completed.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 288,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "ScopeExecution",
          "Type": "ID"
        },
        {
          "Name": "Pipe",
          "Type": "ID"
        },
        {
          "Name": "ReserveId",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "ID"
        },
        {
          "Name": "PacketAlignment",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConstantPipeStorage",
      "Description": "<a id=\"OpConstantPipeStorage\"></a><strong>OpConstantPipeStorage</strong><br />\n<br />\nCreates a pipe-storage object.<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypePipeStorage\"><strong>OpTypePipeStorage</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.<br />\n<br />\n<em>Capacity</em> is the minimum number of <em>Packet Size</em> blocks the resulting <a href=\"#OpTypePipeStorage\"><strong>OpTypePipeStorage</strong></a> can hold.",
      "DescriptionPlain": "OpConstantPipeStorage\n\nCreates a pipe-storage object.\n\nResult Type must be OpTypePipeStorage.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.\n\nCapacity is the minimum number of Packet Size blocks the resulting OpTypePipeStorage can hold.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 323,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "PacketSize",
          "Type": "LiteralNumber"
        },
        {
          "Name": "PacketAlignment",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Capacity",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpCreatePipeFromPipeStorage",
      "Description": "<a id=\"OpCreatePipeFromPipeStorage\"></a><strong>OpCreatePipeFromPipeStorage</strong><br />\n<br />\nCreates a pipe object from a pipe-storage object.<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a>.<br />\n<br />\n<em>Pipe Storage</em> must be a pipe-storage object created from <a href=\"#OpConstantPipeStorage\"><strong>OpConstantPipeStorage</strong></a>.<br />\n<br />\n<em>Qualifier</em> is the pipe access qualifier.",
      "DescriptionPlain": "OpCreatePipeFromPipeStorage\n\nCreates a pipe object from a pipe-storage object.\n\nResult Type must be OpTypePipe.\n\nPipe Storage must be a pipe-storage object created from OpConstantPipeStorage.\n\nQualifier is the pipe access qualifier.",
      "Category": "Pipe",
      "Capabilities": [
        "Capability"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 324,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "PipeStorage",
          "Type": "ID"
        }
      ]
    }
  ],
  "Enums": [
    {
      "Name": "SourceLanguage",
      "Values": [
        {
          "Value": 0,
          "Name": "Unknown",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "ESSL",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "GLSL",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "OpenCL_C",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "OpenCL_CPP",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "The source language is for debug purposes only, with no semantics that affect the meaning of other parts of the module.\nUsed by <a href=\"#OpSource\"><strong>OpSource</strong></a>.",
      "CommentPlain": "The source language is for debug purposes only, with no semantics that affect the meaning of other parts of the module.\nUsed by OpSource."
    },
    {
      "Name": "ExecutionModel",
      "Values": [
        {
          "Value": 0,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used by <a href=\"#OpEntryPoint\"><strong>OpEntryPoint</strong></a>.",
      "CommentPlain": "Used by OpEntryPoint."
    },
    {
      "Name": "AddressingModel",
      "Values": [
        {
          "Value": 0,
          "Name": "Logical",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Addresses",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Addresses",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used by <a href=\"#OpMemoryModel\"><strong>OpMemoryModel</strong></a>.",
      "CommentPlain": "Used by OpMemoryModel."
    },
    {
      "Name": "MemoryModel",
      "Values": [
        {
          "Value": 0,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used by <a href=\"#OpMemoryModel\"><strong>OpMemoryModel</strong></a>.",
      "CommentPlain": "Used by OpMemoryModel."
    },
    {
      "Name": "ExecutionMode",
      "Values": [
        {
          "Value": 0,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Number of invocations"
            }
          ]
        },
        {
          "Value": 1,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "TransformFeedback",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 12,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 14,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 15,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 17,
          "Name": "LocalSize",
          "Comment": "Indicates the work-group size in the <em>x</em>, <em>y</em>, and <em>z</em> dimensions. Only valid with the <strong>GLCompute</strong> or <strong>Kernel</strong> <a href=\"#Execution_Model\">Execution Models</a>.",
          "CommentPlain": "Indicates the work-group size in the x, y, and z dimensions. Only valid with the GLCompute or Kernel Execution Models.",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "x size"
            },
            {
              "Type": "LiteralNumber",
              "Comment": "y size"
            },
            {
              "Type": "LiteralNumber",
              "Comment": "z size"
            }
          ]
        },
        {
          "Value": 18,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "x size"
            },
            {
              "Type": "LiteralNumber",
              "Comment": "y size"
            },
            {
              "Type": "LiteralNumber",
              "Comment": "z size"
            }
          ]
        },
        {
          "Value": 19,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 20,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 21,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 22,
          "Name": "Geometry",
          "Comment": "trong>Tessellation</strong>",
          "CommentPlain": ", Tessellation",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 23,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 24,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 25,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 26,
          "Name": "Geometry",
          "Comment": "trong>Tessellation</strong>",
          "CommentPlain": ", Tessellation",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Vertex count"
            }
          ]
        },
        {
          "Value": 27,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 28,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 29,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 30,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Vector type"
            }
          ]
        },
        {
          "Value": 31,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 33,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 34,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 35,
          "Name": "SubgroupDispatch",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Subgroup Size"
            }
          ]
        },
        {
          "Value": 36,
          "Name": "SubgroupDispatch",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Subgroups Per Workgroup"
            }
          ]
        }
      ],
      "Comment": "Declare the modes an <a href=\"#EntryPoint\">entry point</a> will execute in.\nUsed by <a href=\"#OpExecutionMode\"><strong>OpExecutionMode</strong></a>.",
      "CommentPlain": "Declare the modes an entry point will execute in.\nUsed by OpExecutionMode."
    },
    {
      "Name": "StorageClass",
      "Values": [
        {
          "Value": 0,
          "Name": "UniformConstant",
          "Comment": "Shared externally, visible across all functions in all <a href=\"#Invocation\">invocations</a> in all work groups. Graphics uniform memory. OpenCL constant memory. Variables declared with this storage class are read-only, and cannot have initializers.",
          "CommentPlain": "Shared externally, visible across all functions in all invocations in all work groups. Graphics uniform memory. OpenCL constant memory. Variables declared with this storage class are read-only, and cannot have initializers.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Input",
          "Comment": "Input from pipeline. Visible across all functions in the current <a href=\"#Invocation\">invocation</a>. Variables declared with this storage class are read-only, and cannot have initializers.",
          "CommentPlain": "Input from pipeline. Visible across all functions in the current invocation. Variables declared with this storage class are read-only, and cannot have initializers.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Workgroup",
          "Comment": "Shared across all <a href=\"#Invocation\">invocations</a> within a work group. Visible across all functions. The OpenGL \"shared\" storage qualifier.  OpenCL local memory.",
          "CommentPlain": "Shared across all invocations within a work group. Visible across all functions. The OpenGL \"shared\" storage qualifier.  OpenCL local memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "CrossWorkgroup",
          "Comment": "Visible across all functions of all <a href=\"#Invocation\">invocations</a> of all work groups. OpenCL global memory.",
          "CommentPlain": "Visible across all functions of all invocations of all work groups. OpenCL global memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "Function",
          "Comment": "Visible only within the declaring function of the current <a href=\"#Invocation\">invocation</a>. Regular function memory.",
          "CommentPlain": "Visible only within the declaring function of the current invocation. Regular function memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "GenericPointer",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "AtomicStorage",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "Image",
          "Comment": "For holding <a href=\"#ImageTerm\">image</a> memory.",
          "CommentPlain": "For holding image memory.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Class of storage for declared variables (does not include <a href=\"#Intermediate\"><em>intermediate</em></a> values).\nUsed by:",
      "CommentPlain": "Class of storage for declared variables (does not include intermediate values).\nUsed by:"
    },
    {
      "Name": "Dim",
      "Values": [
        {
          "Value": 0,
          "Name": "Sampled1D",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "2D",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "3D",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "SampledRect",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "SampledBuffer",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "InputAttachment",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Dimensionality of an image.\nUsed by <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.",
      "CommentPlain": "Dimensionality of an image.\nUsed by OpTypeImage."
    },
    {
      "Name": "SamplerAddressingMode",
      "Values": [
        {
          "Value": 0,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Addressing mode for creating constant samplers.\nUsed by <a href=\"#OpConstantSampler\"><strong>OpConstantSampler</strong></a>.",
      "CommentPlain": "Addressing mode for creating constant samplers.\nUsed by OpConstantSampler."
    },
    {
      "Name": "SamplerFilterMode",
      "Values": [
        {
          "Value": 0,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Filter mode for creating constant samplers.\nUsed by <a href=\"#OpConstantSampler\"><strong>OpConstantSampler</strong></a>.",
      "CommentPlain": "Filter mode for creating constant samplers.\nUsed by OpConstantSampler."
    },
    {
      "Name": "ImageFormat",
      "Values": [
        {
          "Value": 0,
          "Name": "Unknown",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 12,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 13,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 14,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 15,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 17,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 18,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 19,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 20,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 21,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 22,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 23,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 24,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 25,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 26,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 27,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 28,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 29,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 30,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 31,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 32,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 33,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 34,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 35,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 36,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 37,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 38,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 39,
          "Name": "StorageImageExtendedFormats",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Declarative image format.\nUsed by <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.",
      "CommentPlain": "Declarative image format.\nUsed by OpTypeImage."
    },
    {
      "Name": "ImageChannelOrder",
      "Values": [
        {
          "Value": 0,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 12,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 13,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 14,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 15,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 17,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 18,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 19,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Image channel order returned by <a href=\"#OpImageQueryOrder\"><strong>OpImageQueryOrder</strong></a>.",
      "CommentPlain": "Image channel order returned by OpImageQueryOrder."
    },
    {
      "Name": "ImageChannelDataType",
      "Values": [
        {
          "Value": 0,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 12,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 13,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 14,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 15,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Image channel data type returned by <a href=\"#OpImageQueryFormat\"><strong>OpImageQueryFormat</strong></a>.",
      "CommentPlain": "Image channel data type returned by OpImageQueryFormat."
    },
    {
      "Name": "ImageOperands",
      "Values": [
        {
          "Value": 0,
          "Name": "None",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Lod",
          "Comment": "A following operand is the explicit level-of-detail to use.  Only valid with explicit-lod instructions. For sampling operations, it must be a <a href=\"#Floating\"><em>floating-point type</em></a> scalar.  For queries and fetch operations, it must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  This can only be used with an <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> that has a <a href=\"#Dim\"><em>Dim</em></a> operand of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>, and the <em>MS</em> operand must be 0.",
          "CommentPlain": "A following operand is the explicit level-of-detail to use.  Only valid with explicit-lod instructions. For sampling operations, it must be a floating-point type scalar.  For queries and fetch operations, it must be an integer type scalar.  This can only be used with an OpTypeImage that has a Dim operand of 1D, 2D, 3D, or Cube, and the MS operand must be 0.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Grad",
          "Comment": "Two following operands are <em>dx</em> followed by <em>dy</em>.  These are explicit derivatives in the <em>x</em> and <em>y</em> direction to use in computing level of detail. Each is a scalar or vector containing (<em>du/dx</em>[, <em>dv/dx</em>] [, <em>dw/dx</em>]) and (<em>du/dy</em>[, <em>dv/dy</em>] [, <em>dw/dy</em>]). The number of components of each must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present. Only valid with explicit-lod instructions. They must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  This can only be used with an <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> that has an <em>MS</em> operand of 0. It is invalid to set both the <strong>Lod</strong> and <strong>Grad</strong> bits.",
          "CommentPlain": "Two following operands are dx followed by dy.  These are explicit derivatives in the x and y direction to use in computing level of detail. Each is a scalar or vector containing (du/dx[, dv/dx] [, dw/dx]) and (du/dy[, dv/dy] [, dw/dy]). The number of components of each must equal the number of components in Coordinate, minus the array layer component, if present. Only valid with explicit-lod instructions. They must be a scalar or vector of floating-point type.  This can only be used with an OpTypeImage that has an MS operand of 0. It is invalid to set both the Lod and Grad bits.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "ConstOffset",
          "Comment": "A following operand is added to (<em>u</em>, <em>v</em>, <em>w</em>) before texel lookup. It must be an <em>&lt;id&gt;</em> of an integer-based <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of scalar or vector type. It is invalid for these to be outside a target-dependent allowed range. The number of components must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.",
          "CommentPlain": "A following operand is added to (u, v, w) before texel lookup. It must be an &lt;id&gt; of an integer-based constant instruction of scalar or vector type. It is invalid for these to be outside a target-dependent allowed range. The number of components must equal the number of components in Coordinate, minus the array layer component, if present.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "ImageGatherExtended",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 32,
          "Name": "ConstOffsets",
          "Comment": "A following operand is <em>Offsets</em>. <em>Offsets</em> must be an <em>&lt;id&gt;</em> of a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> making an array of size four of vectors of two integer components. Each gathered texel is identified by adding one of these array elements to the (<em>u</em>, <em>v</em>) sampled location. It is a compile-time error if this falls outside a target-dependent allowed range. Only valid with <a href=\"#OpImageGather\"><strong>OpImageGather</strong></a> or <a href=\"#OpImageDrefGather\"><strong>OpImageDrefGather</strong></a>.",
          "CommentPlain": "A following operand is Offsets. Offsets must be an &lt;id&gt; of a constant instruction making an array of size four of vectors of two integer components. Each gathered texel is identified by adding one of these array elements to the (u, v) sampled location. It is a compile-time error if this falls outside a target-dependent allowed range. Only valid with OpImageGather or OpImageDrefGather.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 64,
          "Name": "Sample",
          "Comment": "A following operand is the sample number of the sample to use. Only valid with <a href=\"#OpImageFetch\"><strong>OpImageFetch</strong></a>, <a href=\"#OpImageRead\"><strong>OpImageRead</strong></a>, and <a href=\"#OpImageWrite\"><strong>OpImageWrite</strong></a>. It is invalid to have a <strong>Sample</strong> operand if the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> has <em>MS</em> of 0. It must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.",
          "CommentPlain": "A following operand is the sample number of the sample to use. Only valid with OpImageFetch, OpImageRead, and OpImageWrite. It is invalid to have a Sample operand if the underlying OpTypeImage has MS of 0. It must be an integer type scalar.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 128,
          "Name": "MinLod",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Additional operands to sampling, or getting texels from, an image. Bits that are set can indicate that another operand follows. If there are multiple following operands indicated, they are ordered: Those indicated by smaller-numbered bits appear first. At least one bit must be set (<strong>None</strong> is invalid).",
      "CommentPlain": "Additional operands to sampling, or getting texels from, an image. Bits that are set can indicate that another operand follows. If there are multiple following operands indicated, they are ordered: Those indicated by smaller-numbered bits appear first. At least one bit must be set (None is invalid)."
    },
    {
      "Name": "FPFastMathMode",
      "Values": [
        {
          "Value": 0,
          "Name": "None",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Enables fast math operations which are otherwise unsafe.",
      "CommentPlain": "Enables fast math operations which are otherwise unsafe."
    },
    {
      "Name": "FPRoundingMode",
      "Values": [
        {
          "Value": 0,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Associate a rounding mode to a floating-point conversion instruction.",
      "CommentPlain": "Associate a rounding mode to a floating-point conversion instruction."
    },
    {
      "Name": "LinkageType",
      "Values": [
        {
          "Value": 0,
          "Name": "Linkage",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Linkage",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Associate a linkage type to functions or global variables. See <a href=\"#Linkage\">linkage</a>.",
      "CommentPlain": "Associate a linkage type to functions or global variables. See linkage."
    },
    {
      "Name": "AccessQualifier",
      "Values": [
        {
          "Value": 0,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Defines the access permissions.",
      "CommentPlain": "Defines the access permissions."
    },
    {
      "Name": "FunctionParameterAttribute",
      "Values": [
        {
          "Value": 0,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Adds additional information to the return type and to each parameter of a function.",
      "CommentPlain": "Adds additional information to the return type and to each parameter of a function."
    },
    {
      "Name": "Decoration",
      "Values": [
        {
          "Value": 0,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Shader",
          "Comment": "trong>Kernel</strong>",
          "CommentPlain": ", Kernel",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Specialization Constant ID"
            }
          ]
        },
        {
          "Value": 2,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Matrix",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "Matrix",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Array Stride"
            }
          ]
        },
        {
          "Value": 7,
          "Name": "Matrix",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Matrix Stride"
            }
          ]
        },
        {
          "Value": 8,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "BuiltIn",
          "Comment": "Apply to an object or a member of a structure type.  Indicates which built-in variable the entity represents.  See <a href=\"#BuiltIn\">BuiltIn</a> for more information.",
          "CommentPlain": "Apply to an object or a member of a structure type.  Indicates which built-in variable the entity represents.  See BuiltIn for more information.",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "BuiltIn",
              "Comment": ""
            }
          ]
        },
        {
          "Value": 13,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 14,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 15,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 17,
          "Name": "SampleRateShading",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 18,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 19,
          "Name": "Restrict",
          "Comment": "Apply to a variable, to indicate the compiler may compile as if there is no aliasing.  See the <a href=\"#AliasingSection\">Aliasing</a> section for more detail.",
          "CommentPlain": "Apply to a variable, to indicate the compiler may compile as if there is no aliasing.  See the Aliasing section for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 20,
          "Name": "Aliased",
          "Comment": "Apply to a variable, to indicate the compiler is to generate accesses to the variable that work correctly in the presence of aliasing.  See the <a href=\"#AliasingSection\">Aliasing</a> section for more detail.",
          "CommentPlain": "Apply to a variable, to indicate the compiler is to generate accesses to the variable that work correctly in the presence of aliasing.  See the Aliasing section for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 21,
          "Name": "Volatile",
          "Comment": "Apply to an object or a member of a structure type.  Can only be used for objects declared as storage images (see <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>) or in the <strong>Uniform</strong> <a href=\"#Storage_Class\">Storage Class</a> with the <strong>BufferBlock</strong> <a href=\"#Decoration\">Decoration</a>. This indicates the memory holding the variable is volatile memory. Accesses to volatile memory cannot be eliminated, duplicated, or combined with other accesses. The variable cannot be in the <strong>Function</strong> <a href=\"#Storage_Class\">Storage Class</a>.",
          "CommentPlain": "Apply to an object or a member of a structure type.  Can only be used for objects declared as storage images (see OpTypeImage) or in the Uniform Storage Class with the BufferBlock Decoration. This indicates the memory holding the variable is volatile memory. Accesses to volatile memory cannot be eliminated, duplicated, or combined with other accesses. The variable cannot be in the Function Storage Class.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 22,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 23,
          "Name": "Coherent",
          "Comment": "Apply to an object or a member of a structure type.  Can only be used for objects declared as storage images (see <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>) or in the <strong>Uniform</strong> <a href=\"#Storage_Class\">Storage Class</a> with the <strong>BufferBlock</strong> <a href=\"#Decoration\">Decoration</a>. This indicates the memory backing the object is coherent.",
          "CommentPlain": "Apply to an object or a member of a structure type.  Can only be used for objects declared as storage images (see OpTypeImage) or in the Uniform Storage Class with the BufferBlock Decoration. This indicates the memory backing the object is coherent.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 24,
          "Name": "NonWritable",
          "Comment": "Apply to an object or a member of a structure type.  Can only be used for objects declared as storage images (see <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>) or in the <strong>Uniform</strong> <a href=\"#Storage_Class\">Storage Class</a> with the <strong>BufferBlock</strong> <a href=\"#Decoration\">Decoration</a>. This indicates the memory holding the variable is not writable, and that this module does not write to it.",
          "CommentPlain": "Apply to an object or a member of a structure type.  Can only be used for objects declared as storage images (see OpTypeImage) or in the Uniform Storage Class with the BufferBlock Decoration. This indicates the memory holding the variable is not writable, and that this module does not write to it.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 25,
          "Name": "NonReadable",
          "Comment": "Apply to an object or a member of a structure type.  Can only be used for objects declared as storage images (see <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>) or in the <strong>Uniform</strong> <a href=\"#Storage_Class\">Storage Class</a> with the <strong>BufferBlock</strong> <a href=\"#Decoration\">Decoration</a>. This indicates the memory holding the variable is not readable, and that this module does not read from it.",
          "CommentPlain": "Apply to an object or a member of a structure type.  Can only be used for objects declared as storage images (see OpTypeImage) or in the Uniform Storage Class with the BufferBlock Decoration. This indicates the memory holding the variable is not readable, and that this module does not read from it.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 26,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 28,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 29,
          "Name": "GeometryStreams",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Stream Number"
            }
          ]
        },
        {
          "Value": 30,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Location"
            }
          ]
        },
        {
          "Value": 31,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Component"
            }
          ]
        },
        {
          "Value": 32,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Index"
            }
          ]
        },
        {
          "Value": 33,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Binding Point"
            }
          ]
        },
        {
          "Value": 34,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Descriptor Set"
            }
          ]
        },
        {
          "Value": 35,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Byte Offset"
            }
          ]
        },
        {
          "Value": 36,
          "Name": "TransformFeedback",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "XFB Buffer Number"
            }
          ]
        },
        {
          "Value": 37,
          "Name": "TransformFeedback",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "XFB Stride"
            }
          ]
        },
        {
          "Value": 38,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "FunctionParameterAttribute",
              "Comment": "Function Parameter Attribute"
            }
          ]
        },
        {
          "Value": 39,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "FPRoundingMode",
              "Comment": "Floating-Point Rounding Mode"
            }
          ]
        },
        {
          "Value": 40,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "FPFastMathMode",
              "Comment": "Fast-Math Mode"
            }
          ]
        },
        {
          "Value": 41,
          "Name": "Linkage",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralString",
              "Comment": "Name"
            },
            {
              "Type": "LinkageType",
              "Comment": "Linkage Type"
            }
          ]
        },
        {
          "Value": 42,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 43,
          "Name": "InputAttachment",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Attachment Index"
            }
          ]
        },
        {
          "Value": 44,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Alignment"
            }
          ]
        },
        {
          "Value": 45,
          "Name": "Addresses",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Max Byte Offset"
            }
          ]
        }
      ],
      "Comment": "Used by <a href=\"#OpDecorate\"><strong>OpDecorate</strong></a> and <a href=\"#OpMemberDecorate\"><strong>OpMemberDecorate</strong></a>.",
      "CommentPlain": "Used by OpDecorate and OpMemberDecorate."
    },
    {
      "Name": "BuiltIn",
      "Values": [
        {
          "Value": 0,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "ClipDistance",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "CullDistance",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "Geometry",
          "Comment": "trong>Tessellation</strong>",
          "CommentPlain": ", Tessellation",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "Geometry",
          "Comment": "trong>Tessellation</strong>",
          "CommentPlain": ", Tessellation",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "Geometry",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "MultiViewport",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 12,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 13,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 14,
          "Name": "Tessellation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 15,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 17,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 18,
          "Name": "SampleRateShading",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 19,
          "Name": "SampleRateShading",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 20,
          "Name": "SampleRateShading",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 22,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 23,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 24,
          "Name": "NumWorkgroups",
          "Comment": "Number of workgroups in <strong>GLCompute</strong> or <strong>Kernel</strong>  <a href=\"#Execution_Model\">Execution Models</a>. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "CommentPlain": "Number of workgroups in GLCompute or Kernel  Execution Models. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 25,
          "Name": "WorkgroupSize",
          "Comment": "Work-group size in <strong>GLCompute</strong> or <strong>Kernel</strong>  <a href=\"#Execution_Model\">Execution Models</a>. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "CommentPlain": "Work-group size in GLCompute or Kernel  Execution Models. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 26,
          "Name": "WorkgroupId",
          "Comment": "Work-group ID in <strong>GLCompute</strong> or <strong>Kernel</strong>  <a href=\"#Execution_Model\">Execution Models</a>. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "CommentPlain": "Work-group ID in GLCompute or Kernel  Execution Models. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 27,
          "Name": "LocalInvocationId",
          "Comment": "Local invocation ID in <strong>GLCompute</strong> or <strong>Kernel</strong>  <a href=\"#Execution_Model\">Execution Models</a>. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "CommentPlain": "Local invocation ID in GLCompute or Kernel  Execution Models. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 28,
          "Name": "GlobalInvocationId",
          "Comment": "Global invocation ID in <strong>GLCompute</strong> or <strong>Kernel</strong>  <a href=\"#Execution_Model\">Execution Models</a>. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "CommentPlain": "Global invocation ID in GLCompute or Kernel  Execution Models. See OpenCL, Vulkan, or OpenGL API specifications for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 29,
          "Name": "LocalInvocationIndex",
          "Comment": "Local invocation index in <strong>GLCompute</strong> <a href=\"#Execution_Model\">Execution Models</a>. See Vulkan or OpenGL API specifications for more detail. <br />\n<br />\nWork-group Linear ID in <strong>Kernel</strong> <a href=\"#Execution_Model\">Execution Models</a>. See OpenCL API specification for more detail.",
          "CommentPlain": "Local invocation index in GLCompute Execution Models. See Vulkan or OpenGL API specifications for more detail. \n\nWork-group Linear ID in Kernel Execution Models. See OpenCL API specification for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 30,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 31,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 32,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 33,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 34,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 36,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 37,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 38,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 39,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 40,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 41,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 42,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 43,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4416,
          "Name": "SubgroupBallotKHR",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4417,
          "Name": "SubgroupBallotKHR",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4418,
          "Name": "SubgroupBallotKHR",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4419,
          "Name": "SubgroupBallotKHR",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4420,
          "Name": "SubgroupBallotKHR",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4424,
          "Name": "DrawParameters",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4425,
          "Name": "DrawParameters",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4426,
          "Name": "DrawParameters",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used when <a href=\"#Decoration\"><strong>Decoration</strong></a> is <strong>BuiltIn</strong>. Apply to either",
      "CommentPlain": "Used when Decoration is BuiltIn. Apply to either"
    },
    {
      "Name": "SelectionControl",
      "Values": [
        {
          "Value": 0,
          "Name": "None",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Flatten",
          "Comment": "Strong request, to the extent possible, to remove the control flow for this selection.",
          "CommentPlain": "Strong request, to the extent possible, to remove the control flow for this selection.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "DontFlatten",
          "Comment": "Strong request, to the extent possible, to keep this selection as control flow.",
          "CommentPlain": "Strong request, to the extent possible, to keep this selection as control flow.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "This value is a mask; it can be formed by combining the bits from multiple rows in the table below.",
      "CommentPlain": "This value is a mask; it can be formed by combining the bits from multiple rows in the table below."
    },
    {
      "Name": "LoopControl",
      "Values": [
        {
          "Value": 0,
          "Name": "None",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Unroll",
          "Comment": "Strong request, to the extent possible, to unroll or unwind this loop.",
          "CommentPlain": "Strong request, to the extent possible, to unroll or unwind this loop.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "DontUnroll",
          "Comment": "Strong request, to the extent possible, to keep this loop as a loop, without unrolling.",
          "CommentPlain": "Strong request, to the extent possible, to keep this loop as a loop, without unrolling.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "DependencyInfinite",
          "Comment": "Guarantees that there are no dependencies between loop iterations.",
          "CommentPlain": "Guarantees that there are no dependencies between loop iterations.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "DependencyLength",
          "Comment": "Guarantees that there are no dependencies between a number of loop iterations,specified as a subsequent literal-number operand to the instruction.",
          "CommentPlain": "Guarantees that there are no dependencies between a number of loop iterations,specified as a subsequent literal-number operand to the instruction.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "This value is a mask; it can be formed by combining the bits from multiple rows in the table below.",
      "CommentPlain": "This value is a mask; it can be formed by combining the bits from multiple rows in the table below."
    },
    {
      "Name": "FunctionControl",
      "Values": [
        {
          "Value": 0,
          "Name": "None",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Inline",
          "Comment": "Strong request, to the extent possible, to inline the function.",
          "CommentPlain": "Strong request, to the extent possible, to inline the function.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "DontInline",
          "Comment": "Strong request, to the extent possible, to not inline the function.",
          "CommentPlain": "Strong request, to the extent possible, to not inline the function.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Pure",
          "Comment": "Compiler can assume this function has no side effect, but might read global memory or read through dereferenced function parameters. Always computes the same result for the same argument values.",
          "CommentPlain": "Compiler can assume this function has no side effect, but might read global memory or read through dereferenced function parameters. Always computes the same result for the same argument values.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "Const",
          "Comment": "Compiler can assume this function has no side effects, and will not access global memory or dereference function parameters. Always computes the same result for the same argument values.",
          "CommentPlain": "Compiler can assume this function has no side effects, and will not access global memory or dereference function parameters. Always computes the same result for the same argument values.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "This value is a mask; it can be formed by combining the bits from multiple rows in the table below.",
      "CommentPlain": "This value is a mask; it can be formed by combining the bits from multiple rows in the table below."
    },
    {
      "Name": "MemorySemantics&lt;id&gt;",
      "Values": [
        {
          "Value": 0,
          "Name": "None (Relaxed)",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Acquire",
          "Comment": "All memory operations provided in program order after this memory operation will execute after this memory operation.",
          "CommentPlain": "All memory operations provided in program order after this memory operation will execute after this memory operation.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Release",
          "Comment": "All memory operations provided in program order before this memory operation will execute before this memory operation.",
          "CommentPlain": "All memory operations provided in program order before this memory operation will execute before this memory operation.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "AcquireRelease",
          "Comment": "Has the properties of both <a href=\"#Memory_Semantics\"><strong>Acquire</strong></a> and <a href=\"#Memory_Semantics\"><strong>Release</strong></a> semantics.  It is used for read-modify-write operations.",
          "CommentPlain": "Has the properties of both Acquire and Release semantics.  It is used for read-modify-write operations.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "SequentiallyConsistent",
          "Comment": "All observers will see this memory access in the same order with respect to other sequentially-consistent memory accesses from this <a href=\"#Invocation\">invocation</a>.",
          "CommentPlain": "All observers will see this memory access in the same order with respect to other sequentially-consistent memory accesses from this invocation.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 64,
          "Name": "Shader",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 128,
          "Name": "SubgroupMemory",
          "Comment": "Apply the memory-ordering constraints to subgroup memory.",
          "CommentPlain": "Apply the memory-ordering constraints to subgroup memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 256,
          "Name": "WorkgroupMemory",
          "Comment": "Apply the memory-ordering constraints to <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a> memory.",
          "CommentPlain": "Apply the memory-ordering constraints to Workgroup Storage Class memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 512,
          "Name": "CrossWorkgroupMemory",
          "Comment": "Apply the memory-ordering constraints to <strong>CrossWorkgroup</strong> <a href=\"#Storage_Class\">Storage Class</a> memory.",
          "CommentPlain": "Apply the memory-ordering constraints to CrossWorkgroup Storage Class memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1024,
          "Name": "AtomicStorage",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2048,
          "Name": "ImageMemory",
          "Comment": "Apply the memory-ordering constraints to image contents (types declared by <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>), or to accesses done through pointers to the <strong>Image</strong> <a href=\"#Storage_Class\">Storage Class</a>.",
          "CommentPlain": "Apply the memory-ordering constraints to image contents (types declared by OpTypeImage), or to accesses done through pointers to the Image Storage Class.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Must be an <em>&lt;id&gt;</em> of a 32-bit integer scalar that contains a mask.  The rest of this description is about that mask.",
      "CommentPlain": "Must be an &lt;id&gt; of a 32-bit integer scalar that contains a mask.  The rest of this description is about that mask."
    },
    {
      "Name": "MemoryAccess",
      "Values": [
        {
          "Value": 0,
          "Name": "None",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Volatile",
          "Comment": "This access cannot be eliminated, duplicated, or combined with other accesses.",
          "CommentPlain": "This access cannot be eliminated, duplicated, or combined with other accesses.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Aligned",
          "Comment": "This access has a known alignment, provided as a literal in the next operand.",
          "CommentPlain": "This access has a known alignment, provided as a literal in the next operand.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Nontemporal",
          "Comment": "Hints that the accessed address is not likely to be accessed again in the near future.",
          "CommentPlain": "Hints that the accessed address is not likely to be accessed again in the near future.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Memory access semantics.",
      "CommentPlain": "Memory access semantics."
    },
    {
      "Name": "Scope&lt;id&gt;",
      "Values": [
        {
          "Value": 0,
          "Name": "CrossDevice",
          "Comment": "Scope crosses multiple devices.",
          "CommentPlain": "Scope crosses multiple devices.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Device",
          "Comment": "Scope is the current device.",
          "CommentPlain": "Scope is the current device.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Workgroup",
          "Comment": "Scope is the current workgroup.",
          "CommentPlain": "Scope is the current workgroup.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Subgroup",
          "Comment": "Scope is the current subgroup.",
          "CommentPlain": "Scope is the current subgroup.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Invocation",
          "Comment": "Scope is the current <a href=\"#Invocation\">Invocation</a>.",
          "CommentPlain": "Scope is the current Invocation.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Must be an <em>&lt;id&gt;</em> of a 32-bit integer scalar that contains a mask.  The rest of this description is about that mask.",
      "CommentPlain": "Must be an &lt;id&gt; of a 32-bit integer scalar that contains a mask.  The rest of this description is about that mask."
    },
    {
      "Name": "GroupOperation",
      "Values": [
        {
          "Value": 0,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Defines the class of workgroup or subgroup operation.\nUsed by:",
      "CommentPlain": "Defines the class of workgroup or subgroup operation.\nUsed by:"
    },
    {
      "Name": "KernelEnqueueFlags",
      "Values": [
        {
          "Value": 0,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Specify when the child kernel begins execution.<br />\n<br />\n<strong>Note:</strong> Implementations are not required to honor this flag.  Implementations may not schedule kernel launch earlier than the point specified by this flag, however. Used by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a>.",
      "CommentPlain": "Specify when the child kernel begins execution.\n\nNote: Implementations are not required to honor this flag.  Implementations may not schedule kernel launch earlier than the point specified by this flag, however. Used by OpEnqueueKernel."
    },
    {
      "Name": "KernelProfilingInfo",
      "Values": [
        {
          "Value": 0,
          "Name": "None",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Kernel",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Specify the profiling information to be queried. Used by <a href=\"#OpCaptureEventProfilingInfo\"><strong>OpCaptureEventProfilingInfo</strong></a>.",
      "CommentPlain": "Specify the profiling information to be queried. Used by OpCaptureEventProfilingInfo."
    },
    {
      "Name": "Instructions",
      "Values": [],
      "Comment": "Form for each instruction:",
      "CommentPlain": "Form for each instruction:"
    }
  ],
  "Extensions": [
    {
      "Metadata": {
        "Language": "GLSL",
        "Version": 450,
        "Title": "SPIR-V Extended Instructions for GLSL",
        "Author": "John Kessenich, Google",
        "Revnumber": "version 1.00, Revision 4",
        "LastUpdate": "Last updated 2017-02-14 16:32:17 MST"
      },
      "ExtendedInstructions": [
        {
          "Name": "Round",
          "OriginalName": "Round",
          "Description": "Result is the value equal to the nearest whole number to <em>x</em>. The fraction 0.5 will round in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that <strong>Round</strong> <em>x</em> is the same value as <strong>RoundEven</strong> <em>x</em> for all values of <em>x</em>.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the value equal to the nearest whole number to x. The fraction 0.5 will round in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that Round x is the same value as RoundEven x for all values of x.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 1,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "RoundEven",
          "OriginalName": "RoundEven",
          "Description": "Result is the value equal to the nearest whole number to <em>x</em>. A fractional part of 0.5 will round toward the nearest even whole number. (Both 3.5 and 4.5 for <em>x</em> will be 4.0.)<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the value equal to the nearest whole number to x. A fractional part of 0.5 will round toward the nearest even whole number. (Both 3.5 and 4.5 for x will be 4.0.)\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 2,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Trunc",
          "OriginalName": "Trunc",
          "Description": "Result is the value equal to the nearest whole number to <em>x</em> whose absolute value is not larger than the absolute value of <em>x</em>.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the value equal to the nearest whole number to x whose absolute value is not larger than the absolute value of x.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 3,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FAbs",
          "OriginalName": "FAbs",
          "Description": "Result is <em>x</em> if <em>x</em> &ge; 0; otherwise result is -<em>x</em>.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is x if x &ge; 0; otherwise result is -x.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 4,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "SAbs",
          "OriginalName": "SAbs",
          "Description": "Result is <em>x</em> if <em>x</em> &ge; 0; otherwise result is -<em>x</em>, where <em>x</em> is interpreted as a signed integer.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.",
          "DescriptionPlain": "Result is x if x &ge; 0; otherwise result is -x, where x is interpreted as a signed integer.\n\n Result Type and the type of x must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.",
          "Number": 5,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FSign",
          "OriginalName": "FSign",
          "Description": "Result is 1.0 if <em>x</em> &gt; 0, 0.0 if <em>x</em> = 0, or -1.0 if <em>x</em> &lt; 0.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is 1.0 if x &gt; 0, 0.0 if x = 0, or -1.0 if x &lt; 0.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 6,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "SSign",
          "OriginalName": "SSign",
          "Description": "Result is 1 if <em>x</em> &gt; 0, 0 if <em>x</em> = 0, or -1 if <em>x</em> &lt; 0, where <em>x</em> is interpreted as a signed integer.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.",
          "DescriptionPlain": "Result is 1 if x &gt; 0, 0 if x = 0, or -1 if x &lt; 0, where x is interpreted as a signed integer.\n\n Result Type and the type of x must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.",
          "Number": 7,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Floor",
          "OriginalName": "Floor",
          "Description": "Result is the value equal to the nearest whole number that is less than or equal to <em>x</em>.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the value equal to the nearest whole number that is less than or equal to x.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 8,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Ceil",
          "OriginalName": "Ceil",
          "Description": "Result is the value equal to the nearest whole number that is greater than or equal to <em>x</em>.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the value equal to the nearest whole number that is greater than or equal to x.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 9,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Fract",
          "OriginalName": "Fract",
          "Description": "Result is <em>x</em> - <strong>floor</strong> <em>x</em>.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is x - floor x.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 10,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Radians",
          "OriginalName": "Radians",
          "Description": "Converts <em>degrees</em> to radians, i.e., <em>degrees</em> * &#960; / 180.<br />\n<br />\n The operand <em>degrees</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>degrees</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Converts degrees to radians, i.e., degrees * &#960; / 180.\n\n The operand degrees must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of degrees must be the same type. Results are computed per component.",
          "Number": 11,
          "Operands": [
            {
              "Name": "degrees",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Degrees",
          "OriginalName": "Degrees",
          "Description": "Converts <em>radians</em> to degrees, i.e., <em>radians</em> * 180 / &#960;.<br />\n<br />\n The operand <em>radians</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>radians</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Converts radians to degrees, i.e., radians * 180 / &#960;.\n\n The operand radians must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of radians must be the same type. Results are computed per component.",
          "Number": 12,
          "Operands": [
            {
              "Name": "radians",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Sin",
          "OriginalName": "Sin",
          "Description": "The standard trigonometric sine of <em>x</em> radians.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "The standard trigonometric sine of x radians.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 13,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Cos",
          "OriginalName": "Cos",
          "Description": "The standard trigonometric cosine of <em>x</em> radians.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "The standard trigonometric cosine of x radians.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 14,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Tan",
          "OriginalName": "Tan",
          "Description": "The standard trigonometric tangent of <em>x</em> radians.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "The standard trigonometric tangent of x radians.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 15,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Asin",
          "OriginalName": "Asin",
          "Description": "Arc sine. Result is an angle, in radians, whose sine is <em>x</em>. The range of result values is [-&#960; / 2, &#960; / 2]. Result is undefined if <strong>abs</strong> <em>x</em> &gt; 1.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Arc sine. Result is an angle, in radians, whose sine is x. The range of result values is [-&#960; / 2, &#960; / 2]. Result is undefined if abs x &gt; 1.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 16,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Acos",
          "OriginalName": "Acos",
          "Description": "Arc cosine. Result is an angle, in radians, whose cosine is <em>x</em>. The range of result values is [0, &#960;]. Result is undefined if <strong>abs</strong> <em>x</em> &gt; 1.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Arc cosine. Result is an angle, in radians, whose cosine is x. The range of result values is [0, &#960;]. Result is undefined if abs x &gt; 1.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 17,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Atan",
          "OriginalName": "Atan",
          "Description": "Arc tangent. Result is an angle, in radians, whose tangent is <em>y_over_x</em>. The range of result values is [-&#960;, &#960;].<br />\n<br />\n The operand <em>y_over_x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>y_over_x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Arc tangent. Result is an angle, in radians, whose tangent is y_over_x. The range of result values is [-&#960;, &#960;].\n\n The operand y_over_x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of y_over_x must be the same type. Results are computed per component.",
          "Number": 18,
          "Operands": [
            {
              "Name": "y_over_x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Sinh",
          "OriginalName": "Sinh",
          "Description": "Hyperbolic sine of <em>x</em> radians.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Hyperbolic sine of x radians.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 19,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Cosh",
          "OriginalName": "Cosh",
          "Description": "Hyperbolic cosine of <em>x</em> radians.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Hyperbolic cosine of x radians.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 20,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Tanh",
          "OriginalName": "Tanh",
          "Description": "Hyperbolic tangent of <em>x</em> radians.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Hyperbolic tangent of x radians.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 21,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Asinh",
          "OriginalName": "Asinh",
          "Description": "Arc hyperbolic sine; result is the inverse of <strong>sinh</strong>.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Arc hyperbolic sine; result is the inverse of sinh.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 22,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Acosh",
          "OriginalName": "Acosh",
          "Description": "Arc hyperbolic cosine; Result is the non-negative inverse of <strong>cosh</strong>. Result is undefined if <em>x</em> &lt; 1.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Arc hyperbolic cosine; Result is the non-negative inverse of cosh. Result is undefined if x &lt; 1.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 23,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Atanh",
          "OriginalName": "Atanh",
          "Description": "Arc hyperbolic tangent; result is the inverse of tanh. Result is undefined if <strong>abs</strong> <em>x</em> &ge; 1.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Arc hyperbolic tangent; result is the inverse of tanh. Result is undefined if abs x &ge; 1.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 24,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Atan2",
          "OriginalName": "Atan2",
          "Description": "Arc tangent. Result is an angle, in radians, whose tangent is <em>y</em> / <em>x</em>. The signs of <em>x</em> and <em>y</em> are used to determine what quadrant the angle is in. The range of result values is  [-&#960;, &#960;] . Result is undefined if <em>x</em> and <em>y</em> are both 0.<br />\n<br />\n The operand <em>x</em> and <em>y</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Arc tangent. Result is an angle, in radians, whose tangent is y / x. The signs of x and y are used to determine what quadrant the angle is in. The range of result values is  [-&#960;, &#960;] . Result is undefined if x and y are both 0.\n\n The operand x and y must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 25,
          "Operands": [
            {
              "Name": "y",
              "Type": "ID"
            },
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Pow",
          "OriginalName": "Pow",
          "Description": "Result is <em>x</em> raised to the <em>y</em> power; <em>x</em><sup><em>y</em></sup>. Result is undefined if <em>x</em> &lt; 0. Result is undefined if <em>x</em> = 0 and <em>y</em> &le; 0.<br />\n<br />\n The operand <em>x</em> and <em>y</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is x raised to the y power; xy. Result is undefined if x &lt; 0. Result is undefined if x = 0 and y &le; 0.\n\n The operand x and y must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 26,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Exp",
          "OriginalName": "Exp",
          "Description": "Result is the natural exponentiation of <em>x</em>; <em>e</em><sup><em>x</em></sup>.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the natural exponentiation of x; ex.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 27,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Log",
          "OriginalName": "Log",
          "Description": "Result is the natural logarithm of <em>x</em>, i.e., the value <em>y</em> which satisfies the equation <em>x</em> = <em>e</em><sup><em>y</em></sup>.  Result is undefined if <em>x</em> &le; 0.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the natural logarithm of x, i.e., the value y which satisfies the equation x = ey.  Result is undefined if x &le; 0.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 28,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Exp2",
          "OriginalName": "Exp2",
          "Description": "Result is 2 raised to the <em>x</em> power; 2<sup><em>x</em></sup>.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is 2 raised to the x power; 2x.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 29,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Log2",
          "OriginalName": "Log2",
          "Description": "Result is the base-2 logarithm of <em>x</em>, i.e., the value <em>y</em> which satisfies the equation  <em>x</em> = 2<sup><em>y</em></sup>. Result is undefined if <em>x</em> &le; 0.<br />\n<br />\n The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the base-2 logarithm of x, i.e., the value y which satisfies the equation  x = 2y. Result is undefined if x &le; 0.\n\n The operand x must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 30,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Sqrt",
          "OriginalName": "Sqrt",
          "Description": "Result is the square root of <em>x</em>. Result is undefined if <em>x</em> &lt; 0.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the square root of x. Result is undefined if x &lt; 0.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 31,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "InverseSqrt",
          "OriginalName": "InverseSqrt",
          "Description": "Result is the reciprocal of <strong>sqrt</strong> <em>x</em>. Result is undefined if <em>x</em> &le; 0.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the reciprocal of sqrt x. Result is undefined if x &le; 0.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type. Results are computed per component.",
          "Number": 32,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Determinant",
          "OriginalName": "Determinant",
          "Description": "Result is the determinant of <em>x</em>.<br />\n<br />\nThe operand <em>x</em> must be a square matrix.<br />\n<br />\n<em>Result Type</em> must be the same type as the component type in the columns of <em>x</em>.",
          "DescriptionPlain": "Result is the determinant of x.\n\nThe operand x must be a square matrix.\n\nResult Type must be the same type as the component type in the columns of x.",
          "Number": 33,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "MatrixInverse",
          "OriginalName": "MatrixInverse",
          "Description": "Result is a matrix that is the inverse of <em>x</em>. The values in the result are undefined if <em>x</em> is singular or poorly conditioned (nearly singular).<br />\n<br />\nThe operand <em>x</em> must be a square matrix.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type.",
          "DescriptionPlain": "Result is a matrix that is the inverse of x. The values in the result are undefined if x is singular or poorly conditioned (nearly singular).\n\nThe operand x must be a square matrix.\n\n Result Type and the type of x must be the same type.",
          "Number": 34,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Modf",
          "OriginalName": "Modf",
          "Description": "Result is the fractional part of <em>x</em> and stores through <em>i</em> the whole number part (as a whole-number floating-point value). Both the result and the output parameter will have the same sign as <em>x</em>.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\nThe operand <em>i</em> must have a pointer type.<br />\n<br />\n<em>Result Type</em>, the type of <em>x</em>, and the type <em>i</em> points to must all be the same type Results are computed per component.",
          "DescriptionPlain": "Result is the fractional part of x and stores through i the whole number part (as a whole-number floating-point value). Both the result and the output parameter will have the same sign as x.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\nThe operand i must have a pointer type.\n\nResult Type, the type of x, and the type i points to must all be the same type Results are computed per component.",
          "Number": 35,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "i",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "ModfStruct",
          "OriginalName": "ModfStruct",
          "Description": "Same semantics as in <strong>Modf</strong>, except that the entire result is in the instruction&#8217;s result; there is not a pointer operand to write through.<br />\n<br />\n<em>Result Type</em> must be an <strong>OpTypeStruct</strong> with two members. Member 0 holds the fractional part. Member 1 holds the whole number part. These two members, and the <em>Result Type</em> must all have the same type. This structure type must be explicitly declared by the module.",
          "DescriptionPlain": "Same semantics as in Modf, except that the entire result is in the instruction&#8217;s result; there is not a pointer operand to write through.\n\nResult Type must be an OpTypeStruct with two members. Member 0 holds the fractional part. Member 1 holds the whole number part. These two members, and the Result Type must all have the same type. This structure type must be explicitly declared by the module.",
          "Number": 36,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FMin",
          "OriginalName": "FMin",
          "Description": "Result is <em>y</em> if <em>y</em> &lt; <em>x</em>; otherwise result is <em>x</em>. Which operand is the result is undefined if one of the operands is a NaN.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is y if y &lt; x; otherwise result is x. Which operand is the result is undefined if one of the operands is a NaN.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 37,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "UMin",
          "OriginalName": "UMin",
          "Description": "Result is <em>y</em> if <em>y</em> &lt; <em>x</em>; otherwise result is <em>x</em>, where <em>x</em> and <em>y</em> are interpreted as unsigned integers.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> and <em>y</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.",
          "DescriptionPlain": "Result is y if y &lt; x; otherwise result is x, where x and y are interpreted as unsigned integers.\n\n Result Type and the type of x and y must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.",
          "Number": 38,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "SMin",
          "OriginalName": "SMin",
          "Description": "Result is <em>y</em> if <em>y</em> &lt; <em>x</em>; otherwise result is <em>x</em>, where <em>x</em> and <em>y</em> are interpreted as signed integers.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> and <em>y</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.",
          "DescriptionPlain": "Result is y if y &lt; x; otherwise result is x, where x and y are interpreted as signed integers.\n\n Result Type and the type of x and y must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.",
          "Number": 39,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FMax",
          "OriginalName": "FMax",
          "Description": "Result is <em>y</em> if <em>x</em> &lt; <em>y</em>; otherwise result is <em>x</em>.  Which operand is the result is undefined if one of the operands is a NaN.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is y if x &lt; y; otherwise result is x.  Which operand is the result is undefined if one of the operands is a NaN.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 40,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "UMax",
          "OriginalName": "UMax",
          "Description": "Result is <em>y</em> if <em>x</em> &lt; <em>y</em>; otherwise result is <em>x</em>, where <em>x</em> and <em>y</em> are interpreted as unsigned integers.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> and <em>y</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.",
          "DescriptionPlain": "Result is y if x &lt; y; otherwise result is x, where x and y are interpreted as unsigned integers.\n\n Result Type and the type of x and y must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.",
          "Number": 41,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "SMax",
          "OriginalName": "SMax",
          "Description": "Result is <em>y</em> if <em>x</em> &lt; <em>y</em>; otherwise result is <em>x</em>, where <em>x</em> and <em>y</em> are interpreted as signed integers.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> and <em>y</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.",
          "DescriptionPlain": "Result is y if x &lt; y; otherwise result is x, where x and y are interpreted as signed integers.\n\n Result Type and the type of x and y must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.",
          "Number": 42,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FClamp",
          "OriginalName": "FClamp",
          "Description": "Result is min(max(<em>x</em>, <em>minVal</em>), <em>maxVal</em>). Result is undefined if <em>minVal</em> &gt; <em>maxVal</em>.The semantics used by min() and max() are those of FMin and FMax.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is min(max(x, minVal), maxVal). Result is undefined if minVal &gt; maxVal.The semantics used by min() and max() are those of FMin and FMax.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 43,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "minVal",
              "Type": "ID"
            },
            {
              "Name": "maxVal",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "UClamp",
          "OriginalName": "UClamp",
          "Description": "Result is min(max(<em>x</em>, <em>minVal</em>), <em>maxVal</em>),  where <em>x</em>, <em>minVal</em> and <em>maxVal</em> are interpreted as unsigned integers. Result is undefined if <em>minVal</em> &gt; <em>maxVal</em>.<br />\n<br />\n <em>Result Type</em> and the type of the operands must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.",
          "DescriptionPlain": "Result is min(max(x, minVal), maxVal),  where x, minVal and maxVal are interpreted as unsigned integers. Result is undefined if minVal &gt; maxVal.\n\n Result Type and the type of the operands must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.",
          "Number": 44,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "minVal",
              "Type": "ID"
            },
            {
              "Name": "maxVal",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "SClamp",
          "OriginalName": "SClamp",
          "Description": "Result is min(max(<em>x</em>, <em>minVal</em>), <em>maxVal</em>), where <em>x</em>, <em>minVal</em> and <em>maxVal</em> are interpreted as signed integers. Result is undefined if <em>minVal</em> &gt; <em>maxVal</em>.<br />\n<br />\n <em>Result Type</em> and the type of the operands must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.",
          "DescriptionPlain": "Result is min(max(x, minVal), maxVal), where x, minVal and maxVal are interpreted as signed integers. Result is undefined if minVal &gt; maxVal.\n\n Result Type and the type of the operands must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.",
          "Number": 45,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "minVal",
              "Type": "ID"
            },
            {
              "Name": "maxVal",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FMix",
          "OriginalName": "FMix",
          "Description": "Result is the linear blend of <em>x</em> and <em>y</em>, i.e., <em>x</em> * (1 - <em>a</em>) + <em>y</em> * <em>a</em>.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is the linear blend of x and y, i.e., x * (1 - a) + y * a.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 46,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            },
            {
              "Name": "a",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Step",
          "OriginalName": "Step",
          "Description": "Result is 0.0 if <em>x</em> &lt; <em>edge</em>; otherwise result is 1.0.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is 0.0 if x &lt; edge; otherwise result is 1.0.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 48,
          "Operands": [
            {
              "Name": "edge",
              "Type": "ID"
            },
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "SmoothStep",
          "OriginalName": "SmoothStep",
          "Description": "Result is 0.0 if <em>x</em> &le; <em>edge0</em> and 1.0 if <em>x</em> &ge; <em>edge1</em> and performs smooth Hermite interpolation between 0 and 1 when <em>edge0</em> &lt; <em>x</em> &lt; <em>edge1</em>. This is equivalent to:<br />\n<br />\n<em>t</em> * <em>t</em> * (3 - 2 * <em>t</em>), where <em>t</em> = clamp ((<em>x</em> - <em>edge0</em>) / (<em>edge1</em> - <em>edge0</em>), 0, 1)<br />\n<br />\nResult is undefined if <em>edge0</em> &ge; <em>edge1</em>.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is 0.0 if x &le; edge0 and 1.0 if x &ge; edge1 and performs smooth Hermite interpolation between 0 and 1 when edge0 &lt; x &lt; edge1. This is equivalent to:\n\nt * t * (3 - 2 * t), where t = clamp ((x - edge0) / (edge1 - edge0), 0, 1)\n\nResult is undefined if edge0 &ge; edge1.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 49,
          "Operands": [
            {
              "Name": "edge0",
              "Type": "ID"
            },
            {
              "Name": "edge1",
              "Type": "ID"
            },
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Fma",
          "OriginalName": "Fma",
          "Description": "Computes <em>a</em> * <em>b</em> + <em>c</em>. In uses where this operation is decorated with <strong>NoContraction</strong>:<br />\n<br />\n- <strong>fma</strong> is considered a single operation, whereas the expression <em>a</em> * <em>b</em> + <em>c</em> is considered two operations.<br />",
          "DescriptionPlain": "Computes a * b + c. In uses where this operation is decorated with NoContraction:\n\n- fma is considered a single operation, whereas the expression a * b + c is considered two operations.",
          "Number": 50,
          "Operands": [
            {
              "Name": "a",
              "Type": "ID"
            },
            {
              "Name": "b",
              "Type": "ID"
            },
            {
              "Name": "c",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Frexp",
          "OriginalName": "Frexp",
          "Description": "Splits <em>x</em> into a floating-point significand in the range [0.5, 1.0) and an integral exponent of two, such that:<br />",
          "DescriptionPlain": "Splits x into a floating-point significand in the range [0.5, 1.0) and an integral exponent of two, such that:",
          "Number": 51,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "exp",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FrexpStruct",
          "OriginalName": "FrexpStruct",
          "Description": "Same semantics as in <strong>Frexp</strong>, except that the entire result is in the instruction&#8217;s result; there is not a pointer operand to write through.<br />\n<br />\n<em>Result Type</em> must be an <strong>OpTypeStruct</strong> with two members.  Member 0 must have the same type as the type of <em>x</em>. Member 0 holds the <em>significand</em>. Member 1 must be a scalar or vector with integer component type, with 32-bit component width. Member 1 holds <em>exponent</em>. These two members must have the same number of components. This structure type must be explicitly declared by the module.",
          "DescriptionPlain": "Same semantics as in Frexp, except that the entire result is in the instruction&#8217;s result; there is not a pointer operand to write through.\n\nResult Type must be an OpTypeStruct with two members.  Member 0 must have the same type as the type of x. Member 0 holds the significand. Member 1 must be a scalar or vector with integer component type, with 32-bit component width. Member 1 holds exponent. These two members must have the same number of components. This structure type must be explicitly declared by the module.",
          "Number": 52,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Ldexp",
          "OriginalName": "Ldexp",
          "Description": "Builds a floating-point number from <em>x</em> and the corresponding integral exponent of two in <em>exp</em>:<br />",
          "DescriptionPlain": "Builds a floating-point number from x and the corresponding integral exponent of two in exp:",
          "Number": 53,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "exp",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "PackSnorm4x8",
          "OriginalName": "PackSnorm4x8",
          "Description": "First, converts each component of the normalized floating-point value <em>v</em> into 8-bit integer values. These are then packed into the result.<br />",
          "DescriptionPlain": "First, converts each component of the normalized floating-point value v into 8-bit integer values. These are then packed into the result.",
          "Number": 54,
          "Operands": [
            {
              "Name": "v",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "PackUnorm4x8",
          "OriginalName": "PackUnorm4x8",
          "Description": "First, converts each component of the normalized floating-point value <em>v</em> into 8-bit integer values. These are then packed into the result.<br />",
          "DescriptionPlain": "First, converts each component of the normalized floating-point value v into 8-bit integer values. These are then packed into the result.",
          "Number": 55,
          "Operands": [
            {
              "Name": "v",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "PackSnorm2x16",
          "OriginalName": "PackSnorm2x16",
          "Description": "First, converts each component of the normalized floating-point value <em>v</em> into 16-bit integer values. These are then packed into the result.<br />",
          "DescriptionPlain": "First, converts each component of the normalized floating-point value v into 16-bit integer values. These are then packed into the result.",
          "Number": 56,
          "Operands": [
            {
              "Name": "v",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "PackUnorm2x16",
          "OriginalName": "PackUnorm2x16",
          "Description": "First, converts each component of the normalized floating-point value <em>v</em> into 16-bit integer values. These are then packed into the result.<br />",
          "DescriptionPlain": "First, converts each component of the normalized floating-point value v into 16-bit integer values. These are then packed into the result.",
          "Number": 57,
          "Operands": [
            {
              "Name": "v",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "PackHalf2x16",
          "OriginalName": "PackHalf2x16",
          "Description": "Result is the unsigned integer obtained by converting the components of a two-component floating-point vector to the 16-bit <strong>OpTypeFloat</strong>, and then packing these two 16-bit integers into a 32-bit unsigned integer. The first vector component specifies the 16 least-significant bits of the result; the second component specifies the 16 most-significant bits.<br />\n<br />\nThe <em>v</em> operand must be a vector of 2 components whose type is a 32-bit floating-point.<br />\n<br />\n<em>Result Type</em> must be a 32-bit integer type.",
          "DescriptionPlain": "Result is the unsigned integer obtained by converting the components of a two-component floating-point vector to the 16-bit OpTypeFloat, and then packing these two 16-bit integers into a 32-bit unsigned integer. The first vector component specifies the 16 least-significant bits of the result; the second component specifies the 16 most-significant bits.\n\nThe v operand must be a vector of 2 components whose type is a 32-bit floating-point.\n\nResult Type must be a 32-bit integer type.",
          "Number": 58,
          "Operands": [
            {
              "Name": "v",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "PackDouble2x32",
          "OriginalName": "PackDouble2x32",
          "Description": "Result is the double-precision value obtained by packing the components of <em>v</em> into a 64-bit value. If an IEEE 754 Inf or NaN is created, it will not signal, and the resulting floating-point value is unspecified. Otherwise, the bit-level representation of <em>v</em> is preserved. The first vector component specifies the 32 least significant bits; the second component specifies the 32 most significant bits.<br />\n<br />\nThe <em>v</em> operand must be a vector of 2 components whose type is a 32-bit integer.<br />\n<br />\n<em>Result Type</em> must be a 64-bit floating-point scalar.<br />\n<br />\nUse of this instruction requires declaration of the <strong>Float64</strong> capability.",
          "DescriptionPlain": "Result is the double-precision value obtained by packing the components of v into a 64-bit value. If an IEEE 754 Inf or NaN is created, it will not signal, and the resulting floating-point value is unspecified. Otherwise, the bit-level representation of v is preserved. The first vector component specifies the 32 least significant bits; the second component specifies the 32 most significant bits.\n\nThe v operand must be a vector of 2 components whose type is a 32-bit integer.\n\nResult Type must be a 64-bit floating-point scalar.\n\nUse of this instruction requires declaration of the Float64 capability.",
          "Number": 59,
          "Operands": [
            {
              "Name": "v",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "UnpackSnorm2x16",
          "OriginalName": "UnpackSnorm2x16",
          "Description": "First, unpacks a single 32-bit unsigned integer <em>p</em> into a pair of 16-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value <em>f</em> to floating point is done as follows:<br />",
          "DescriptionPlain": "First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value f to floating point is done as follows:",
          "Number": 60,
          "Operands": [
            {
              "Name": "p",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "UnpackUnorm2x16",
          "OriginalName": "UnpackUnorm2x16",
          "Description": "First, unpacks a single 32-bit unsigned integer <em>p</em> into a pair of 16-bit unsigned integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value <em>f</em> to floating point is done as follows:<br />",
          "DescriptionPlain": "First, unpacks a single 32-bit unsigned integer p into a pair of 16-bit unsigned integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value f to floating point is done as follows:",
          "Number": 61,
          "Operands": [
            {
              "Name": "p",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "UnpackHalf2x16",
          "OriginalName": "UnpackHalf2x16",
          "Description": "Result is the two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values.<br />",
          "DescriptionPlain": "Result is the two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values.",
          "Number": 62,
          "Operands": [
            {
              "Name": "v",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "UnpackSnorm4x8",
          "OriginalName": "UnpackSnorm4x8",
          "Description": "First, unpacks a single 32-bit unsigned integer <em>p</em> into four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value <em>f</em> to floating point is done as follows:<br />",
          "DescriptionPlain": "First, unpacks a single 32-bit unsigned integer p into four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value f to floating point is done as follows:",
          "Number": 63,
          "Operands": [
            {
              "Name": "p",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "UnpackUnorm4x8",
          "OriginalName": "UnpackUnorm4x8",
          "Description": "First, unpacks a single 32-bit unsigned integer <em>p</em> into four 8-bit unsigned integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value <em>f</em> to floating point is done as follows:<br />",
          "DescriptionPlain": "First, unpacks a single 32-bit unsigned integer p into four 8-bit unsigned integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value f to floating point is done as follows:",
          "Number": 64,
          "Operands": [
            {
              "Name": "p",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "UnpackDouble2x32",
          "OriginalName": "UnpackDouble2x32",
          "Description": "Result is the two-component unsigned integer vector representation of <em>v</em>. The bit-level representation of <em>v</em> is preserved. The first component of the vector contains the 32 least significant bits of the double; the second component consists of the 32 most significant bits.<br />\n<br />\nThe <em>v</em> operand must be a scalar whose type is 64-bit floating point.<br />\n<br />\n<em>Result Type</em> must be a vector of 2 components whose type is a 32-bit integer.<br />\n<br />\nUse of this instruction requires declaration of the <strong>Float64</strong> capability.",
          "DescriptionPlain": "Result is the two-component unsigned integer vector representation of v. The bit-level representation of v is preserved. The first component of the vector contains the 32 least significant bits of the double; the second component consists of the 32 most significant bits.\n\nThe v operand must be a scalar whose type is 64-bit floating point.\n\nResult Type must be a vector of 2 components whose type is a 32-bit integer.\n\nUse of this instruction requires declaration of the Float64 capability.",
          "Number": 65,
          "Operands": [
            {
              "Name": "v",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Length",
          "OriginalName": "Length",
          "Description": "Result is the length of vector <em>x</em>, i.e., sqrt(<em>x</em> [0] <sup>2</sup> + <em>x</em> [1] <sup>2</sup> + &#8230;).<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n<em>Result Type</em> must be a scalar of the same type as the component type of <em>x</em>.",
          "DescriptionPlain": "Result is the length of vector x, i.e., sqrt(x [0] 2 + x [1] 2 + &#8230;).\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\nResult Type must be a scalar of the same type as the component type of x.",
          "Number": 66,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Distance",
          "OriginalName": "Distance",
          "Description": "Result is the distance between <em>p0</em> and <em>p1</em>, i.e., length(<em>p0</em> - <em>p1</em>).<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n<em>Result Type</em> must be a scalar of the same type as the component type of the operands.",
          "DescriptionPlain": "Result is the distance between p0 and p1, i.e., length(p0 - p1).\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\nResult Type must be a scalar of the same type as the component type of the operands.",
          "Number": 67,
          "Operands": [
            {
              "Name": "p0",
              "Type": "ID"
            },
            {
              "Name": "p1",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Cross",
          "OriginalName": "Cross",
          "Description": "Result is the cross product of <em>x</em> and <em>y</em>, i.e., the resulting components are, in order:<br />",
          "DescriptionPlain": "Result is the cross product of x and y, i.e., the resulting components are, in order:",
          "Number": 68,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Normalize",
          "OriginalName": "Normalize",
          "Description": "Result is the vector in the same direction as <em>x</em> but with a length of 1.<br />\n<br />\n The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of <em>x</em> must be the same type.",
          "DescriptionPlain": "Result is the vector in the same direction as x but with a length of 1.\n\n The operand x must be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of x must be the same type.",
          "Number": 69,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FaceForward",
          "OriginalName": "FaceForward",
          "Description": "If the dot product of <em>Nref</em> and <em>I</em> is negative, the result is <em>N</em>, otherwise it is <em>-N</em>.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type.",
          "DescriptionPlain": "If the dot product of Nref and I is negative, the result is N, otherwise it is -N.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type.",
          "Number": 70,
          "Operands": [
            {
              "Name": "N",
              "Type": "ID"
            },
            {
              "Name": "I",
              "Type": "ID"
            },
            {
              "Name": "Nref",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Reflect",
          "OriginalName": "Reflect",
          "Description": "For the incident vector <em>I</em> and surface orientation <em>N</em>, the result is the reflection direction:<br />",
          "DescriptionPlain": "For the incident vector I and surface orientation N, the result is the reflection direction:",
          "Number": 71,
          "Operands": [
            {
              "Name": "I",
              "Type": "ID"
            },
            {
              "Name": "N",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "Refract",
          "OriginalName": "Refract",
          "Description": "For the incident vector <em>I</em> and surface normal <em>N</em>, and the ratio of indices of refraction <em>eta</em>, the result is the refraction vector. The result is computed by<br />",
          "DescriptionPlain": "For the incident vector I and surface normal N, and the ratio of indices of refraction eta, the result is the refraction vector. The result is computed by",
          "Number": 72,
          "Operands": [
            {
              "Name": "I",
              "Type": "ID"
            },
            {
              "Name": "N",
              "Type": "ID"
            },
            {
              "Name": "eta",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FindILsb",
          "OriginalName": "FindILsb",
          "Description": "Integer least-significant bit.<br />\n<br />\nResults in the bit number of the least-significant 1-bit in the binary representation of <em>Value</em>. If <em>Value</em> is 0, the result is -1.<br />\n<br />\n <em>Result Type</em> and the type of <em>Value</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.",
          "DescriptionPlain": "Integer least-significant bit.\n\nResults in the bit number of the least-significant 1-bit in the binary representation of Value. If Value is 0, the result is -1.\n\n Result Type and the type of Value must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.",
          "Number": 73,
          "Operands": [
            {
              "Name": "Value",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FindSMsb",
          "OriginalName": "FindSMsb",
          "Description": "Signed-integer most-significant bit, with <em>Value</em> interpreted as a signed integer.<br />\n<br />\nFor positive numbers, the result will be the bit number of the most significant 1-bit. For negative numbers, the result will be the bit number of the most significant 0-bit. For a <em>Value</em> of 0 or -1, the result is -1.<br />\n<br />\n <em>Result Type</em> and the type of <em>Value</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.<br />\n<br />\nThis instruction is currently limited to 32-bit width components.",
          "DescriptionPlain": "Signed-integer most-significant bit, with Value interpreted as a signed integer.\n\nFor positive numbers, the result will be the bit number of the most significant 1-bit. For negative numbers, the result will be the bit number of the most significant 0-bit. For a Value of 0 or -1, the result is -1.\n\n Result Type and the type of Value must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.\n\nThis instruction is currently limited to 32-bit width components.",
          "Number": 74,
          "Operands": [
            {
              "Name": "Value",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "FindUMsb",
          "OriginalName": "FindUMsb",
          "Description": "Unsigned-integer most-significant bit.<br />\n<br />\nResults in the bit number of the most-significant 1-bit in the binary representation of <em>Value</em>. If <em>Value</em> is 0, the result is -1.<br />\n<br />\n <em>Result Type</em> and the type of <em>Value</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.<br />\n<br />\nThis instruction is currently limited to 32-bit width components.",
          "DescriptionPlain": "Unsigned-integer most-significant bit.\n\nResults in the bit number of the most-significant 1-bit in the binary representation of Value. If Value is 0, the result is -1.\n\n Result Type and the type of Value must both be integer scalar or integer vector types. Result Type and operand types must have the same number of components with the same component width. Results are computed per component.\n\nThis instruction is currently limited to 32-bit width components.",
          "Number": 75,
          "Operands": [
            {
              "Name": "Value",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "InterpolateAtCentroid",
          "OriginalName": "InterpolateAtCentroid",
          "Description": "Result is the value of the input <em>interpolant</em> sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the same value assigned to the input variable if it were decorated as <strong>Centroid</strong>.<br />\n<br />\n The operand <em>interpolant</em> must be a pointer to the <strong>Input</strong> Storage Class.<br />\n<br />\n The operand <em>interpolant</em> must be a pointer to a scalar or vector whose component type is 32-bit floating-point.<br />\n<br />\n This instruction is only valid in the <strong>Fragment</strong> execution model.<br />\n<br />\n <em>Result Type</em> and the type of <em>interpolant</em> must be the same type.<br />\n<br />\nUse of this instruction requires declaration of the <strong>InterpolationFunction</strong> capability.",
          "DescriptionPlain": "Result is the value of the input interpolant sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the same value assigned to the input variable if it were decorated as Centroid.\n\n The operand interpolant must be a pointer to the Input Storage Class.\n\n The operand interpolant must be a pointer to a scalar or vector whose component type is 32-bit floating-point.\n\n This instruction is only valid in the Fragment execution model.\n\n Result Type and the type of interpolant must be the same type.\n\nUse of this instruction requires declaration of the InterpolationFunction capability.",
          "Number": 76,
          "Operands": [
            {
              "Name": "interpolant",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "InterpolateAtSample",
          "OriginalName": "InterpolateAtSample",
          "Description": "Result is the value of the input <em>interpolant</em> variable at the location of sample number <em>sample</em>. If multisample buffers are not available, the input variable will be evaluated at the center of the pixel. If sample <em>sample</em> does not exist, the position used to interpolate the input variable is undefined.<br />\n<br />\n The operand <em>interpolant</em> must be a pointer to the <strong>Input</strong> Storage Class.<br />\n<br />\n The operand <em>interpolant</em> must be a pointer to a scalar or vector whose component type is 32-bit floating-point.<br />\n<br />\n This instruction is only valid in the <strong>Fragment</strong> execution model.<br />\n<br />\nThe <em>sample</em> operand must be a scalar 32-bit integer.<br />\n<br />\n <em>Result Type</em> and the type of <em>interpolant</em> must be the same type.<br />\n<br />\nUse of this instruction requires declaration of the <strong>InterpolationFunction</strong> capability.",
          "DescriptionPlain": "Result is the value of the input interpolant variable at the location of sample number sample. If multisample buffers are not available, the input variable will be evaluated at the center of the pixel. If sample sample does not exist, the position used to interpolate the input variable is undefined.\n\n The operand interpolant must be a pointer to the Input Storage Class.\n\n The operand interpolant must be a pointer to a scalar or vector whose component type is 32-bit floating-point.\n\n This instruction is only valid in the Fragment execution model.\n\nThe sample operand must be a scalar 32-bit integer.\n\n Result Type and the type of interpolant must be the same type.\n\nUse of this instruction requires declaration of the InterpolationFunction capability.",
          "Number": 77,
          "Operands": [
            {
              "Name": "interpolant",
              "Type": "ID"
            },
            {
              "Name": "sample",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "InterpolateAtOffset",
          "OriginalName": "InterpolateAtOffset",
          "Description": "Result is the value of the input <em>interpolant</em> variable sampled at an offset from the center of the pixel specified by <em>offset</em>. The two floating-point components of <em>offset</em>, give the offset in pixels in the <em>x</em> and <em>y</em> directions, respectively. An <em>offset</em> of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported are implementation-dependent.<br />\n<br />\n The operand <em>interpolant</em> must be a pointer to the <strong>Input</strong> Storage Class.<br />\n<br />\n The operand <em>interpolant</em> must be a pointer to a scalar or vector whose component type is 32-bit floating-point.<br />\n<br />\n This instruction is only valid in the <strong>Fragment</strong> execution model.<br />\n<br />\nThe <em>offset</em> operand must be a vector of 2 components of 32-bit floating-point type.<br />\n<br />\n <em>Result Type</em> and the type of <em>interpolant</em> must be the same type.<br />\n<br />\nUse of this instruction requires declaration of the <strong>InterpolationFunction</strong> capability.",
          "DescriptionPlain": "Result is the value of the input interpolant variable sampled at an offset from the center of the pixel specified by offset. The two floating-point components of offset, give the offset in pixels in the x and y directions, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported are implementation-dependent.\n\n The operand interpolant must be a pointer to the Input Storage Class.\n\n The operand interpolant must be a pointer to a scalar or vector whose component type is 32-bit floating-point.\n\n This instruction is only valid in the Fragment execution model.\n\nThe offset operand must be a vector of 2 components of 32-bit floating-point type.\n\n Result Type and the type of interpolant must be the same type.\n\nUse of this instruction requires declaration of the InterpolationFunction capability.",
          "Number": 78,
          "Operands": [
            {
              "Name": "interpolant",
              "Type": "ID"
            },
            {
              "Name": "offset",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "NMin",
          "OriginalName": "NMin",
          "Description": "Result is <em>y</em> if <em>y</em> &lt; <em>x</em>; otherwise result is <em>x</em>. If one operand is a NaN, the other operand is the result. If both operands are NaN, the result is a NaN.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is y if y &lt; x; otherwise result is x. If one operand is a NaN, the other operand is the result. If both operands are NaN, the result is a NaN.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 79,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "NMax",
          "OriginalName": "NMax",
          "Description": "Result is <em>y</em> if <em>x</em> &lt; <em>y</em>; otherwise result is <em>x</em>.  If one operand is a NaN, the other operand is the result. If both operands are NaN, the result is a NaN.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is y if x &lt; y; otherwise result is x.  If one operand is a NaN, the other operand is the result. If both operands are NaN, the result is a NaN.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 80,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "y",
              "Type": "ID"
            }
          ]
        },
        {
          "Name": "NClamp",
          "OriginalName": "NClamp",
          "Description": "Result is min(max(<em>x</em>, <em>minVal</em>), <em>maxVal</em>). Result is undefined if <em>minVal</em> &gt; <em>maxVal</em>.The semantics used by min() and max() are those of NMin and NMax.<br />\n<br />\n The operands must all be a scalar or vector whose component type is floating-point.<br />\n<br />\n <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.",
          "DescriptionPlain": "Result is min(max(x, minVal), maxVal). Result is undefined if minVal &gt; maxVal.The semantics used by min() and max() are those of NMin and NMax.\n\n The operands must all be a scalar or vector whose component type is floating-point.\n\n Result Type and the type of all operands must be the same type. Results are computed per component.",
          "Number": 81,
          "Operands": [
            {
              "Name": "x",
              "Type": "ID"
            },
            {
              "Name": "minVal",
              "Type": "ID"
            },
            {
              "Name": "maxVal",
              "Type": "ID"
            }
          ]
        }
      ]
    },
    {
      "Metadata": {
        "Language": "Open CL",
        "Version": 1.2,
        "Title": "OpenCL 1.2 Extended Instruction Set Specification (Provisional)",
        "Author": "Boaz Ouriel, Intel",
        "Revnumber": "version 0.99, revision 30",
        "LastUpdate": "Last updated 2015-04-02 11:22:21 MDT"
      },
      "ExtendedInstructions": [
        {
          "Name": "Acos",
          "OriginalName": "acos",
          "Description": "Compute the arc cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 0,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Acosh",
          "OriginalName": "acosh",
          "Description": "Compute the inverse hyperbolic cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the inverse hyperbolic cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 1,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Acospi",
          "OriginalName": "acospi",
          "Description": "Compute <em>acos</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute acos(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 2,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Asin",
          "OriginalName": "asin",
          "Description": "Compute the arc sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 3,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Asinh",
          "OriginalName": "asinh",
          "Description": "Compute the inverse hyperbolic sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the inverse hyperbolic sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 4,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Asinpi",
          "OriginalName": "asinpi",
          "Description": "Compute <em>asin</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute asin(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 5,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atan",
          "OriginalName": "atan",
          "Description": "Compute the arc tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 6,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atan2",
          "OriginalName": "atan2",
          "Description": "Compute the arc tangent of <em>y</em> / <em>x</em>.\n<br />\n<em>Result Type</em>,<em>y</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc tangent of y / x.\n\nResult Type,y and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 7,
          "Operands": [
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atanh",
          "OriginalName": "atanh",
          "Description": "Compute the hyperbolic arc tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the hyperbolic arc tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 8,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atanpi",
          "OriginalName": "atanpi",
          "Description": "Compute <em>atan</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute atan(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 9,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atan2pi",
          "OriginalName": "atan2pi",
          "Description": "Compute <em>atan2</em>(<em>y</em>, <em>x</em>) / &#960;.\n<br />\n<em>Result Type</em>,<em>y</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute atan2(y, x) / &#960;.\n\nResult Type,y and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 10,
          "Operands": [
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cbrt",
          "OriginalName": "cbrt",
          "Description": "Compute the cube-root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the cube-root of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 11,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ceil",
          "OriginalName": "ceil",
          "Description": "Round <em>x</em> to integral value using the round to positive infinity rounding mode.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to integral value using the round to positive infinity rounding mode.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 12,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Copysign",
          "OriginalName": "copysign",
          "Description": "Returns <em>x</em> with its sign changed to match the sign of <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns x with its sign changed to match the sign of y.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 13,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cos",
          "OriginalName": "cos",
          "Description": "Compute the cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 14,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cosh",
          "OriginalName": "cosh",
          "Description": "Compute the hyperbolic cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the hyperbolic cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 15,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cospi",
          "OriginalName": "cospi",
          "Description": "Compute <em>cos</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute cos(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 16,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Erfc",
          "OriginalName": "erfc",
          "Description": "Complementary error function of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Complementary error function of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 17,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Erf",
          "OriginalName": "erf",
          "Description": "Error function of <em>x</em> encountered in integrating the normal distribution.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Error function of x encountered in integrating the normal distribution.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 18,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Exp",
          "OriginalName": "exp",
          "Description": "Compute the base-e exponential of <em>x</em>. (i.e. <em>e</em><sup><em>x</em></sup>)\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the base-e exponential of x. (i.e. ex)\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 19,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Exp2",
          "OriginalName": "exp2",
          "Description": "Computes 2 raised to the power of <em>x</em>. (i.e. <em>2</em><sup><em>x</em></sup>)\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes 2 raised to the power of x. (i.e. 2x)\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 20,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Exp10",
          "OriginalName": "exp10",
          "Description": "Computes 10 raised to the power of <em>x</em>. (i.e. <em>10</em><sup><em>x</em></sup>)\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes 10 raised to the power of x. (i.e. 10x)\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 21,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Expm1",
          "OriginalName": "expm1",
          "Description": "Computes <em>e</em><sup><em>x</em></sup> <em>- 1.0</em> .\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes ex - 1.0 .\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 22,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fabs",
          "OriginalName": "fabs",
          "Description": "Compute the absolute value of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the absolute value of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 23,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fdim",
          "OriginalName": "fdim",
          "Description": "Compute <em>x - y</em> if <em>x &gt; y</em>, <em>+0</em> if <em>x</em> is less than or equal to <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute x - y if x &gt; y, +0 if x is less than or equal to y.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 24,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Floor",
          "OriginalName": "floor",
          "Description": "Round <em>x</em> to the integral value using the round to negative infinity rounding mode.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to the integral value using the round to negative infinity rounding mode.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 25,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fma",
          "OriginalName": "fma",
          "Description": "Compute the correctly rounded floating-point representation of the sum of <em>c</em> with the infinitely precise product of <em>a</em> and <em>b</em>.Rounding of intermediate products shall not occur. Edge case behavior is per the IEEE 754-2008 standard.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the correctly rounded floating-point representation of the sum of c with the infinitely precise product of a and b.Rounding of intermediate products shall not occur. Edge case behavior is per the IEEE 754-2008 standard.\n\nResult Type,a,b and c must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 26,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmax",
          "OriginalName": "fmax",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>. If one argument is a NaN, <em>Fmax</em> returns the other argument.  If both arguments are NaNs, <em>Fmax</em> returns a NaN.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> fmax behave as defined by C99 and may not match the IEEE 754-2008 definition for maxNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x. If one argument is a NaN, Fmax returns the other argument.  If both arguments are NaNs, Fmax returns a NaN.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: fmax behave as defined by C99 and may not match the IEEE 754-2008 definition for maxNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "Category": "MathExtendedInstructions",
          "Number": 27,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmin",
          "OriginalName": "fmin",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>. If one argument is a NaN, <em>Fmin</em> returns the other argument.  If both arguments are NaNs, <em>Fmin</em> returns a NaN.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> fmin behave as defined by C99 and may not match the IEEE 754-2008 definition for minNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x. If one argument is a NaN, Fmin returns the other argument.  If both arguments are NaNs, Fmin returns a NaN.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: fmin behave as defined by C99 and may not match the IEEE 754-2008 definition for minNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "Category": "MathExtendedInstructions",
          "Number": 28,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmod",
          "OriginalName": "fmod",
          "Description": "Modulus. Returns <em>x</em> - <em>y</em> * <em>trunc</em> (<em>x</em>/<em>y</em>).\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Modulus. Returns x - y * trunc (x/y).\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 29,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fract",
          "OriginalName": "fract",
          "Description": "Returns <em>fmin</em>( <em>x</em> - <em>floor</em>(<em>x</em>), 0x1.fffffep-1f. <em>floor</em>(<em>x</em>) is returned in <em>ptr</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>ptr</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type, or must be a pointer to the same type.<br />",
          "DescriptionPlain": "Returns fmin( x - floor(x), 0x1.fffffep-1f. floor(x) is returned in ptr.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nptr must be a pointer(global, local, private) to floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type, or must be a pointer to the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 30,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "ptr",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Frexp",
          "OriginalName": "frexp",
          "Description": "Extract the mantissa and exponent from <em>x</em>. The <em>Result Type</em> holds the mantissa, and <em>exp</em> points to the exponent. For each component the mantissa returned is a <em>floating-point</em> with magnitude in the interval [1/2, 1) or 0.  Each component of <em>x</em> equals mantissa returned * 2<sup>exp</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>exp</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>exp</em> operand must point to an <em>i32</em> with the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Extract the mantissa and exponent from x. The Result Type holds the mantissa, and exp points to the exponent. For each component the mantissa returned is a floating-point with magnitude in the interval [1/2, 1) or 0.  Each component of x equals mantissa returned * 2exp.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nexp must be a pointer(global, local, private) to i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x operands must be of the same type. exp operand must point to an i32 with the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 31,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "exp",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Hypot",
          "OriginalName": "hypot",
          "Description": "Compute the value of the square root of <em>x</em><sup>2</sup>+ <em>y</em><sup>2</sup> without undue overflow or underflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the value of the square root of x2+ y2 without undue overflow or underflow.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 32,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ilogb",
          "OriginalName": "ilogb",
          "Description": "Return the exponent of <em>x</em> as an <em>i32</em> value.\n<br />\n<em>Result Type</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must have the same component count.<br />",
          "DescriptionPlain": "Return the exponent of x as an i32 value.\n\nResult Type must be i32 or vector(2,3,4,8,16) of i32 values. \nx must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must have the same component count.",
          "Category": "MathExtendedInstructions",
          "Number": 33,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ldexp",
          "OriginalName": "ldexp",
          "Description": "Multiply <em>x</em> by 2 to the power <em>k</em>.\n<br />\n<em>k</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>exp</em> operand must have the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Multiply x by 2 to the power k.\n\nk must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must be of the same type. exp operand must have the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 34,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "k",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Lgamma",
          "OriginalName": "lgamma",
          "Description": "Log gamma function of <em>x</em>. Returns the natural logarithm of the absolute value of the gamma function.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Log gamma function of x. Returns the natural logarithm of the absolute value of the gamma function.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 35,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Lgamma_r",
          "OriginalName": "lgamma_r",
          "Description": "Log gamma function of <em>x</em>. Returns the natural logarithm of the absolute value of the gamma function. The sign of the gamma function is returned in the <em>signp</em> operand\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>singp</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>singp</em> operand must point to an <em>i32</em> with the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Log gamma function of x. Returns the natural logarithm of the absolute value of the gamma function. The sign of the gamma function is returned in the signp operand\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nsingp must be a pointer(global, local, private) to i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x operands must be of the same type. singp operand must point to an i32 with the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 36,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "singp",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log",
          "OriginalName": "log",
          "Description": "Compute natural logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute natural logarithm of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 37,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log2",
          "OriginalName": "log2",
          "Description": "Compute a base 2 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute a base 2 logarithm of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 38,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log10",
          "OriginalName": "log10",
          "Description": "Compute a base 10 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute a base 10 logarithm of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 39,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log1p",
          "OriginalName": "log1p",
          "Description": "Compute log<sub>e</sub>(1.0 + <em>x</em>).\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute loge(1.0 + x).\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 40,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Logb",
          "OriginalName": "logb",
          "Description": "Compute the exponent of <em>x</em>, which is the integral part of log<sub>r</sub>  | <em>x</em> |.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the exponent of x, which is the integral part of logr  | x |.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 41,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Mad",
          "OriginalName": "mad",
          "Description": "mad approximates <em>a</em> * <em>b</em> + <em>c</em>. Whether or how the product of <em>a</em> * <em>b</em> is rounded and how supernormal or subnormal intermediate products are handled is not defined.  mad is intended to be used where speed is preferred over accuracy\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> For some usages, e.g.mad(<em>a</em>, <em>b</em>, -<em>a</em>*<em>b</em>), the definition of mad() is loose enough that almost any result is allowed from mad() for some values of <em>a</em> and <em>b</em>.",
          "DescriptionPlain": "mad approximates a * b + c. Whether or how the product of a * b is rounded and how supernormal or subnormal intermediate products are handled is not defined.  mad is intended to be used where speed is preferred over accuracy\n\nResult Type,a,b and c must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: For some usages, e.g.mad(a, b, -a*b), the definition of mad() is loose enough that almost any result is allowed from mad() for some values of a and b.",
          "Category": "MathExtendedInstructions",
          "Number": 42,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Maxmag",
          "OriginalName": "maxmag",
          "Description": "Returns <em>x</em> if | <em>x</em> | &gt; | <em>y</em> | , <em>y</em> if | <em>y</em> | &gt; | <em>x</em> | , otherwise <em>fmax</em>(<em>x</em>, <em>y</em>).\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns x if | x | &gt; | y | , y if | y | &gt; | x | , otherwise fmax(x, y).\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 43,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Minmag",
          "OriginalName": "minmag",
          "Description": "Returns <em>x</em> if | <em>x</em> | &lt; | <em>y</em> |, <em>y</em> if | <em>y</em> | &lt; | <em>x</em> |, otherwise <em>fmin</em>(<em>x</em>, <em>y</em>).\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns x if | x | &lt; | y |, y if | y | &lt; | x |, otherwise fmin(x, y).\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 44,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Modf",
          "OriginalName": "modf",
          "Description": "Decompose a <em>floating-point</em> number. The modf function breaks the argument <em>x</em> into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part in the object pointed to by <em>iptr</em>\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>iptr</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type, or must be a pointer to the same type.<br />",
          "DescriptionPlain": "Decompose a floating-point number. The modf function breaks the argument x into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part in the object pointed to by iptr\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \niptr must be a pointer(global, local, private) to floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type, or must be a pointer to the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 45,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "iptr",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Nan",
          "OriginalName": "nan",
          "Description": "Returns a quiet NaN. The <em>nancode</em> may be placed in the significand of the resulting NaN.\n<br />\n<em>nancode</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>nancode</em> operands must have the same component count.<br />",
          "DescriptionPlain": "Returns a quiet NaN. The nancode may be placed in the significand of the resulting NaN.\n\nnancode must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and nancode operands must have the same component count.",
          "Category": "MathExtendedInstructions",
          "Number": 46,
          "Operands": [
            {
              "Name": "nancode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Nextafter",
          "OriginalName": "nextafter",
          "Description": "Computes the next representable <em>floating-point</em> value following <em>x</em> in the direction of <em>y</em>. Thus, if <em>y</em> is less than <em>x</em>, <em>nextafter</em>() returns the largest representable floating-point number less than <em>x</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes the next representable floating-point value following x in the direction of y. Thus, if y is less than x, nextafter() returns the largest representable floating-point number less than x.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 47,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Pow",
          "OriginalName": "pow",
          "Description": "Compute <em>x</em> to the power <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute x to the power y.\n\nResult Type,x,y and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 48,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Pown",
          "OriginalName": "pown",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>y</em> is an <em>i32</em> integer.\n<br />\n<em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>y</em> operand must have the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Compute x to the power y, where y is an i32 integer.\n\ny must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must be of the same type. y operand must have the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 49,
          "Operands": [
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Powr",
          "OriginalName": "powr",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>y</em> is an integer.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute x to the power y, where y is an integer.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 50,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Remainder",
          "OriginalName": "remainder",
          "Description": "Compute the value r such that r = <em>x</em> - n*<em>y</em>, where n is the integer nearest the exact value of <em>x</em>/<em>y</em>. If there are two integers closest to <em>x</em>/<em>y</em>, n shall be the even one. If r is zero, it is given the same sign as <em>x</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the value r such that r = x - n*y, where n is the integer nearest the exact value of x/y. If there are two integers closest to x/y, n shall be the even one. If r is zero, it is given the same sign as x.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 51,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Remquo",
          "OriginalName": "remquo",
          "Description": "The remquo function computes the value r such that r = <em>x</em> - k*<em>y</em>, where k is the integer nearest the exact value of <em>x</em>/<em>y</em>.  If there are two integers closest to <em>x</em>/<em>y</em>, k shall be the even one. If r is zero, it is given the same sign as <em>x</em>.  This is the same value that is returned by the <em>remainder</em> function. remquo also calculates the lower seven bits of the integral quotient <em>x</em>/<em>y</em>, and gives that value the same sign as <em>x</em>/<em>y</em>. It stores this signed value in the object pointed to by <em>quo</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>quo</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em>, <em>x</em> and <em>y</em> operands must be of the same type. <em>quo</em> operand must point to an <em>i32</em> with the same component count as <em>Result Type</em>, <em>x</em> and <em>y</em> operands.<br />",
          "DescriptionPlain": "The remquo function computes the value r such that r = x - k*y, where k is the integer nearest the exact value of x/y.  If there are two integers closest to x/y, k shall be the even one. If r is zero, it is given the same sign as x.  This is the same value that is returned by the remainder function. remquo also calculates the lower seven bits of the integral quotient x/y, and gives that value the same sign as x/y. It stores this signed value in the object pointed to by quo.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nquo must be a pointer(global, local, private) to i32 or vector(2,3,4,8,16) of i32 values. \nResult Type, x and y operands must be of the same type. quo operand must point to an i32 with the same component count as Result Type, x and y operands.",
          "Category": "MathExtendedInstructions",
          "Number": 52,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "quo",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rint",
          "OriginalName": "rint",
          "Description": "Round <em>x</em> to integral value (using round to nearest even rounding mode) in floating-point format.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to integral value (using round to nearest even rounding mode) in floating-point format.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 53,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rootn",
          "OriginalName": "rootn",
          "Description": "Compute <em>x</em> to the power 1/<em>y</em>.\n<br />\n<em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>y</em> operand must have the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Compute x to the power 1/y.\n\ny must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must be of the same type. y operand must have the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 54,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Round",
          "OriginalName": "round",
          "Description": "Return the integral value nearest to <em>x</em> rounding halfway cases away from zero, regardless of the current rounding direction.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Return the integral value nearest to x rounding halfway cases away from zero, regardless of the current rounding direction.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 55,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rsqrt",
          "OriginalName": "rsqrt",
          "Description": "Compute inverse square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute inverse square root of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 56,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sin",
          "OriginalName": "sin",
          "Description": "Compute sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 57,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sincos",
          "OriginalName": "sincos",
          "Description": "Compute sine and cosine of <em>x</em>. The computed sine is the return value and computed cosine is returned in <em>cosval</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>cosval</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type, or must be a pointer to the same type.<br />",
          "DescriptionPlain": "Compute sine and cosine of x. The computed sine is the return value and computed cosine is returned in cosval.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \ncosval must be a pointer(global, local, private) to floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type, or must be a pointer to the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 58,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "cosval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sinh",
          "OriginalName": "sinh",
          "Description": "Compute hyperbolic sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute hyperbolic sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 59,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sinpi",
          "OriginalName": "sinpi",
          "Description": "Compute <em>sin</em> (&#960; x).\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute sin (&#960; x).\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 60,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sqrt",
          "OriginalName": "sqrt",
          "Description": "Compute square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute square root of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 61,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tan",
          "OriginalName": "tan",
          "Description": "Compute tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 62,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tanh",
          "OriginalName": "tanh",
          "Description": "Compute hyperbolic tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute hyperbolic tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 63,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tanpi",
          "OriginalName": "tanpi",
          "Description": "Compute <em>tan</em> (&#960; x).\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute tan (&#960; x).\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 64,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tgamma",
          "OriginalName": "tgamma",
          "Description": "Compute the gamma function of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the gamma function of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 65,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Trunc",
          "OriginalName": "trunc",
          "Description": "Round <em>x</em> to integral value using the round to zero rounding mode.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to integral value using the round to zero rounding mode.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 66,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_cos",
          "OriginalName": "half_cos",
          "Description": "Compute cosine of <em>x</em>, where <em>x</em> must be in the range -2<sup>16</sup> &#8230; +2<sup>16</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute cosine of x, where x must be in the range -216 &#8230; +216.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 67,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_divide",
          "OriginalName": "half_divide",
          "Description": "Compute <em>x</em> / <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute x / y.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 68,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_exp",
          "OriginalName": "half_exp",
          "Description": "Compute the base-e exponential of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the base-e exponential of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 69,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_exp2",
          "OriginalName": "half_exp2",
          "Description": "Compute the base- 2 exponential of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the base- 2 exponential of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 70,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_exp10",
          "OriginalName": "half_exp10",
          "Description": "Compute the base- 10 exponential of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the base- 10 exponential of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 71,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_log",
          "OriginalName": "half_log",
          "Description": "Compute natural logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute natural logarithm of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 72,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_log2",
          "OriginalName": "half_log2",
          "Description": "Compute a base 2 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute a base 2 logarithm of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 73,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_log10",
          "OriginalName": "half_log10",
          "Description": "Compute a base 10 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute a base 10 logarithm of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 74,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_powr",
          "OriginalName": "half_powr",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>x</em> is &gt;= 0.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute x to the power y, where x is &gt;= 0.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 75,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_recip",
          "OriginalName": "half_recip",
          "Description": "Compute reciprocal of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute reciprocal of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 76,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_rsqrt",
          "OriginalName": "half_rsqrt",
          "Description": "Compute inverse square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute inverse square root of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 77,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_sin",
          "OriginalName": "half_sin",
          "Description": "Compute sine of <em>x</em>, where <em>x</em> must be in the range -2<sup>16</sup> &#8230; +2<sup>16</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute sine of x, where x must be in the range -216 &#8230; +216.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 78,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_sqrt",
          "OriginalName": "half_sqrt",
          "Description": "Compute the square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the square root of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 79,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_tan",
          "OriginalName": "half_tan",
          "Description": "Compute tangent value of <em>x</em>, where <em>x</em> must be in the range -2<sup>16</sup> &#8230; +2<sup>16</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute tangent value of x, where x must be in the range -216 &#8230; +216.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 80,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_cos",
          "OriginalName": "native_cos",
          "Description": "Compute cosine of <em>x</em> over an implementation-defined range. The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute cosine of x over an implementation-defined range. The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 81,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_divide",
          "OriginalName": "native_divide",
          "Description": "Compute <em>x</em> / <em>y</em> over an implementation-defined range. The maximum error is implementation-defined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute x / y over an implementation-defined range. The maximum error is implementation-defined.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 82,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_exp",
          "OriginalName": "native_exp",
          "Description": "Compute the base-e exponential of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the base-e exponential of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 83,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_exp2",
          "OriginalName": "native_exp2",
          "Description": "Compute the base- 2 exponential of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined..\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the base- 2 exponential of x over an implementation-defined range.  The maximum error is implementation-defined..\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 84,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_exp10",
          "OriginalName": "native_exp10",
          "Description": "Compute the base- 10 exponential of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined..\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the base- 10 exponential of x over an implementation-defined range.  The maximum error is implementation-defined..\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 85,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_log",
          "OriginalName": "native_log",
          "Description": "Compute natural logarithm of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute natural logarithm of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 86,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_log2",
          "OriginalName": "native_log2",
          "Description": "Compute a base 2 logarithm of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute a base 2 logarithm of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 87,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_log10",
          "OriginalName": "native_log10",
          "Description": "Compute a base 10 logarithm of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute a base 10 logarithm of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 88,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_powr",
          "OriginalName": "native_powr",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>x</em> is &gt;= 0.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute x to the power y, where x is &gt;= 0.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 89,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_recip",
          "OriginalName": "native_recip",
          "Description": "Compute reciprocal of <em>x</em> over an implementation-defined range. The range of x and y are implementation-defined. The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute reciprocal of x over an implementation-defined range. The range of x and y are implementation-defined. The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 90,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_rsqrt",
          "OriginalName": "native_rsqrt",
          "Description": "Compute inverse square root of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute inverse square root of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 91,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_sin",
          "OriginalName": "native_sin",
          "Description": "Compute sine of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute sine of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 92,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_sqrt",
          "OriginalName": "native_sqrt",
          "Description": "Compute the square root of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the square root of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 93,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_tan",
          "OriginalName": "native_tan",
          "Description": "Compute tangent value of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute tangent value of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 94,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_abs",
          "OriginalName": "s_abs",
          "Description": "Returns |<em>x</em>|, where <em>x</em> is treated as signed integer.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns |x|, where x is treated as signed integer.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 141,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_abs_diff",
          "OriginalName": "s_abs_diff",
          "Description": "Returns | <em>x</em> - <em>y</em> | without modulo overflow, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns | x - y | without modulo overflow, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 142,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_add_sat",
          "OriginalName": "s_add_sat",
          "Description": "Returns the saturated value of <em>x</em> + <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x + y, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 143,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_add_sat",
          "OriginalName": "u_add_sat",
          "Description": "Returns the saturated value of <em>x</em> + <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x + y, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 144,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_hadd",
          "OriginalName": "s_hadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em>) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as signed integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y) &gt;&gt; 1, where x and y are treated as signed integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 145,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_hadd",
          "OriginalName": "u_hadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em>) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as unsigned integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y) &gt;&gt; 1, where x and y are treated as unsigned integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 146,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_rhadd",
          "OriginalName": "s_rhadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em> + 1) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as signed integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y + 1) &gt;&gt; 1, where x and y are treated as signed integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 147,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_rhadd",
          "OriginalName": "u_rhadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em> + 1) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as unsigned integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y + 1) &gt;&gt; 1, where x and y are treated as unsigned integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 148,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_clamp",
          "OriginalName": "s_clamp",
          "Description": "Returns <em>s_min</em>(<em>s_max</em>(<em>x</em>,<em>minval</em>),<em>maxval</em>). Results are undefined if <em>minval</em> &gt; <em>maxval</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>minval</em> and <em>maxval</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns s_min(s_max(x,minval),maxval). Results are undefined if minval &gt; maxval.\n\nResult Type,x,minval and maxval must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 149,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "minval",
              "Tpe": "ID"
            },
            {
              "Name": "maxval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_clamp",
          "OriginalName": "u_clamp",
          "Description": "Returns <em>u_min</em>(<em>u_max</em>(<em>x</em>,<em>minval</em>),<em>maxval</em>). Results are undefined if <em>minval</em> &gt; <em>maxval</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>minval</em> and <em>maxval</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns u_min(u_max(x,minval),maxval). Results are undefined if minval &gt; maxval.\n\nResult Type,x,minval and maxval must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 150,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "minval",
              "Tpe": "ID"
            },
            {
              "Name": "maxval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Clz",
          "OriginalName": "clz",
          "Description": "Returns the number of leading 0-bits in <em>x</em>, starting at the most significant bit position. If <em>x</em> is 0, returns the size in bits of the type of <em>x</em> or component type of <em>x</em>, if <em>x</em> is a vector.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, returns the size in bits of the type of x or component type of x, if x is a vector.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 151,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ctz",
          "OriginalName": "ctz",
          "Description": "Returns the count of trailing 0-bits in <em>x</em>. If <em>x</em> is 0, returns the size in bits of the type of <em>x</em> or component type of <em>x</em>, if <em>x</em> is a vector.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the count of trailing 0-bits in x. If x is 0, returns the size in bits of the type of x or component type of x, if x is a vector.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 152,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mad_hi",
          "OriginalName": "s_mad_hi",
          "Description": "Returns <em>mul_hi</em>(<em>a</em>, <em>b</em>) + <em>c</em>, where <em>a</em>,<em>b</em> and <em>c</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns mul_hi(a, b) + c, where a,b and c are treated as signed integers.\n\nResult Type,a,b and c must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 153,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_max",
          "OriginalName": "s_max",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 156,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_max",
          "OriginalName": "u_max",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 157,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_min",
          "OriginalName": "s_min",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 158,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_min",
          "OriginalName": "u_min",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 159,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mul_hi",
          "OriginalName": "s_mul_hi",
          "Description": "Computes <em>x</em> * <em>y</em> and returns the high half of the product of <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes x * y and returns the high half of the product of x and y, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 160,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rotate",
          "OriginalName": "rotate",
          "Description": "For each element in <em>v</em>, the bits are shifted left by the number of bits given by the corresponding element in <em>i</em>. Bits shifted off the left side of the element are shifted back in from the right.\n<br />\n<em>Result Type</em>,<em>v</em> and <em>i</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "For each element in v, the bits are shifted left by the number of bits given by the corresponding element in i. Bits shifted off the left side of the element are shifted back in from the right.\n\nResult Type,v and i must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 161,
          "Operands": [
            {
              "Name": "v",
              "Tpe": "ID"
            },
            {
              "Name": "i",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_sub_sat",
          "OriginalName": "s_sub_sat",
          "Description": "Returns the saturated value of <em>x</em> - <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x - y, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 162,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_sub_sat",
          "OriginalName": "u_sub_sat",
          "Description": "Returns the saturated value of <em>x</em> - <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x - y, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 163,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_upsample",
          "OriginalName": "u_upsample",
          "Description": "When <em>hi</em> and <em>lo</em> component type is i8:<br />\nResult = ((upcast&#8230;to i16)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component type is i16:<br />\nResult = ((upcast&#8230;to i32)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component i32:<br />\nResult = ((upcast&#8230;to i64)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\n<em>hi</em> and <em>lo</em> are treated as unsigned integers.\n<br />\n<em>hi</em> and <em>lo</em> must be <em>i8</em>, <em>i16</em> or <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i8</em>, <em>i16</em> or <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>i16</em>, <em>i32</em> or <em>i64</em> or <em>vector(2,3,4,8,16)</em> of <em>i16</em>, <em>i32</em> or <em>i64</em> values. <br />\n<em>hi</em> and <em>lo</em> operands must be of the same type. When <em>hi</em> and <em>lo</em> component type is i8, the <em>Result Type</em> component type must be i16. When <em>hi</em> and <em>lo</em> component type is i16, the <em>Result Type</em> component type must be i32. When <em>hi</em> and <em>lo</em> component type is i32, the <em>Result Type</em> component type must be i64. <em>Result Type</em> must have the same component count as <em>hi</em> and <em>lo</em> operands.<br />",
          "DescriptionPlain": "When hi and lo component type is i8:\nResult = ((upcast&#8230;to i16)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component type is i16:\nResult = ((upcast&#8230;to i32)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component i32:\nResult = ((upcast&#8230;to i64)hi &lt;&lt; 8) | lo\n\nhi and lo are treated as unsigned integers.\n\nhi and lo must be i8, i16 or i32 or vector(2,3,4,8,16) of i8, i16 or i32 values. \nResult Type must be i16, i32 or i64 or vector(2,3,4,8,16) of i16, i32 or i64 values. \nhi and lo operands must be of the same type. When hi and lo component type is i8, the Result Type component type must be i16. When hi and lo component type is i16, the Result Type component type must be i32. When hi and lo component type is i32, the Result Type component type must be i64. Result Type must have the same component count as hi and lo operands.",
          "Category": "IntegerInstructions",
          "Number": 164,
          "Operands": [
            {
              "Name": "hi",
              "Tpe": "ID"
            },
            {
              "Name": "lo",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_upsample",
          "OriginalName": "s_upsample",
          "Description": "When <em>hi</em> and <em>lo</em> component type is i8:<br />\nResult = ((upcast&#8230;to i16)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component type is i16:<br />\nResult = ((upcast&#8230;to i32)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component i32:<br />\nResult = ((upcast&#8230;to i64)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\n<em>hi</em> and <em>lo</em> are treated as signed integers.\n<br />\n<em>hi</em> and <em>lo</em> must be <em>i8</em>, <em>i16</em> or <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i8</em>, <em>i16</em> or <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>i16</em>, <em>i32</em> or <em>i64</em> or <em>vector(2,3,4,8,16)</em> of <em>i16</em>, <em>i32</em> or <em>i64</em> values. <br />\n<em>hi</em> and <em>lo</em> operands must be of the same type. When <em>hi</em> and <em>lo</em> component type is i8, the <em>Result Type</em> component type must be i16. When <em>hi</em> and <em>lo</em> component type is i16, the <em>Result Type</em> component type must be i32. When <em>hi</em> and <em>lo</em> component type is i32, the <em>Result Type</em> component type must be i64. <em>Result Type</em> must have the same component count as <em>hi</em> and <em>lo</em> operands.<br />",
          "DescriptionPlain": "When hi and lo component type is i8:\nResult = ((upcast&#8230;to i16)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component type is i16:\nResult = ((upcast&#8230;to i32)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component i32:\nResult = ((upcast&#8230;to i64)hi &lt;&lt; 8) | lo\n\nhi and lo are treated as signed integers.\n\nhi and lo must be i8, i16 or i32 or vector(2,3,4,8,16) of i8, i16 or i32 values. \nResult Type must be i16, i32 or i64 or vector(2,3,4,8,16) of i16, i32 or i64 values. \nhi and lo operands must be of the same type. When hi and lo component type is i8, the Result Type component type must be i16. When hi and lo component type is i16, the Result Type component type must be i32. When hi and lo component type is i32, the Result Type component type must be i64. Result Type must have the same component count as hi and lo operands.",
          "Category": "IntegerInstructions",
          "Number": 165,
          "Operands": [
            {
              "Name": "hi",
              "Tpe": "ID"
            },
            {
              "Name": "lo",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Popcount",
          "OriginalName": "popcount",
          "Description": "Returns the number of non-zero bits in <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the number of non-zero bits in x.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 166,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mad24",
          "OriginalName": "s_mad24",
          "Description": "Multipy two 24-bit integer values <em>x</em> and <em>y</em> and add the 32-bit integer result to the 32-bit integer <em>z</em>. Refer to definition of s_mul24 to see how the 24-bit integer multiplication is performed.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>z</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multipy two 24-bit integer values x and y and add the 32-bit integer result to the 32-bit integer z. Refer to definition of s_mul24 to see how the 24-bit integer multiplication is performed.\n\nResult Type,x,y and z must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 167,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "z",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mad24",
          "OriginalName": "u_mad24",
          "Description": "Multipy two 24-bit integer values <em>x</em> and <em>y</em> and add the 32-bit integer result to the 32-bit integer <em>z</em>. Refer to definition of u_mul24 to see how the 24-bit integer multiplication is performed.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>z</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multipy two 24-bit integer values x and y and add the 32-bit integer result to the 32-bit integer z. Refer to definition of u_mul24 to see how the 24-bit integer multiplication is performed.\n\nResult Type,x,y and z must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 168,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "z",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mul24",
          "OriginalName": "s_mul24",
          "Description": "Multiply two 24-bit integer values <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers. <em>x</em> and <em>y</em> are 32-bit integers but only the low 24-bits are used to perform the multiplication. s_mul24 should only be used when values in <em>x</em> and <em>y</em> are in the range [-2<sup>23</sup>, 2<sup>23</sup>-1]. If <em>x</em> and <em>y</em> are not in this range, the multiplication result is implementation-defined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multiply two 24-bit integer values x and y, where x and y are treated as signed integers. x and y are 32-bit integers but only the low 24-bits are used to perform the multiplication. s_mul24 should only be used when values in x and y are in the range [-223, 223-1]. If x and y are not in this range, the multiplication result is implementation-defined.\n\nResult Type,x and y must be i32 or vector(2,3,4,8,16) of i32 values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 169,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mul24",
          "OriginalName": "u_mul24",
          "Description": "Multiply two 24-bit integer values <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers. <em>x</em> and <em>y</em> are 32-bit integers but only the low 24-bits are used to perform the multiplication. u_mul24 should only be used when values in <em>x</em> and <em>y</em> are in the range [0, 2<sup>24</sup>-1]. If <em>x</em> and <em>y</em> are not in this range, the multiplication result is implementation-defined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multiply two 24-bit integer values x and y, where x and y are treated as unsigned integers. x and y are 32-bit integers but only the low 24-bits are used to perform the multiplication. u_mul24 should only be used when values in x and y are in the range [0, 224-1]. If x and y are not in this range, the multiplication result is implementation-defined.\n\nResult Type,x and y must be i32 or vector(2,3,4,8,16) of i32 values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 170,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_abs",
          "OriginalName": "u_abs",
          "Description": "Returns |<em>x</em>|, where <em>x</em> is treated as unsigned integer.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns |x|, where x is treated as unsigned integer.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 201,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_abs_diff",
          "OriginalName": "u_abs_diff",
          "Description": "Returns | <em>x</em> - <em>y</em> | without modulo overflow, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns | x - y | without modulo overflow, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 202,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mul_hi",
          "OriginalName": "u_mul_hi",
          "Description": "Computes <em>x</em> * <em>y</em> and returns the high half of the product of <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes x * y and returns the high half of the product of x and y, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 203,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mad_hi",
          "OriginalName": "u_mad_hi",
          "Description": "Returns <em>mul_hi</em>(<em>a</em>, <em>b</em>) + <em>c</em>, where <em>a</em>,<em>b</em> and <em>c</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns mul_hi(a, b) + c, where a,b and c are treated as unsigned integers.\n\nResult Type,a,b and c must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 204,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fclamp",
          "OriginalName": "fclamp",
          "Description": "Returns <em>fmin</em>(<em>fmax</em>(<em>x</em>, <em>minval</em>), <em>maxval</em>). Results are undefined if <em>minval</em> &gt; <em>maxval</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>minval</em> and <em>maxval</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns fmin(fmax(x, minval), maxval). Results are undefined if minval &gt; maxval.\n\nResult Type,x,minval and maxval must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 95,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "minval",
              "Tpe": "ID"
            },
            {
              "Name": "maxval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Degrees",
          "OriginalName": "degrees",
          "Description": "Converts <em>radians</em> to degrees, i.e. (180 / &#960;) * <em>radians</em>.\n<br />\n<em>Result Type</em> and <em>radians</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Converts radians to degrees, i.e. (180 / &#960;) * radians.\n\nResult Type and radians must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 96,
          "Operands": [
            {
              "Name": "radians",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmax_common",
          "OriginalName": "fmax_common",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>. If x or y are infinite or NaN, the return values are undefined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x. If x or y are infinite or NaN, the return values are undefined.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 97,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmin_common",
          "OriginalName": "fmin_common",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>. If x or y are infinite or NaN, the return values are undefined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x. If x or y are infinite or NaN, the return values are undefined.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 98,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Mix",
          "OriginalName": "mix",
          "Description": "Returns the linear blend of <em>x</em> &amp; <em>y</em> implemented as:<br />\n<em>x</em> + (<em>y</em> - <em>x</em>) * <em>a</em>\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>a</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> This function can be implemented using contractions such as mad or fma<br />",
          "DescriptionPlain": "Returns the linear blend of x &amp; y implemented as:\nx + (y - x) * a\n\nResult Type,x,y and a must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: This function can be implemented using contractions such as mad or fma",
          "Category": "CommonInstructions",
          "Number": 99,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "a",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Radians",
          "OriginalName": "radians",
          "Description": "Converts <em>degrees</em> to radians, i.e. (&#960; / 180) * <em>degrees</em>.\n<br />\n<em>Result Type</em> and <em>degrees</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Converts degrees to radians, i.e. (&#960; / 180) * degrees.\n\nResult Type and degrees must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 100,
          "Operands": [
            {
              "Name": "degrees",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Step",
          "OriginalName": "step",
          "Description": "Returns 0.0 if <em>x</em> &lt; <em>edge</em>, otherwise it returns 1.0.\n<br />\n<em>Result Type</em>,<em>edge</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns 0.0 if x &lt; edge, otherwise it returns 1.0.\n\nResult Type,edge and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 101,
          "Operands": [
            {
              "Name": "edge",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Smoothstep",
          "OriginalName": "smoothstep",
          "Description": "Returns 0.0 if <em>x</em> &#8656; <em>edge<sub>0</sub></em> and 1.0 if <em>x</em> &gt;= <em>edge<sub>1</sub></em> and performs smooth Hermite interpolation between 0 and 1, when <em>edge<sub>0</sub></em> &lt; x &lt; <em>edge<sub>1</sub></em>.<br />\n<br />\n This is equivalent to :<br />\n t = <em>fclamp</em>((<em>x</em> - <em>edge<sub>0</sub></em>) / (<em>edge<sub>1</sub></em> - <em>edge<sub>0</sub></em>), 0, 1);<br />\n return t * t * (3 - 2 * t);<br />\n<br />\nResults are undefined if <em>edge<sub>0</sub></em> &gt;= <em>edge<sub>1</sub></em> or if <em>x</em>, <em>edge<sub>0</sub></em> or <em>edge<sub>1</sub></em> is a NaN.\n<br />\n<em>Result Type</em>,<em>edge<sub>0</sub></em>,<em>edge<sub>1</sub></em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> This function can be implemented using contractions such as mad or fma<br />",
          "DescriptionPlain": "Returns 0.0 if x &#8656; edge0 and 1.0 if x &gt;= edge1 and performs smooth Hermite interpolation between 0 and 1, when edge0 &lt; x &lt; edge1.\n\n This is equivalent to :\n t = fclamp((x - edge0) / (edge1 - edge0), 0, 1);\n return t * t * (3 - 2 * t);\n\nResults are undefined if edge0 &gt;= edge1 or if x, edge0 or edge1 is a NaN.\n\nResult Type,edge0,edge1 and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: This function can be implemented using contractions such as mad or fma",
          "Category": "CommonInstructions",
          "Number": 102,
          "Operands": [
            {
              "Name": "edge0",
              "Tpe": "ID"
            },
            {
              "Name": "edge1",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sign",
          "OriginalName": "sign",
          "Description": "Returns 1.0 if <em>x</em> &gt; 0, -0.0 if <em>x</em> = -0.0, +0.0 if <em>x</em> = +0.0, or -1.0 if <em>x</em> &lt; 0. Returns 0.0 if <em>x</em> is a NaN.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns 1.0 if x &gt; 0, -0.0 if x = -0.0, +0.0 if x = +0.0, or -1.0 if x &lt; 0. Returns 0.0 if x is a NaN.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 103,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cross",
          "OriginalName": "cross",
          "Description": "Returns the cross product of <em>p<sub>0</sub></em>.xyz and <em>p<sub>1</sub></em>.xyz. <br />\nWhen the vector component count is 4, the w component returned will be 0.0.\n<br />\n<em>Result Type</em>,<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> must be  <em>vector(3,4)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the cross product of p0.xyz and p1.xyz. \nWhen the vector component count is 4, the w component returned will be 0.0.\n\nResult Type,p0 and p1 must be  vector(3,4) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "GeometricInstructions",
          "Number": 104,
          "Operands": [
            {
              "Name": "p0",
              "Tpe": "ID"
            },
            {
              "Name": "p1",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Distance",
          "OriginalName": "distance",
          "Description": "Returns the distance between <em>p<sub>0</sub></em> and <em>p<sub>1</sub></em>.  This is calculated as <em>length</em>(<em>p<sub>0</sub></em> - <em>p<sub>1</sub></em>).\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same type. <em>Result Type</em>, <em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same component type",
          "DescriptionPlain": "Returns the distance between p0 and p1.  This is calculated as length(p0 - p1).\n\nResult Type must be floating-point. \np0 and p1 must be floating-point or vector(2,3,4) of floating-point values. \np0 and p1 operands must have the same type. Result Type, p0 and p1 operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 105,
          "Operands": [
            {
              "Name": "p0",
              "Tpe": "ID"
            },
            {
              "Name": "p1",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Length",
          "OriginalName": "length",
          "Description": "Return the length of vector <em>p</em>, i.e. <em>sqrt</em>( <em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> + &#8230; )\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p</em> must be  <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>p</em> operands must have the same component type",
          "DescriptionPlain": "Return the length of vector p, i.e. sqrt( p.x2 + p.y2 + &#8230; )\n\nResult Type must be floating-point. \np must be  vector(2,3,4) of floating-point values. \nResult Type and p operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 106,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Normalize",
          "OriginalName": "normalize",
          "Description": "Returns a vector in the same direction as <em>p</em> but with a length of 1.\n<br />\n<em>Result Type</em> and <em>p</em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns a vector in the same direction as p but with a length of 1.\n\nResult Type and p must be floating-point or vector(2,3,4) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "GeometricInstructions",
          "Number": 107,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fast_distance",
          "OriginalName": "fast_distance",
          "Description": "Returns <em>fast_length</em>(<em>p<sub>0</sub></em> - <em>p<sub>1</sub></em>).\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same type. <em>Result Type</em>, <em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same component type",
          "DescriptionPlain": "Returns fast_length(p0 - p1).\n\nResult Type must be floating-point. \np0 and p1 must be floating-point or vector(2,3,4) of floating-point values. \np0 and p1 operands must have the same type. Result Type, p0 and p1 operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 108,
          "Operands": [
            {
              "Name": "p0",
              "Tpe": "ID"
            },
            {
              "Name": "p1",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fast_length",
          "OriginalName": "fast_length",
          "Description": "Return the length of vector <em>p</em> computed as: <em>half_sqrt</em>( <em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> + &#8230; )\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p</em> must be  <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>p</em> operands must have the same component type",
          "DescriptionPlain": "Return the length of vector p computed as: half_sqrt( p.x2 + p.y2 + &#8230; )\n\nResult Type must be floating-point. \np must be  vector(2,3,4) of floating-point values. \nResult Type and p operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 109,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fast_normalize",
          "OriginalName": "fast_normalize",
          "Description": "Returns a vector in the same direction as <em>p</em> but with a length of 1 computed as:<br />\n<em>p</em> * <em>half_rsqrt</em>( <em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> &#8230; ) <br />\n<br />\nThe result shall be within 8192 ulps error from the infinitely precise result of:<br />\nif (<em>all</em>( <em>p</em> == 0.0f )) { result = <em>p</em>; }<br />\nelse {  result = <em>p</em> / <em>sqrt</em>(<em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> + &#8230;); }<br />\n<br />\nwith the following exceptions :<br />\n1) If the sum of squares is greater than FLT_MAX then the value of the floating-point values in the result vector are undefined.<br />\n2) If the sum of squares is less than FLT_MIN then the implementation may return back <em>p</em>.<br />\n3) If the device is in \"denorms are flushed to zero\" mode, individual operand elements with magnitude less than <em>sqrt</em>(FLT_MIN) may be flushed to zero before proceeding with the calculation.\n<br />\n<em>Result Type</em> and <em>p</em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns a vector in the same direction as p but with a length of 1 computed as:\np * half_rsqrt( p.x2 + p.y2 &#8230; ) \n\nThe result shall be within 8192 ulps error from the infinitely precise result of:\nif (all( p == 0.0f )) { result = p; }\nelse {  result = p / sqrt(p.x2 + p.y2 + &#8230;); }\n\nwith the following exceptions :\n1) If the sum of squares is greater than FLT_MAX then the value of the floating-point values in the result vector are undefined.\n2) If the sum of squares is less than FLT_MIN then the implementation may return back p.\n3) If the device is in \"denorms are flushed to zero\" mode, individual operand elements with magnitude less than sqrt(FLT_MIN) may be flushed to zero before proceeding with the calculation.\n\nResult Type and p must be floating-point or vector(2,3,4) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "GeometricInstructions",
          "Number": 110,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Bitselect",
          "OriginalName": "bitselect",
          "Description": "Each bit of the result is the corresponding bit of <em>a</em> if the corresponding bit of <em>c</em> is 0.  Otherwise it is the corresponding bit of <em>b</em>.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>floating-point</em> or <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Each bit of the result is the corresponding bit of a if the corresponding bit of c is 0.  Otherwise it is the corresponding bit of b.\n\nResult Type,a,b and c must be floating-point or integer or vector(2,3,4,8,16) of floating-point or integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "RelationalInstructions",
          "Number": 186,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Select",
          "OriginalName": "select",
          "Description": "Each bit of the result is the corresponding bit of <em>a</em> if the corresponding bit of <em>c</em> is 0.  Otherwise it is the corresponding bit of <em>b</em>.\n<br />\n<em>c</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\n<em>Result Type</em>,<em>a</em> and <em>b</em> must be <em>floating-point</em> or <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\n<em>Result Type</em>, <em>a</em> and <em>b</em> must have the same type. <em>c</em> operand must have the same component count and component bit width as the rest of the operands.",
          "DescriptionPlain": "Each bit of the result is the corresponding bit of a if the corresponding bit of c is 0.  Otherwise it is the corresponding bit of b.\n\nc must be integer or vector(2,3,4,8,16) of integer values. \nResult Type,a and b must be floating-point or integer or vector(2,3,4,8,16) of floating-point or integer values. \nResult Type, a and b must have the same type. c operand must have the same component count and component bit width as the rest of the operands.",
          "Category": "RelationalInstructions",
          "Number": 187,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vloadn",
          "OriginalName": "vloadn",
          "Description": "Return a vector value which is read from address (<em>p</em> + (<em>offset</em> * <em>n</em>)). <br />\nThe address computed as (<em>p</em> + (<em>offset</em> * <em>n</em>)) must be 8-bit aligned if <em>p</em> points to i8 value; 16-bit aligned if <em>p</em> points to i16 or half value; 32-bit aligned if <em>p</em> points to i32 or float value; 64-bit aligned if <em>p</em> points to i64 or double value.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>, <em>constant</em>) to <em>floating-point</em>, <em>integer</em>. <br />\n<em>Result Type</em> must be  <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\n<em>Result Type</em> component count must be equal to <em>n</em> and its component type must be equal to the type pointed by <em>p</em>.<br />\n<em>n</em> must be 2,3,4,8 or 16.",
          "DescriptionPlain": "Return a vector value which is read from address (p + (offset * n)). \nThe address computed as (p + (offset * n)) must be 8-bit aligned if p points to i8 value; 16-bit aligned if p points to i16 or half value; 32-bit aligned if p points to i32 or float value; 64-bit aligned if p points to i64 or double value.\n\noffset must be size_t. \np must be a pointer(global, local, private, constant) to floating-point, integer. \nResult Type must be  vector(2,3,4,8,16) of floating-point or integer values. \nResult Type component count must be equal to n and its component type must be equal to the type pointed by p.\nn must be 2,3,4,8 or 16.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 171,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "n",
              "Type": "LiteralNumber"
            }
          ]
        },
        {
          "Name": "Vstoren",
          "OriginalName": "vstoren",
          "Description": "Write <em>data</em> vector value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be 8-bit aligned if <em>p</em> points to i8 value; 16-bit aligned if <em>p</em> points to i16 or half value; 32-bit aligned if <em>p</em> points to i32 or float value; 64-bit aligned if <em>p</em> points to i64 or double value.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>floating-point</em>, <em>integer</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\n<em>data</em> component type must be equal to the type pointed by <em>p</em>.",
          "DescriptionPlain": "Write data vector value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be 8-bit aligned if p points to i8 value; 16-bit aligned if p points to i16 or half value; 32-bit aligned if p points to i32 or float value; 64-bit aligned if p points to i64 or double value.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(global, local, private) to floating-point, integer. \ndata must be  vector(2,3,4,8,16) of floating-point or integer values. \ndata component type must be equal to the type pointed by p.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 172,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vload_half",
          "OriginalName": "vload_half",
          "Description": "Reads a half value from the address (<em>p</em> + (<em>offset</em>)) and converts it to a float return value. The address computed as (<em>p</em> + (<em>offset</em>)) must be 16-bit aligned.\n<br />\n<em>Result Type</em> must be <em>float</em>. <br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>, <em>constant</em>) to <em>half</em>. <br />",
          "DescriptionPlain": "Reads a half value from the address (p + (offset)) and converts it to a float return value. The address computed as (p + (offset)) must be 16-bit aligned.\n\nResult Type must be float. \noffset must be size_t. \np must be a pointer(global, local, private, constant) to half. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 173,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vload_halfn",
          "OriginalName": "vload_halfn",
          "Description": "Reads a half vector value from the address (<em>p</em> + (<em>offset</em> * <em>n</em>)) and converts it to a float vector return value. The address computed as (<em>p</em> + (<em>offset</em> * <em>n</em>)) must be 16-bit aligned.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>, <em>constant</em>) to <em>half</em>. <br />\n<em>Result Type</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\n<em>Result Type</em> component count must be equal to <em>n</em>.<br />\n<em>n</em> must be 2,3,4,8 or 16.",
          "DescriptionPlain": "Reads a half vector value from the address (p + (offset * n)) and converts it to a float vector return value. The address computed as (p + (offset * n)) must be 16-bit aligned.\n\noffset must be size_t. \np must be a pointer(global, local, private, constant) to half. \nResult Type must be  vector(2,3,4,8,16) of float values. \nResult Type component count must be equal to n.\nn must be 2,3,4,8 or 16.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 174,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "n",
              "Type": "LiteralNumber"
            }
          ]
        },
        {
          "Name": "Vstore_half",
          "OriginalName": "vstore_half",
          "Description": "Converts <em>data</em> float or double value to a half value and then write the converted value to the address (<em>p</em> + <em>offset</em>). The address computed as (<em>p</em> + <em>offset</em>) must be 16-bit aligned. <br />\nThis function uses the default rounding mode when converting <em>data</em> to a half value. The default rounding mode is round to nearest even.\n<br />\n<em>data</em> must be <em>float</em> or <em>double</em>. <br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>half</em>. <br />",
          "DescriptionPlain": "Converts data float or double value to a half value and then write the converted value to the address (p + offset). The address computed as (p + offset) must be 16-bit aligned. \nThis function uses the default rounding mode when converting data to a half value. The default rounding mode is round to nearest even.\n\ndata must be float or double. \noffset must be size_t. \nResult Type must be void. \np must be a pointer(global, local, private) to half. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 175,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstore_half_r",
          "OriginalName": "vstore_half_r",
          "Description": "Converts <em>data</em> float or double value to a half value and then write the converted value to the address (<em>p</em> + <em>offset</em>). The address computed as (<em>p</em> + <em>offset</em>) must be 16-bit aligned. <br />\nThis function uses <em>mode</em> rounding mode when converting <em>data</em> to a half value.\n<br />\n<em>data</em> must be <em>float</em> or <em>double</em>. <br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>half</em>. <br />",
          "DescriptionPlain": "Converts data float or double value to a half value and then write the converted value to the address (p + offset). The address computed as (p + offset) must be 16-bit aligned. \nThis function uses mode rounding mode when converting data to a half value.\n\ndata must be float or double. \noffset must be size_t. \nResult Type must be void. \np must be a pointer(global, local, private) to half. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 176,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "FP Rounding Mode\nmode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstore_halfn",
          "OriginalName": "vstore_halfn",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be 16-bit aligned.<br />\nThis function uses the default rounding mode when converting <em>data</em> to a vector of half values. The default rounding mode is round to nearest even.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be 16-bit aligned.\nThis function uses the default rounding mode when converting data to a vector of half values. The default rounding mode is round to nearest even.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(global, local, private) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 177,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstore_halfn_r",
          "OriginalName": "vstore_halfn_r",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be 16-bit aligned.<br />\nThis function uses <em>mode</em> rounding mode when converting <em>data</em> to a half value.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be 16-bit aligned.\nThis function uses mode rounding mode when converting data to a half value.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(global, local, private) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 178,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "FP Rounding Mode\nmode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vloada_halfn",
          "OriginalName": "vloada_halfn",
          "Description": "Reads a half vector value from the address (<em>p</em> + (<em>offset</em> * <em>n</em>)) and converts it to a float vector return value. The address computed as (<em>p</em> + (<em>offset</em> * <em>n</em>)) must be (2 * <em>n</em>) bytes aligned, when n = 2,4,8,16; For <em>n</em> = 3, the function returns a vector of 3 float values from the address (<em>p</em> + (<em>offset</em> * 4)). The address computed as (<em>p</em> + (<em>offset</em> * 4)) must be 8-bytes aligned\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>, <em>constant</em>) to <em>half</em>. <br />\n<em>Result Type</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\n<em>Result Type</em> component count must be equal to <em>n</em>.<br />\n<em>n</em> must be 2,3,4,8 or 16.",
          "DescriptionPlain": "Reads a half vector value from the address (p + (offset * n)) and converts it to a float vector return value. The address computed as (p + (offset * n)) must be (2 * n) bytes aligned, when n = 2,4,8,16; For n = 3, the function returns a vector of 3 float values from the address (p + (offset * 4)). The address computed as (p + (offset * 4)) must be 8-bytes aligned\n\noffset must be size_t. \np must be a pointer(global, local, private, constant) to half. \nResult Type must be  vector(2,3,4,8,16) of float values. \nResult Type component count must be equal to n.\nn must be 2,3,4,8 or 16.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 179,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "n",
              "Type": "LiteralNumber"
            }
          ]
        },
        {
          "Name": "Vstorea_halfn",
          "OriginalName": "vstorea_halfn",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be (2 * compCountOf(<em>data</em>)) bytes aligned, when n = 2,4,8,16; For <em>n</em> = 3, the function returns a vector of 3 float values from the address (<em>p</em> + (<em>offset</em> * 4)). The address computed as (<em>p</em> + (<em>offset</em> * 4)) must be 8-bytes aligned.<br />\nThis function uses the default rounding mode when converting <em>data</em> to a vector of half values. The default rounding mode is round to nearest even.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be (2 * compCountOf(data)) bytes aligned, when n = 2,4,8,16; For n = 3, the function returns a vector of 3 float values from the address (p + (offset * 4)). The address computed as (p + (offset * 4)) must be 8-bytes aligned.\nThis function uses the default rounding mode when converting data to a vector of half values. The default rounding mode is round to nearest even.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(global, local, private) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 180,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstorea_halfn_r",
          "OriginalName": "vstorea_halfn_r",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be (2 * compCountOf(<em>data</em>)) bytes aligned, when n = 2,4,8,16; For <em>n</em> = 3, the function returns a vector of 3 float values from the address (<em>p</em> + (<em>offset</em> * 4)). The address computed as (<em>p</em> + (<em>offset</em> * 4)) must be 8-bytes aligned.<br />\nThis function uses <em>mode</em> rounding mode when converting <em>data</em> to a vector of half values.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>, <em>local</em>, <em>private</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be (2 * compCountOf(data)) bytes aligned, when n = 2,4,8,16; For n = 3, the function returns a vector of 3 float values from the address (p + (offset * 4)). The address computed as (p + (offset * 4)) must be 8-bytes aligned.\nThis function uses mode rounding mode when converting data to a vector of half values.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(global, local, private) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 181,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "FP Rounding Mode\nmode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Shuffle",
          "OriginalName": "shuffle",
          "Description": "Construct a permutation of components from <em>x</em> vector value, returning a vector value with the same component type as <em>x</em> and component component count that is the same as <em>shuffle mask</em>.<br />\nIn this function, only the <em>ilogb</em>(2 <em>m</em> -1) least significant bits of each mask element are considered, where <em>m</em> is equal to the component count of <em>x</em>.<br />\n<em>shuffle mask</em> operand specifies, for each component in the result vector, which component of <em>x</em> it gets.<br />\nThe size of each component in <em>shuffle mask</em> must match the size of each component in <em>Result Type</em>.<br />\n<em>Result Type</em> must have the same component type as <em>x</em> and component count as <em>shuffle mask</em>.\n<br />\n<em>shuffle mask</em> must be  <em>vector(2,4,8,16)</em> of <em>integer</em> values. <br />\n<em>Result Type</em> and <em>x</em> must be  <em>vector(2,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Construct a permutation of components from x vector value, returning a vector value with the same component type as x and component component count that is the same as shuffle mask.\nIn this function, only the ilogb(2 m -1) least significant bits of each mask element are considered, where m is equal to the component count of x.\nshuffle mask operand specifies, for each component in the result vector, which component of x it gets.\nThe size of each component in shuffle mask must match the size of each component in Result Type.\nResult Type must have the same component type as x and component count as shuffle mask.\n\nshuffle mask must be  vector(2,4,8,16) of integer values. \nResult Type and x must be  vector(2,4,8,16) of floating-point or integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MiscellaneousVectorInstructions",
          "Number": 182,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "shuffle mask",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Shuffle2",
          "OriginalName": "shuffle2",
          "Description": "Construct a permutation of components from <em>x</em> and <em>y</em> vector values, returning a vector value with the same component type as <em>x</em> and <em>y</em> and component count that is the same as <em>shuffle mask</em>.<br />\nIn this function, only the <em>ilogb</em>(2 <em>m</em> - 1) + 1 least significant bits of each mask component are considered, where <em>m</em> is equal to the component count of <em>x</em> and <em>y</em>.<br />\n<em>shuffle mask</em> operand specifies, for each component in the result vector, which component of <em>x</em> or <em>y</em> it gets. Where component count begins with <em>x</em> and then proceeds to <em>y</em>.<br />\n<em>x</em> and <em>y</em> must be of the same type.<br />\nThe size of each component in <em>shuffle mask</em> must match the size of each component in <em>Result Type</em>.<br />\n<em>Result Type</em> must have the same component type as <em>x</em> and component count as <em>shuffle mask</em>.\n<br />\n<em>shuffle mask</em> must be  <em>vector(2,4,8,16)</em> of <em>integer</em> values. <br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be  <em>vector(2,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Construct a permutation of components from x and y vector values, returning a vector value with the same component type as x and y and component count that is the same as shuffle mask.\nIn this function, only the ilogb(2 m - 1) + 1 least significant bits of each mask component are considered, where m is equal to the component count of x and y.\nshuffle mask operand specifies, for each component in the result vector, which component of x or y it gets. Where component count begins with x and then proceeds to y.\nx and y must be of the same type.\nThe size of each component in shuffle mask must match the size of each component in Result Type.\nResult Type must have the same component type as x and component count as shuffle mask.\n\nshuffle mask must be  vector(2,4,8,16) of integer values. \nResult Type,x and y must be  vector(2,4,8,16) of floating-point or integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MiscellaneousVectorInstructions",
          "Number": 183,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "shuffle mask",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Printf",
          "OriginalName": "printf",
          "Description": "The <em>printf</em> extended instruction writes output to an implementation-defined stream such as stdout under control of the string pointed to by format that specifies how subsequent arguments are converted for output.  If there are insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.  The printf function returns when the end of the format string is encountered<br />\n<em>printf</em> returns 0 if it was executed successfully and -1 otherwise\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>format</em> must be <strong>OpString</strong>.<br />",
          "DescriptionPlain": "The printf extended instruction writes output to an implementation-defined stream such as stdout under control of the string pointed to by format that specifies how subsequent arguments are converted for output.  If there are insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.  The printf function returns when the end of the format string is encountered\nprintf returns 0 if it was executed successfully and -1 otherwise\n\nResult Type must be i32. \nformat must be OpString.",
          "Category": "MiscInstructions",
          "Number": 184,
          "Operands": [
            {
              "Name": "format",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Prefetch",
          "OriginalName": "prefetch",
          "Description": "Prefetch <em>num_elements</em> * size in bytes of the type pointed by <em>p</em>, into the global cache. The prefetch instruction is applied to a work-item in a work-group and does not affect the functional behavior of the kernel.\n<br />\n<em>num_elements</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>) to <em>floating-point</em>, <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em>, <em>integer</em> values. <br />",
          "DescriptionPlain": "Prefetch num_elements * size in bytes of the type pointed by p, into the global cache. The prefetch instruction is applied to a work-item in a work-group and does not affect the functional behavior of the kernel.\n\nnum_elements must be size_t. \nResult Type must be void. \np must be a pointer(global) to floating-point, integer or vector(2,3,4,8,16) of floating-point, integer values. ",
          "Category": "MiscInstructions",
          "Number": 185,
          "Operands": [
            {
              "Name": "num_elements",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef",
          "OriginalName": "read_imagef",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns floating-point values in the range [0.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to one of the pre-defined packed formats or <strong>UNORM INT8</strong>, or <strong>UNORM INT16</strong>. <br />\n<br />\nThis function returns floating-point values in the range[-1.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to <strong>SNORM INT8</strong>, or <strong>SNORM INT16</strong>.<br />\n<br />\nThis function returns floating-point values for <em>image</em> objects created with <em>channel data type</em> set to <strong>HALF FLOAT</strong>, or <strong>FLOAT</strong>.<br />\n<br />\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.<br />\n<br />\nValues returned by this function for image objects with <em>channel data type</em> which is not specified in the description above are undefined.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em>, <em>image2dMsaaDepth</em>, <em>image2dArrayMsaaDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>image2dDepth</em>, <em>image2dMsaa</em> or <em>image2dMsaaDepth</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dArrayMsaa</em> or <em>image2dArrayMsaaDepth</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />\n<em>Result Type</em> must be a <em>float</em> when <em>img</em> is a <em>image2dArrayDepth</em>, <em>image2dDepth</em>, <em>image2dMsaaDepth</em> or <em>image2dArrayMsaaDepth</em>, and  <em>vector(4)</em> of <em>float</em> values when <em>img</em> is on of the remaining valid image types for this instruction.",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns floating-point values in the range [0.0 &#8230; 1.0] for image objects created with channel data type set to one of the pre-defined packed formats or UNORM INT8, or UNORM INT16. \n\nThis function returns floating-point values in the range[-1.0 &#8230; 1.0] for image objects created with channel data type set to SNORM INT8, or SNORM INT16.\n\nThis function returns floating-point values for image objects created with channel data type set to HALF FLOAT, or FLOAT.\n\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nValues returned by this function for image objects with channel data type which is not specified in the description above are undefined.\n\nResult Type must be float or vector(4) of float values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth, image2dMsaa, image2dArrayMsaa, image2dMsaaDepth, image2dArrayMsaaDepth or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, image2dDepth, image2dMsaa or image2dMsaaDepth, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, image2dArrayDepth, image2dArrayMsaa or image2dArrayMsaaDepth, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.\nResult Type must be a float when img is a image2dArrayDepth, image2dDepth, image2dMsaaDepth or image2dArrayMsaaDepth, and  vector(4) of float values when img is on of the remaining valid image types for this instruction.",
          "Category": "ImageReadFunctions",
          "Number": 111,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei",
          "OriginalName": "read_imagei",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns a non-parametric <em>i32</em> integer value.<br />\n<br />\nThis function can only be used if <em>img</em> image object <em>channel data type</em> is set to <strong>SIGNED INT8</strong>, <strong>SIGNED INT16</strong> or <strong>SIGNED INT32</strong>. If the <em>channel data type</em> is not one of these values, the values returned by read_imagei are undefined.<br />\n<br />\nThe sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>image2dDepth</em>, <em>image2dMsaa</em> or <em>image2dMsaaDepth</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dArrayMsaa</em> or <em>image2dArrayMsaaDepth</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns a non-parametric i32 integer value.\n\nThis function can only be used if img image object channel data type is set to SIGNED INT8, SIGNED INT16 or SIGNED INT32. If the channel data type is not one of these values, the values returned by read_imagei are undefined.\n\nThe sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dMsaa, image2dArrayMsaa or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, image2dDepth, image2dMsaa or image2dMsaaDepth, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, image2dArrayDepth, image2dArrayMsaa or image2dArrayMsaaDepth, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.",
          "Category": "ImageReadFunctions",
          "Number": 112,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui",
          "OriginalName": "read_imageui",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns a non-parametric <em>i32</em> integer value.<br />\n<br />\nThis function can only be used if <em>img</em> image object <em>channel data type</em> is set to <strong>UNSIGNED INT8</strong>, <strong>UNSIGNED INT16</strong> or <strong>UNSIGNED INT32</strong>. If the <em>channel data type</em> is not one of these values, the values returned by read_imagei are undefined.<br />\n<br />\nThe sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>image2dDepth</em>, <em>image2dMsaa</em> or <em>image2dMsaaDepth</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dArrayMsaa</em> or <em>image2dArrayMsaaDepth</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns a non-parametric i32 integer value.\n\nThis function can only be used if img image object channel data type is set to UNSIGNED INT8, UNSIGNED INT16 or UNSIGNED INT32. If the channel data type is not one of these values, the values returned by read_imagei are undefined.\n\nThe sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dMsaa, image2dArrayMsaa or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, image2dDepth, image2dMsaa or image2dMsaaDepth, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, image2dArrayDepth, image2dArrayMsaa or image2dArrayMsaaDepth, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.",
          "Category": "ImageReadFunctions",
          "Number": 113,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageh",
          "OriginalName": "read_imageh",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns half precision floating-point values in the range [0.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to one of the pre-defined packed formats or <strong>UNORM INT8</strong>, or <strong>UNORM INT16</strong>. <br />\n<br />\nThis function returns half precision floating-point values in the range[-1.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to <strong>SNORM INT8</strong>, or <strong>SNORM INT16</strong>.<br />\n<br />\nThis function returns half precision floating-point values for <em>image</em> objects created with <em>channel data type</em> set to <strong>HALF FLOAT</strong>, or <strong>FLOAT</strong>.<br />\n<br />\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.<br />\n<br />\nValues returned by this function for image objects with <em>channel data type</em> which is not specified in the description above are undefined.\n<br />\n<em>Result Type</em> must be <em>half</em> or <em>vector(4)</em> of <em>half</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />\n<em>Result Type</em> must be a <em>half</em> when <em>img</em> is a <em>image2dArrayDepth</em>, <em>image2dDepth</em>, <em>image2dMsaaDepth</em> or <em>image2dArrayMsaaDepth</em>, and  <em>vector(4)</em> of <em>half</em> values when <em>img</em> is on of the remaining valid image types for this instruction.",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns half precision floating-point values in the range [0.0 &#8230; 1.0] for image objects created with channel data type set to one of the pre-defined packed formats or UNORM INT8, or UNORM INT16. \n\nThis function returns half precision floating-point values in the range[-1.0 &#8230; 1.0] for image objects created with channel data type set to SNORM INT8, or SNORM INT16.\n\nThis function returns half precision floating-point values for image objects created with channel data type set to HALF FLOAT, or FLOAT.\n\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nValues returned by this function for image objects with channel data type which is not specified in the description above are undefined.\n\nResult Type must be half or vector(4) of half values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.\nResult Type must be a half when img is a image2dArrayDepth, image2dDepth, image2dMsaaDepth or image2dArrayMsaaDepth, and  vector(4) of half values when img is on of the remaining valid image types for this instruction.",
          "Category": "ImageReadFunctions",
          "Number": 114,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef_samplerless",
          "OriginalName": "read_imagef_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imagef function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imagef function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be float or vector(4) of float values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 115,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei_samplerless",
          "OriginalName": "read_imagei_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imagei function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imagei function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dMsaa, image2dArrayMsaa or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 116,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui_samplerless",
          "OriginalName": "read_imageui_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imageui function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imageui function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 117,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageh_samplerless",
          "OriginalName": "read_imageh_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imageh function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>half</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imageh function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be  vector(4) of half values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 118,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef_mipmap_lod",
          "OriginalName": "read_imagef_mipmap_lod",
          "Description": "Use the coordinate specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the mip-level specified by <em>lod</em> in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\n<em>lod</em> is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a <em>float</em>.",
          "DescriptionPlain": "Use the coordinate specified by coords, and the sampler object specified by s to do an element lookup in the mip-level specified by lod in the image object specified by img.\n\nResult Type must be float or vector(4) of float values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nlod is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- Result Type must be a float.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- Result Type must be a float.",
          "Category": "ImageReadFunctions",
          "Number": 123,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei_mipmap_lod",
          "OriginalName": "read_imagei_mipmap_lod",
          "Description": "Use the coordinate specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the mip-level specified by <em>lod</em> in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\n<em>lod</em> is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>lod</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />",
          "DescriptionPlain": "Use the coordinate specified by coords, and the sampler object specified by s to do an element lookup in the mip-level specified by lod in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nlod is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- lod must be a float.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n\nWhen img type is image1d:\n- coords must be a float. \n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. ",
          "Category": "ImageReadFunctions",
          "Number": 124,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui_mipmap_lod",
          "OriginalName": "read_imageui_mipmap_lod",
          "Description": "Use the coordinate specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the mip-level specified by <em>lod</em> in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\n<em>lod</em> is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />",
          "DescriptionPlain": "Use the coordinate specified by coords, and the sampler object specified by s to do an element lookup in the mip-level specified by lod in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nlod is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n\nWhen img type is image1d:\n- coords must be a float. \n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. ",
          "Category": "ImageReadFunctions",
          "Number": 125,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef_mipmap_gradient",
          "OriginalName": "read_imagef_mipmap_gradient",
          "Description": "Use the gradients <em>grad_x</em> and <em>grad_y</em>, the coordinates specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the computed mip-level in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a <em>float</em>.",
          "DescriptionPlain": "Use the gradients grad_x and grad_y, the coordinates specified by coords, and the sampler object specified by s to do an element lookup in the computed mip-level in the image object specified by img.\n\nResult Type must be float or vector(4) of float values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- grad_x and grad_y must be a float.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a float.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(4) of float values.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a float.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a float.",
          "Category": "ImageReadFunctions",
          "Number": 126,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "grad_x",
              "Tpe": "ID"
            },
            {
              "Name": "grad_y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei_mipmap_gradient",
          "OriginalName": "read_imagei_mipmap_gradient",
          "Description": "Use the gradients <em>grad_x</em> and <em>grad_y</em>, the coordinates specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the computed mip-level in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.",
          "DescriptionPlain": "Use the gradients grad_x and grad_y, the coordinates specified by coords, and the sampler object specified by s to do an element lookup in the computed mip-level in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- grad_x and grad_y must be a float.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a float.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.",
          "Category": "ImageReadFunctions",
          "Number": 127,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "grad_x",
              "Tpe": "ID"
            },
            {
              "Name": "grad_y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui_mipmap_gradient",
          "OriginalName": "read_imageui_mipmap_gradient",
          "Description": "Use the gradients <em>grad_x</em> and <em>grad_y</em>, the coordinates specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the computed mip-level in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.",
          "DescriptionPlain": "Use the gradients grad_x and grad_y, the coordinates specified by coords, and the sampler object specified by s to do an element lookup in the computed mip-level in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- grad_x and grad_y must be a float.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a float.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.",
          "Category": "ImageReadFunctions",
          "Number": 128,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "grad_x",
              "Tpe": "ID"
            },
            {
              "Name": "grad_y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagef",
          "OriginalName": "write_imagef",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image2dDepth</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM INT16</strong>, <strong>UNORM INT24</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArrayDepth</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM INT16</strong>, <strong>UNORM INT24</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>.  <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with WriteOnly or ReadWrite access qualifier.\nWhen img is a image2d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value is a  vector(4) of float values.\n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a i32, and is in the range (0 &#8230; image width - 1)\n- value is a  vector(4) of float values.\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value is a  vector(4) of float values\n\nWhen img is a image2dDepth, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM INT16, UNORM INT24, FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value is a float.\n\nWhen img is a image2dArrayDepth, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM INT16, UNORM INT24, FLOAT. \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a float.\n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT.  \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.",
          "Category": "ImageWriteFunctions",
          "Number": 119,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagei",
          "OriginalName": "write_imagei",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>. <em>value</em> component type is considered to be a signed integer. <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe <em>channel data type</em> of <em>img</em> must be set to <strong>SIGNED INT8</strong>, <strong>SIGNED INT16</strong>, <strong>SIGNED INT32</strong>. <br />\nWhen <em>img</em> is a <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>:<br />\n- <em>coords</em> must be a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type. value component type is considered to be a signed integer. coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe channel data type of img must be set to SIGNED INT8, SIGNED INT16, SIGNED INT32. \nWhen img is a image2d:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value must be a  vector(4) of i32 values.\n\nWhen img is a image2dArray:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1d or image1dBuffer:\n- coords must be a i32, and is in the range (0 &#8230; image width - 1)\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1dArray:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value must be a  vector(4) of i32 values\n\nWhen img is a image3d:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.",
          "Category": "ImageWriteFunctions",
          "Number": 120,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imageui",
          "OriginalName": "write_imageui",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>. <em>value</em> component type is considered to be an unsigned integer. <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe <em>channel data type</em> of <em>img</em> must be set to <strong>UNSIGNED INT8</strong>, <strong>UNSIGNED INT16</strong>, <strong>UNSIGNED INT32</strong>. <br />\nWhen <em>img</em> is a <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>:<br />\n- <em>coords</em> must be a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type. value component type is considered to be an unsigned integer. coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe channel data type of img must be set to UNSIGNED INT8, UNSIGNED INT16, UNSIGNED INT32. \nWhen img is a image2d:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value must be a  vector(4) of i32 values.\n\nWhen img is a image2dArray:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1d or image1dBuffer:\n- coords must be a i32, and is in the range (0 &#8230; image width - 1)\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1dArray:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value must be a  vector(4) of i32 values\n\nWhen img is a image3d:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.",
          "Category": "ImageWriteFunctions",
          "Number": 121,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imageh",
          "OriginalName": "write_imageh",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>.  <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nWhen img is a image2d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value is a  vector(4) of half values.\n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of half values.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a i32, and is in the range (0 &#8230; image width - 1)\n- value is a  vector(4) of half values.\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value is a  vector(4) of half values\n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT.  \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of half values.",
          "Category": "ImageWriteFunctions",
          "Number": 122,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagef_mipmap_lod",
          "OriginalName": "write_imagef_mipmap_lod",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> in the mip-level specified by <em>lod</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe behavior of the function is undefined unless <em>lod</em> value is in the range (0 &#8230; number of mip-levels in the image - 1).<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height  of the mip-level specified by <em>lod</em> - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1)<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dDepth</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width  of the mip-level specified by <em>lod</em>- 1), (0 &#8230; image height of the mip-level specified by <em>lod</em>- 1) respectively. <br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArrayDepth</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip - level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image depth of the mip-level specified by <em>lod</em> - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords in the mip-level specified by lod to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe behavior of the function is undefined unless lod value is in the range (0 &#8230; number of mip-levels in the image - 1).\nWhen img is a image2d, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height  of the mip-level specified by lod - 1) respectively. \n- value is a  vector(4) of float values.\n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- coords is a i32, and is in the range (0 &#8230; image width of the mip-level specified by lod - 1)\n- value is a  vector(4) of float values.\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. \n- value is a  vector(4) of float values.\n\nWhen img is a image2dDepth, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width  of the mip-level specified by lod- 1), (0 &#8230; image height of the mip-level specified by lod- 1) respectively. \n- value is a float.\n\nWhen img is a image2dArrayDepth, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip - level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a float.\n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image depth of the mip-level specified by lod - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.",
          "Category": "ImageWriteFunctions",
          "Number": 129,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagei_mipmap_lod",
          "OriginalName": "write_imagei_mipmap_lod",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> in the mip-level specified by <em>lod</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates. <em>value</em> component type is treated as signed integer.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe behavior of the function is undefined unless <em>lod</em> value is in the range (0 &#8230; number of mip-levels in the image - 1).<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height  of the mip-level specified by <em>lod</em> - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1)<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image depth of the mip-level specified by <em>lod</em> - 1) respectively. The fourth component is ignored.<br />",
          "DescriptionPlain": "Write value to the coordinates specified by coords in the mip-level specified by lod to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates. value component type is treated as signed integer.\n\nResult Type must be void. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe behavior of the function is undefined unless lod value is in the range (0 &#8230; number of mip-levels in the image - 1).\nWhen img is a image2d, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height  of the mip-level specified by lod - 1) respectively. \n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- coords is a i32, and is in the range (0 &#8230; image width of the mip-level specified by lod - 1)\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. \n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image depth of the mip-level specified by lod - 1) respectively. The fourth component is ignored.",
          "Category": "ImageWriteFunctions",
          "Number": 130,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imageui_mipmap_lod",
          "OriginalName": "write_imageui_mipmap_lod",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> in the mip-level specified by <em>lod</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates. <em>value</em> component type is treated as unsigned integer.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe behavior of the function is undefined unless <em>lod</em> value is in the range (0 &#8230; number of mip-levels in the image - 1).<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height  of the mip-level specified by <em>lod</em> - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1)<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image depth of the mip-level specified by <em>lod</em> - 1) respectively. The fourth component is ignored.",
          "DescriptionPlain": "Write value to the coordinates specified by coords in the mip-level specified by lod to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates. value component type is treated as unsigned integer.\n\nResult Type must be void. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe behavior of the function is undefined unless lod value is in the range (0 &#8230; number of mip-levels in the image - 1).\nWhen img is a image2d, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height  of the mip-level specified by lod - 1) respectively. \n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- coords is a i32, and is in the range (0 &#8230; image width of the mip-level specified by lod - 1)\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. \n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image depth of the mip-level specified by lod - 1) respectively. The fourth component is ignored.",
          "Category": "ImageWriteFunctions",
          "Number": 131,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_width",
          "OriginalName": "get_image_width",
          "Description": "Return the width in pixels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the width in pixels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 132,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_height",
          "OriginalName": "get_image_height",
          "Description": "Return the height in pixels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the height in pixels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 133,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_depth",
          "OriginalName": "get_image_depth",
          "Description": "Return the depth in pixels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the depth in pixels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 134,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_channel_data_type",
          "OriginalName": "get_image_channel_data_type",
          "Description": "Return the <em>channel data type</em> of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>Result Type</em> must contain a value from <a href=\"#ImageChannelType\"><strong>ImageChannelType</strong></a> enumeration.",
          "DescriptionPlain": "Return the channel data type of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nResult Type must contain a value from ImageChannelType enumeration.",
          "Category": "ImageQueryFunctions",
          "Number": 135,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_channel_order",
          "OriginalName": "get_image_channel_order",
          "Description": "Return the <em>channel order</em> of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>Result Type</em> must contain a value from <a href=\"#ImageChannelOrder\"><strong>ImageChannelOrder</strong></a> enumeration.",
          "DescriptionPlain": "Return the channel order of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nResult Type must contain a value from ImageChannelOrder enumeration.",
          "Category": "ImageQueryFunctions",
          "Number": 136,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_dim",
          "OriginalName": "get_image_dim",
          "Description": "Return the dimensions of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>Result Type&#8217;must be  'vector(2)</em> of <em>i32</em> values when <em>img</em> is a <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em> or <em>image2dDepth</em>. The width and height of the image are contained in the first and second components of the return value repectively.<br />\n<em>Result Type&#8217;must be  'vector(4)</em> of <em>i32</em> values when <em>img</em> is a <em>image3d</em>. The width, height and depth of the image are contained in the first, second and third components of the return value repectively. The fourth component is 0.<br />",
          "DescriptionPlain": "Return the dimensions of the image object specified by img.\n\nResult Type must be i32 or vector(2,4) of i32 values. \nimg must be image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nResult Type&#8217;must be  'vector(2) of i32 values when img is a image2d, image2dArray, image2dArrayDepth or image2dDepth. The width and height of the image are contained in the first and second components of the return value repectively.\nResult Type&#8217;must be  'vector(4) of i32 values when img is a image3d. The width, height and depth of the image are contained in the first, second and third components of the return value repectively. The fourth component is 0.",
          "Category": "ImageQueryFunctions",
          "Number": 137,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_array_size",
          "OriginalName": "get_image_array_size",
          "Description": "Return the number of samples in the MSAA image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>Result Type</em> must be <em>size_t</em>. <br />\n<em>img</em> must be <em>image1dArray</em>, <em>image2dArray</em> or <em>image2dArrayDepth</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>img</em> must be <em>image2dMsaa</em>, <em>image2dArrayMsaa</em>, <em>image2dMsaaDepth</em> or <em>image2dArrayMsaaDepth</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the number of samples in the MSAA image object specified by img.\n\nResult Type must be i32. \nResult Type must be size_t. \nimg must be image1dArray, image2dArray or image2dArrayDepth value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nimg must be image2dMsaa, image2dArrayMsaa, image2dMsaaDepth or image2dArrayMsaaDepth value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 138,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_num_mip_levels",
          "OriginalName": "get_image_num_mip_levels",
          "Description": "Return the number of mip-levels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the number of mip-levels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 140,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        }
      ],
      "Enums": [
        {
          "Name": "ImageChannelOrder",
          "Values": [
            {
              "Value": 4272,
              "Name": "R"
            },
            {
              "Value": 4273,
              "Name": "A"
            },
            {
              "Value": 4274,
              "Name": "RG"
            },
            {
              "Value": 4275,
              "Name": "RA"
            },
            {
              "Value": 4276,
              "Name": "RGB"
            },
            {
              "Value": 4277,
              "Name": "RGBA"
            },
            {
              "Value": 4278,
              "Name": "BGRA"
            },
            {
              "Value": 4279,
              "Name": "ARGB"
            },
            {
              "Value": 4280,
              "Name": "INTENSITY"
            },
            {
              "Value": 4281,
              "Name": "LUMINANCE"
            },
            {
              "Value": 4282,
              "Name": "Rx"
            },
            {
              "Value": 4283,
              "Name": "RGx"
            },
            {
              "Value": 4284,
              "Name": "RGBx"
            },
            {
              "Value": 4285,
              "Name": "DEPTH"
            },
            {
              "Value": 4286,
              "Name": "DEPTH STENCIL"
            },
            {
              "Value": 4287,
              "Name": "sRGB"
            },
            {
              "Value": 4288,
              "Name": "sRGBx"
            },
            {
              "Value": 4289,
              "Name": "sRGBA"
            },
            {
              "Value": 4290,
              "Name": "sBGRA"
            }
          ]
        },
        {
          "Name": "ImageChannelType",
          "Values": [
            {
              "Value": 4304,
              "Name": "SNORM INT8"
            },
            {
              "Value": 4305,
              "Name": "SNORM INT16"
            },
            {
              "Value": 4306,
              "Name": "UNORM INT8"
            },
            {
              "Value": 4307,
              "Name": "UNORM_INT16"
            },
            {
              "Value": 4308,
              "Name": "UNORM SHORT 565"
            },
            {
              "Value": 4309,
              "Name": "UNORM SHORT 555"
            },
            {
              "Value": 4310,
              "Name": "UNORM INT 101010"
            },
            {
              "Value": 4311,
              "Name": "SIGNED INT8"
            },
            {
              "Value": 4312,
              "Name": "SIGNED INT16"
            },
            {
              "Value": 4313,
              "Name": "SIGNED INT32"
            },
            {
              "Value": 4314,
              "Name": "UNSIGNED INT8"
            },
            {
              "Value": 4315,
              "Name": "UNSIGNED INT16"
            },
            {
              "Value": 4316,
              "Name": "UNSIGNED INT32"
            },
            {
              "Value": 4317,
              "Name": "HALF FLOAT"
            },
            {
              "Value": 4318,
              "Name": "FLOAT"
            },
            {
              "Value": 4319,
              "Name": "UNORM INT24"
            }
          ]
        }
      ]
    },
    {
      "Metadata": {
        "Language": "Open CL",
        "Version": 2.0,
        "Title": "OpenCL 2.0 Extended Instruction Set Specification (Provisional)",
        "Author": "Boaz Ouriel, Intel",
        "Revnumber": "version 0.99, revision 30",
        "LastUpdate": "Last updated 2015-04-02 11:22:36 MDT"
      },
      "ExtendedInstructions": [
        {
          "Name": "Acos",
          "OriginalName": "acos",
          "Description": "Compute the arc cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 0,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Acosh",
          "OriginalName": "acosh",
          "Description": "Compute the inverse hyperbolic cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the inverse hyperbolic cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 1,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Acospi",
          "OriginalName": "acospi",
          "Description": "Compute <em>acos</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute acos(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 2,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Asin",
          "OriginalName": "asin",
          "Description": "Compute the arc sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 3,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Asinh",
          "OriginalName": "asinh",
          "Description": "Compute the inverse hyperbolic sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the inverse hyperbolic sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 4,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Asinpi",
          "OriginalName": "asinpi",
          "Description": "Compute <em>asin</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute asin(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 5,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atan",
          "OriginalName": "atan",
          "Description": "Compute the arc tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 6,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atan2",
          "OriginalName": "atan2",
          "Description": "Compute the arc tangent of <em>y</em> / <em>x</em>.\n<br />\n<em>Result Type</em>,<em>y</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc tangent of y / x.\n\nResult Type,y and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 7,
          "Operands": [
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atanh",
          "OriginalName": "atanh",
          "Description": "Compute the hyperbolic arc tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the hyperbolic arc tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 8,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atanpi",
          "OriginalName": "atanpi",
          "Description": "Compute <em>atan</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute atan(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 9,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atan2pi",
          "OriginalName": "atan2pi",
          "Description": "Compute <em>atan2</em>(<em>y</em>, <em>x</em>) / &#960;.\n<br />\n<em>Result Type</em>,<em>y</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute atan2(y, x) / &#960;.\n\nResult Type,y and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 10,
          "Operands": [
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cbrt",
          "OriginalName": "cbrt",
          "Description": "Compute the cube-root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the cube-root of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 11,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ceil",
          "OriginalName": "ceil",
          "Description": "Round <em>x</em> to integral value using the round to positive infinity rounding mode.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to integral value using the round to positive infinity rounding mode.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 12,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Copysign",
          "OriginalName": "copysign",
          "Description": "Returns <em>x</em> with its sign changed to match the sign of <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns x with its sign changed to match the sign of y.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 13,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cos",
          "OriginalName": "cos",
          "Description": "Compute the cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 14,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cosh",
          "OriginalName": "cosh",
          "Description": "Compute the hyperbolic cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the hyperbolic cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 15,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cospi",
          "OriginalName": "cospi",
          "Description": "Compute <em>cos</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute cos(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 16,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Erfc",
          "OriginalName": "erfc",
          "Description": "Complementary error function of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Complementary error function of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 17,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Erf",
          "OriginalName": "erf",
          "Description": "Error function of <em>x</em> encountered in integrating the normal distribution.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Error function of x encountered in integrating the normal distribution.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 18,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Exp",
          "OriginalName": "exp",
          "Description": "Compute the base-e exponential of <em>x</em>. (i.e. <em>e</em><sup><em>x</em></sup>)\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the base-e exponential of x. (i.e. ex)\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 19,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Exp2",
          "OriginalName": "exp2",
          "Description": "Computes 2 raised to the power of <em>x</em>. (i.e. <em>2</em><sup><em>x</em></sup>)\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes 2 raised to the power of x. (i.e. 2x)\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 20,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Exp10",
          "OriginalName": "exp10",
          "Description": "Computes 10 raised to the power of <em>x</em>. (i.e. <em>10</em><sup><em>x</em></sup>)\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes 10 raised to the power of x. (i.e. 10x)\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 21,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Expm1",
          "OriginalName": "expm1",
          "Description": "Computes <em>e</em><sup><em>x</em></sup> <em>- 1.0</em> .\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes ex - 1.0 .\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 22,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fabs",
          "OriginalName": "fabs",
          "Description": "Compute the absolute value of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the absolute value of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 23,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fdim",
          "OriginalName": "fdim",
          "Description": "Compute <em>x - y</em> if <em>x &gt; y</em>, <em>+0</em> if <em>x</em> is less than or equal to <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute x - y if x &gt; y, +0 if x is less than or equal to y.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 24,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Floor",
          "OriginalName": "floor",
          "Description": "Round <em>x</em> to the integral value using the round to negative infinity rounding mode.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to the integral value using the round to negative infinity rounding mode.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 25,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fma",
          "OriginalName": "fma",
          "Description": "Compute the correctly rounded floating-point representation of the sum of <em>c</em> with the infinitely precise product of <em>a</em> and <em>b</em>.Rounding of intermediate products shall not occur. Edge case behavior is per the IEEE 754-2008 standard.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the correctly rounded floating-point representation of the sum of c with the infinitely precise product of a and b.Rounding of intermediate products shall not occur. Edge case behavior is per the IEEE 754-2008 standard.\n\nResult Type,a,b and c must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 26,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmax",
          "OriginalName": "fmax",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>. If one argument is a NaN, <em>Fmax</em> returns the other argument.  If both arguments are NaNs, <em>Fmax</em> returns a NaN.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> fmax behave as defined by C99 and may not match the IEEE 754-2008 definition for maxNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x. If one argument is a NaN, Fmax returns the other argument.  If both arguments are NaNs, Fmax returns a NaN.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: fmax behave as defined by C99 and may not match the IEEE 754-2008 definition for maxNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "Category": "MathExtendedInstructions",
          "Number": 27,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmin",
          "OriginalName": "fmin",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>. If one argument is a NaN, <em>Fmin</em> returns the other argument.  If both arguments are NaNs, <em>Fmin</em> returns a NaN.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> fmin behave as defined by C99 and may not match the IEEE 754-2008 definition for minNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x. If one argument is a NaN, Fmin returns the other argument.  If both arguments are NaNs, Fmin returns a NaN.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: fmin behave as defined by C99 and may not match the IEEE 754-2008 definition for minNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "Category": "MathExtendedInstructions",
          "Number": 28,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmod",
          "OriginalName": "fmod",
          "Description": "Modulus. Returns <em>x</em> - <em>y</em> * <em>trunc</em> (<em>x</em>/<em>y</em>).\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Modulus. Returns x - y * trunc (x/y).\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 29,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fract",
          "OriginalName": "fract",
          "Description": "Returns <em>fmin</em>( <em>x</em> - <em>floor</em>(<em>x</em>), 0x1.fffffep-1f. <em>floor</em>(<em>x</em>) is returned in <em>ptr</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>ptr</em> must be a <em>pointer</em>(<em>generic</em>) to <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type, or must be a pointer to the same type.<br />",
          "DescriptionPlain": "Returns fmin( x - floor(x), 0x1.fffffep-1f. floor(x) is returned in ptr.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nptr must be a pointer(generic) to floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type, or must be a pointer to the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 30,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "ptr",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Frexp",
          "OriginalName": "frexp",
          "Description": "Extract the mantissa and exponent from <em>x</em>. The <em>Result Type</em> holds the mantissa, and <em>exp</em> points to the exponent. For each component the mantissa returned is a <em>floating-point</em> with magnitude in the interval [1/2, 1) or 0.  Each component of <em>x</em> equals mantissa returned * 2<sup>exp</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>exp</em> must be a <em>pointer</em>(<em>generic</em>) to <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>exp</em> operand must point to an <em>i32</em> with the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Extract the mantissa and exponent from x. The Result Type holds the mantissa, and exp points to the exponent. For each component the mantissa returned is a floating-point with magnitude in the interval [1/2, 1) or 0.  Each component of x equals mantissa returned * 2exp.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nexp must be a pointer(generic) to i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x operands must be of the same type. exp operand must point to an i32 with the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 31,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "exp",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Hypot",
          "OriginalName": "hypot",
          "Description": "Compute the value of the square root of <em>x</em><sup>2</sup>+ <em>y</em><sup>2</sup> without undue overflow or underflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the value of the square root of x2+ y2 without undue overflow or underflow.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 32,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ilogb",
          "OriginalName": "ilogb",
          "Description": "Return the exponent of <em>x</em> as an <em>i32</em> value.\n<br />\n<em>Result Type</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must have the same component count.<br />",
          "DescriptionPlain": "Return the exponent of x as an i32 value.\n\nResult Type must be i32 or vector(2,3,4,8,16) of i32 values. \nx must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must have the same component count.",
          "Category": "MathExtendedInstructions",
          "Number": 33,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ldexp",
          "OriginalName": "ldexp",
          "Description": "Multiply <em>x</em> by 2 to the power <em>k</em>.\n<br />\n<em>k</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>exp</em> operand must have the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Multiply x by 2 to the power k.\n\nk must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must be of the same type. exp operand must have the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 34,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "k",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Lgamma",
          "OriginalName": "lgamma",
          "Description": "Log gamma function of <em>x</em>. Returns the natural logarithm of the absolute value of the gamma function.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Log gamma function of x. Returns the natural logarithm of the absolute value of the gamma function.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 35,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Lgamma_r",
          "OriginalName": "lgamma_r",
          "Description": "Log gamma function of <em>x</em>. Returns the natural logarithm of the absolute value of the gamma function. The sign of the gamma function is returned in the <em>signp</em> operand\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>singp</em> must be a <em>pointer</em>(<em>generic</em>) to <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>singp</em> operand must point to an <em>i32</em> with the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Log gamma function of x. Returns the natural logarithm of the absolute value of the gamma function. The sign of the gamma function is returned in the signp operand\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nsingp must be a pointer(generic) to i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x operands must be of the same type. singp operand must point to an i32 with the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 36,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "singp",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log",
          "OriginalName": "log",
          "Description": "Compute natural logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute natural logarithm of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 37,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log2",
          "OriginalName": "log2",
          "Description": "Compute a base 2 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute a base 2 logarithm of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 38,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log10",
          "OriginalName": "log10",
          "Description": "Compute a base 10 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute a base 10 logarithm of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 39,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log1p",
          "OriginalName": "log1p",
          "Description": "Compute log<sub>e</sub>(1.0 + <em>x</em>).\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute loge(1.0 + x).\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 40,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Logb",
          "OriginalName": "logb",
          "Description": "Compute the exponent of <em>x</em>, which is the integral part of log<sub>r</sub>  | <em>x</em> |.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the exponent of x, which is the integral part of logr  | x |.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 41,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Mad",
          "OriginalName": "mad",
          "Description": "mad approximates <em>a</em> * <em>b</em> + <em>c</em>. Whether or how the product of <em>a</em> * <em>b</em> is rounded and how supernormal or subnormal intermediate products are handled is not defined.  mad is intended to be used where speed is preferred over accuracy\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> For some usages, e.g.mad(<em>a</em>, <em>b</em>, -<em>a</em>*<em>b</em>), the definition of mad() is loose enough that almost any result is allowed from mad() for some values of <em>a</em> and <em>b</em>.",
          "DescriptionPlain": "mad approximates a * b + c. Whether or how the product of a * b is rounded and how supernormal or subnormal intermediate products are handled is not defined.  mad is intended to be used where speed is preferred over accuracy\n\nResult Type,a,b and c must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: For some usages, e.g.mad(a, b, -a*b), the definition of mad() is loose enough that almost any result is allowed from mad() for some values of a and b.",
          "Category": "MathExtendedInstructions",
          "Number": 42,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Maxmag",
          "OriginalName": "maxmag",
          "Description": "Returns <em>x</em> if | <em>x</em> | &gt; | <em>y</em> | , <em>y</em> if | <em>y</em> | &gt; | <em>x</em> | , otherwise <em>fmax</em>(<em>x</em>, <em>y</em>).\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns x if | x | &gt; | y | , y if | y | &gt; | x | , otherwise fmax(x, y).\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 43,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Minmag",
          "OriginalName": "minmag",
          "Description": "Returns <em>x</em> if | <em>x</em> | &lt; | <em>y</em> |, <em>y</em> if | <em>y</em> | &lt; | <em>x</em> |, otherwise <em>fmin</em>(<em>x</em>, <em>y</em>).\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns x if | x | &lt; | y |, y if | y | &lt; | x |, otherwise fmin(x, y).\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 44,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Modf",
          "OriginalName": "modf",
          "Description": "Decompose a <em>floating-point</em> number. The modf function breaks the argument <em>x</em> into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part in the object pointed to by <em>iptr</em>\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>iptr</em> must be a <em>pointer</em>(<em>generic</em>) to <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type, or must be a pointer to the same type.<br />",
          "DescriptionPlain": "Decompose a floating-point number. The modf function breaks the argument x into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part in the object pointed to by iptr\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \niptr must be a pointer(generic) to floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type, or must be a pointer to the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 45,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "iptr",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Nan",
          "OriginalName": "nan",
          "Description": "Returns a quiet NaN. The <em>nancode</em> may be placed in the significand of the resulting NaN.\n<br />\n<em>nancode</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>nancode</em> operands must have the same component count.<br />",
          "DescriptionPlain": "Returns a quiet NaN. The nancode may be placed in the significand of the resulting NaN.\n\nnancode must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and nancode operands must have the same component count.",
          "Category": "MathExtendedInstructions",
          "Number": 46,
          "Operands": [
            {
              "Name": "nancode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Nextafter",
          "OriginalName": "nextafter",
          "Description": "Computes the next representable <em>floating-point</em> value following <em>x</em> in the direction of <em>y</em>. Thus, if <em>y</em> is less than <em>x</em>, <em>nextafter</em>() returns the largest representable floating-point number less than <em>x</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes the next representable floating-point value following x in the direction of y. Thus, if y is less than x, nextafter() returns the largest representable floating-point number less than x.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 47,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Pow",
          "OriginalName": "pow",
          "Description": "Compute <em>x</em> to the power <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute x to the power y.\n\nResult Type,x,y and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 48,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Pown",
          "OriginalName": "pown",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>y</em> is an <em>i32</em> integer.\n<br />\n<em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>y</em> operand must have the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Compute x to the power y, where y is an i32 integer.\n\ny must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must be of the same type. y operand must have the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 49,
          "Operands": [
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Powr",
          "OriginalName": "powr",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>y</em> is an integer.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute x to the power y, where y is an integer.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 50,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Remainder",
          "OriginalName": "remainder",
          "Description": "Compute the value r such that r = <em>x</em> - n*<em>y</em>, where n is the integer nearest the exact value of <em>x</em>/<em>y</em>. If there are two integers closest to <em>x</em>/<em>y</em>, n shall be the even one. If r is zero, it is given the same sign as <em>x</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the value r such that r = x - n*y, where n is the integer nearest the exact value of x/y. If there are two integers closest to x/y, n shall be the even one. If r is zero, it is given the same sign as x.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 51,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Remquo",
          "OriginalName": "remquo",
          "Description": "The remquo function computes the value r such that r = <em>x</em> - k*<em>y</em>, where k is the integer nearest the exact value of <em>x</em>/<em>y</em>.  If there are two integers closest to <em>x</em>/<em>y</em>, k shall be the even one. If r is zero, it is given the same sign as <em>x</em>.  This is the same value that is returned by the <em>remainder</em> function. remquo also calculates the lower seven bits of the integral quotient <em>x</em>/<em>y</em>, and gives that value the same sign as <em>x</em>/<em>y</em>. It stores this signed value in the object pointed to by <em>quo</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>quo</em> must be a <em>pointer</em>(<em>generic</em>) to <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em>, <em>x</em> and <em>y</em> operands must be of the same type. <em>quo</em> operand must point to an <em>i32</em> with the same component count as <em>Result Type</em>, <em>x</em> and <em>y</em> operands.<br />",
          "DescriptionPlain": "The remquo function computes the value r such that r = x - k*y, where k is the integer nearest the exact value of x/y.  If there are two integers closest to x/y, k shall be the even one. If r is zero, it is given the same sign as x.  This is the same value that is returned by the remainder function. remquo also calculates the lower seven bits of the integral quotient x/y, and gives that value the same sign as x/y. It stores this signed value in the object pointed to by quo.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nquo must be a pointer(generic) to i32 or vector(2,3,4,8,16) of i32 values. \nResult Type, x and y operands must be of the same type. quo operand must point to an i32 with the same component count as Result Type, x and y operands.",
          "Category": "MathExtendedInstructions",
          "Number": 52,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "quo",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rint",
          "OriginalName": "rint",
          "Description": "Round <em>x</em> to integral value (using round to nearest even rounding mode) in floating-point format.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to integral value (using round to nearest even rounding mode) in floating-point format.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 53,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rootn",
          "OriginalName": "rootn",
          "Description": "Compute <em>x</em> to the power 1/<em>y</em>.\n<br />\n<em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>y</em> operand must have the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Compute x to the power 1/y.\n\ny must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must be of the same type. y operand must have the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 54,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Round",
          "OriginalName": "round",
          "Description": "Return the integral value nearest to <em>x</em> rounding halfway cases away from zero, regardless of the current rounding direction.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Return the integral value nearest to x rounding halfway cases away from zero, regardless of the current rounding direction.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 55,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rsqrt",
          "OriginalName": "rsqrt",
          "Description": "Compute inverse square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute inverse square root of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 56,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sin",
          "OriginalName": "sin",
          "Description": "Compute sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 57,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sincos",
          "OriginalName": "sincos",
          "Description": "Compute sine and cosine of <em>x</em>. The computed sine is the return value and computed cosine is returned in <em>cosval</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>cosval</em> must be a <em>pointer</em>(<em>generic</em>) to <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type, or must be a pointer to the same type.<br />",
          "DescriptionPlain": "Compute sine and cosine of x. The computed sine is the return value and computed cosine is returned in cosval.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \ncosval must be a pointer(generic) to floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type, or must be a pointer to the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 58,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "cosval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sinh",
          "OriginalName": "sinh",
          "Description": "Compute hyperbolic sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute hyperbolic sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 59,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sinpi",
          "OriginalName": "sinpi",
          "Description": "Compute <em>sin</em> (&#960; x).\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute sin (&#960; x).\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 60,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sqrt",
          "OriginalName": "sqrt",
          "Description": "Compute square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute square root of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 61,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tan",
          "OriginalName": "tan",
          "Description": "Compute tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 62,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tanh",
          "OriginalName": "tanh",
          "Description": "Compute hyperbolic tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute hyperbolic tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 63,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tanpi",
          "OriginalName": "tanpi",
          "Description": "Compute <em>tan</em> (&#960; x).\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute tan (&#960; x).\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 64,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tgamma",
          "OriginalName": "tgamma",
          "Description": "Compute the gamma function of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the gamma function of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 65,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Trunc",
          "OriginalName": "trunc",
          "Description": "Round <em>x</em> to integral value using the round to zero rounding mode.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to integral value using the round to zero rounding mode.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 66,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_cos",
          "OriginalName": "half_cos",
          "Description": "Compute cosine of <em>x</em>, where <em>x</em> must be in the range -2<sup>16</sup> &#8230; +2<sup>16</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute cosine of x, where x must be in the range -216 &#8230; +216.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 67,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_divide",
          "OriginalName": "half_divide",
          "Description": "Compute <em>x</em> / <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute x / y.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 68,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_exp",
          "OriginalName": "half_exp",
          "Description": "Compute the base-e exponential of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the base-e exponential of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 69,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_exp2",
          "OriginalName": "half_exp2",
          "Description": "Compute the base- 2 exponential of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the base- 2 exponential of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 70,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_exp10",
          "OriginalName": "half_exp10",
          "Description": "Compute the base- 10 exponential of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the base- 10 exponential of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 71,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_log",
          "OriginalName": "half_log",
          "Description": "Compute natural logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute natural logarithm of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 72,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_log2",
          "OriginalName": "half_log2",
          "Description": "Compute a base 2 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute a base 2 logarithm of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 73,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_log10",
          "OriginalName": "half_log10",
          "Description": "Compute a base 10 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute a base 10 logarithm of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 74,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_powr",
          "OriginalName": "half_powr",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>x</em> is &gt;= 0.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute x to the power y, where x is &gt;= 0.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 75,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_recip",
          "OriginalName": "half_recip",
          "Description": "Compute reciprocal of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute reciprocal of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 76,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_rsqrt",
          "OriginalName": "half_rsqrt",
          "Description": "Compute inverse square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute inverse square root of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 77,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_sin",
          "OriginalName": "half_sin",
          "Description": "Compute sine of <em>x</em>, where <em>x</em> must be in the range -2<sup>16</sup> &#8230; +2<sup>16</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute sine of x, where x must be in the range -216 &#8230; +216.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 78,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_sqrt",
          "OriginalName": "half_sqrt",
          "Description": "Compute the square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the square root of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 79,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_tan",
          "OriginalName": "half_tan",
          "Description": "Compute tangent value of <em>x</em>, where <em>x</em> must be in the range -2<sup>16</sup> &#8230; +2<sup>16</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute tangent value of x, where x must be in the range -216 &#8230; +216.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 80,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_cos",
          "OriginalName": "native_cos",
          "Description": "Compute cosine of <em>x</em> over an implementation-defined range. The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute cosine of x over an implementation-defined range. The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 81,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_divide",
          "OriginalName": "native_divide",
          "Description": "Compute <em>x</em> / <em>y</em> over an implementation-defined range. The maximum error is implementation-defined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute x / y over an implementation-defined range. The maximum error is implementation-defined.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 82,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_exp",
          "OriginalName": "native_exp",
          "Description": "Compute the base-e exponential of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the base-e exponential of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 83,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_exp2",
          "OriginalName": "native_exp2",
          "Description": "Compute the base- 2 exponential of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined..\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the base- 2 exponential of x over an implementation-defined range.  The maximum error is implementation-defined..\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 84,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_exp10",
          "OriginalName": "native_exp10",
          "Description": "Compute the base- 10 exponential of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined..\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the base- 10 exponential of x over an implementation-defined range.  The maximum error is implementation-defined..\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 85,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_log",
          "OriginalName": "native_log",
          "Description": "Compute natural logarithm of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute natural logarithm of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 86,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_log2",
          "OriginalName": "native_log2",
          "Description": "Compute a base 2 logarithm of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute a base 2 logarithm of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 87,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_log10",
          "OriginalName": "native_log10",
          "Description": "Compute a base 10 logarithm of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute a base 10 logarithm of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 88,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_powr",
          "OriginalName": "native_powr",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>x</em> is &gt;= 0.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute x to the power y, where x is &gt;= 0.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 89,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_recip",
          "OriginalName": "native_recip",
          "Description": "Compute reciprocal of <em>x</em> over an implementation-defined range. The range of x and y are implementation-defined. The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute reciprocal of x over an implementation-defined range. The range of x and y are implementation-defined. The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 90,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_rsqrt",
          "OriginalName": "native_rsqrt",
          "Description": "Compute inverse square root of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute inverse square root of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 91,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_sin",
          "OriginalName": "native_sin",
          "Description": "Compute sine of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute sine of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 92,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_sqrt",
          "OriginalName": "native_sqrt",
          "Description": "Compute the square root of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the square root of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 93,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_tan",
          "OriginalName": "native_tan",
          "Description": "Compute tangent value of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute tangent value of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 94,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_abs",
          "OriginalName": "s_abs",
          "Description": "Returns |<em>x</em>|, where <em>x</em> is treated as signed integer.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns |x|, where x is treated as signed integer.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 141,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_abs_diff",
          "OriginalName": "s_abs_diff",
          "Description": "Returns | <em>x</em> - <em>y</em> | without modulo overflow, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns | x - y | without modulo overflow, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 142,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_add_sat",
          "OriginalName": "s_add_sat",
          "Description": "Returns the saturated value of <em>x</em> + <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x + y, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 143,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_add_sat",
          "OriginalName": "u_add_sat",
          "Description": "Returns the saturated value of <em>x</em> + <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x + y, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 144,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_hadd",
          "OriginalName": "s_hadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em>) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as signed integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y) &gt;&gt; 1, where x and y are treated as signed integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 145,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_hadd",
          "OriginalName": "u_hadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em>) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as unsigned integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y) &gt;&gt; 1, where x and y are treated as unsigned integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 146,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_rhadd",
          "OriginalName": "s_rhadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em> + 1) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as signed integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y + 1) &gt;&gt; 1, where x and y are treated as signed integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 147,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_rhadd",
          "OriginalName": "u_rhadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em> + 1) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as unsigned integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y + 1) &gt;&gt; 1, where x and y are treated as unsigned integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 148,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_clamp",
          "OriginalName": "s_clamp",
          "Description": "Returns <em>s_min</em>(<em>s_max</em>(<em>x</em>,<em>minval</em>),<em>maxval</em>). Results are undefined if <em>minval</em> &gt; <em>maxval</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>minval</em> and <em>maxval</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns s_min(s_max(x,minval),maxval). Results are undefined if minval &gt; maxval.\n\nResult Type,x,minval and maxval must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 149,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "minval",
              "Tpe": "ID"
            },
            {
              "Name": "maxval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_clamp",
          "OriginalName": "u_clamp",
          "Description": "Returns <em>u_min</em>(<em>u_max</em>(<em>x</em>,<em>minval</em>),<em>maxval</em>). Results are undefined if <em>minval</em> &gt; <em>maxval</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>minval</em> and <em>maxval</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns u_min(u_max(x,minval),maxval). Results are undefined if minval &gt; maxval.\n\nResult Type,x,minval and maxval must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 150,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "minval",
              "Tpe": "ID"
            },
            {
              "Name": "maxval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Clz",
          "OriginalName": "clz",
          "Description": "Returns the number of leading 0-bits in <em>x</em>, starting at the most significant bit position. If <em>x</em> is 0, returns the size in bits of the type of <em>x</em> or component type of <em>x</em>, if <em>x</em> is a vector.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, returns the size in bits of the type of x or component type of x, if x is a vector.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 151,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ctz",
          "OriginalName": "ctz",
          "Description": "Returns the count of trailing 0-bits in <em>x</em>. If <em>x</em> is 0, returns the size in bits of the type of <em>x</em> or component type of <em>x</em>, if <em>x</em> is a vector.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the count of trailing 0-bits in x. If x is 0, returns the size in bits of the type of x or component type of x, if x is a vector.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 152,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mad_hi",
          "OriginalName": "s_mad_hi",
          "Description": "Returns <em>mul_hi</em>(<em>a</em>, <em>b</em>) + <em>c</em>, where <em>a</em>,<em>b</em> and <em>c</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns mul_hi(a, b) + c, where a,b and c are treated as signed integers.\n\nResult Type,a,b and c must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 153,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_max",
          "OriginalName": "s_max",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 156,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_max",
          "OriginalName": "u_max",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 157,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_min",
          "OriginalName": "s_min",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 158,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_min",
          "OriginalName": "u_min",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 159,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mul_hi",
          "OriginalName": "s_mul_hi",
          "Description": "Computes <em>x</em> * <em>y</em> and returns the high half of the product of <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes x * y and returns the high half of the product of x and y, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 160,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rotate",
          "OriginalName": "rotate",
          "Description": "For each element in <em>v</em>, the bits are shifted left by the number of bits given by the corresponding element in <em>i</em>. Bits shifted off the left side of the element are shifted back in from the right.\n<br />\n<em>Result Type</em>,<em>v</em> and <em>i</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "For each element in v, the bits are shifted left by the number of bits given by the corresponding element in i. Bits shifted off the left side of the element are shifted back in from the right.\n\nResult Type,v and i must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 161,
          "Operands": [
            {
              "Name": "v",
              "Tpe": "ID"
            },
            {
              "Name": "i",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_sub_sat",
          "OriginalName": "s_sub_sat",
          "Description": "Returns the saturated value of <em>x</em> - <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x - y, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 162,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_sub_sat",
          "OriginalName": "u_sub_sat",
          "Description": "Returns the saturated value of <em>x</em> - <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x - y, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 163,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_upsample",
          "OriginalName": "u_upsample",
          "Description": "When <em>hi</em> and <em>lo</em> component type is i8:<br />\nResult = ((upcast&#8230;to i16)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component type is i16:<br />\nResult = ((upcast&#8230;to i32)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component i32:<br />\nResult = ((upcast&#8230;to i64)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\n<em>hi</em> and <em>lo</em> are treated as unsigned integers.\n<br />\n<em>hi</em> and <em>lo</em> must be <em>i8</em>, <em>i16</em> or <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i8</em>, <em>i16</em> or <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>i16</em>, <em>i32</em> or <em>i64</em> or <em>vector(2,3,4,8,16)</em> of <em>i16</em>, <em>i32</em> or <em>i64</em> values. <br />\n<em>hi</em> and <em>lo</em> operands must be of the same type. When <em>hi</em> and <em>lo</em> component type is i8, the <em>Result Type</em> component type must be i16. When <em>hi</em> and <em>lo</em> component type is i16, the <em>Result Type</em> component type must be i32. When <em>hi</em> and <em>lo</em> component type is i32, the <em>Result Type</em> component type must be i64. <em>Result Type</em> must have the same component count as <em>hi</em> and <em>lo</em> operands.<br />",
          "DescriptionPlain": "When hi and lo component type is i8:\nResult = ((upcast&#8230;to i16)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component type is i16:\nResult = ((upcast&#8230;to i32)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component i32:\nResult = ((upcast&#8230;to i64)hi &lt;&lt; 8) | lo\n\nhi and lo are treated as unsigned integers.\n\nhi and lo must be i8, i16 or i32 or vector(2,3,4,8,16) of i8, i16 or i32 values. \nResult Type must be i16, i32 or i64 or vector(2,3,4,8,16) of i16, i32 or i64 values. \nhi and lo operands must be of the same type. When hi and lo component type is i8, the Result Type component type must be i16. When hi and lo component type is i16, the Result Type component type must be i32. When hi and lo component type is i32, the Result Type component type must be i64. Result Type must have the same component count as hi and lo operands.",
          "Category": "IntegerInstructions",
          "Number": 164,
          "Operands": [
            {
              "Name": "hi",
              "Tpe": "ID"
            },
            {
              "Name": "lo",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_upsample",
          "OriginalName": "s_upsample",
          "Description": "When <em>hi</em> and <em>lo</em> component type is i8:<br />\nResult = ((upcast&#8230;to i16)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component type is i16:<br />\nResult = ((upcast&#8230;to i32)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component i32:<br />\nResult = ((upcast&#8230;to i64)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\n<em>hi</em> and <em>lo</em> are treated as signed integers.\n<br />\n<em>hi</em> and <em>lo</em> must be <em>i8</em>, <em>i16</em> or <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i8</em>, <em>i16</em> or <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>i16</em>, <em>i32</em> or <em>i64</em> or <em>vector(2,3,4,8,16)</em> of <em>i16</em>, <em>i32</em> or <em>i64</em> values. <br />\n<em>hi</em> and <em>lo</em> operands must be of the same type. When <em>hi</em> and <em>lo</em> component type is i8, the <em>Result Type</em> component type must be i16. When <em>hi</em> and <em>lo</em> component type is i16, the <em>Result Type</em> component type must be i32. When <em>hi</em> and <em>lo</em> component type is i32, the <em>Result Type</em> component type must be i64. <em>Result Type</em> must have the same component count as <em>hi</em> and <em>lo</em> operands.<br />",
          "DescriptionPlain": "When hi and lo component type is i8:\nResult = ((upcast&#8230;to i16)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component type is i16:\nResult = ((upcast&#8230;to i32)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component i32:\nResult = ((upcast&#8230;to i64)hi &lt;&lt; 8) | lo\n\nhi and lo are treated as signed integers.\n\nhi and lo must be i8, i16 or i32 or vector(2,3,4,8,16) of i8, i16 or i32 values. \nResult Type must be i16, i32 or i64 or vector(2,3,4,8,16) of i16, i32 or i64 values. \nhi and lo operands must be of the same type. When hi and lo component type is i8, the Result Type component type must be i16. When hi and lo component type is i16, the Result Type component type must be i32. When hi and lo component type is i32, the Result Type component type must be i64. Result Type must have the same component count as hi and lo operands.",
          "Category": "IntegerInstructions",
          "Number": 165,
          "Operands": [
            {
              "Name": "hi",
              "Tpe": "ID"
            },
            {
              "Name": "lo",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Popcount",
          "OriginalName": "popcount",
          "Description": "Returns the number of non-zero bits in <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the number of non-zero bits in x.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 166,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mad24",
          "OriginalName": "s_mad24",
          "Description": "Multipy two 24-bit integer values <em>x</em> and <em>y</em> and add the 32-bit integer result to the 32-bit integer <em>z</em>. Refer to definition of s_mul24 to see how the 24-bit integer multiplication is performed.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>z</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multipy two 24-bit integer values x and y and add the 32-bit integer result to the 32-bit integer z. Refer to definition of s_mul24 to see how the 24-bit integer multiplication is performed.\n\nResult Type,x,y and z must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 167,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "z",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mad24",
          "OriginalName": "u_mad24",
          "Description": "Multipy two 24-bit integer values <em>x</em> and <em>y</em> and add the 32-bit integer result to the 32-bit integer <em>z</em>. Refer to definition of u_mul24 to see how the 24-bit integer multiplication is performed.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>z</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multipy two 24-bit integer values x and y and add the 32-bit integer result to the 32-bit integer z. Refer to definition of u_mul24 to see how the 24-bit integer multiplication is performed.\n\nResult Type,x,y and z must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 168,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "z",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mul24",
          "OriginalName": "s_mul24",
          "Description": "Multiply two 24-bit integer values <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers. <em>x</em> and <em>y</em> are 32-bit integers but only the low 24-bits are used to perform the multiplication. s_mul24 should only be used when values in <em>x</em> and <em>y</em> are in the range [-2<sup>23</sup>, 2<sup>23</sup>-1]. If <em>x</em> and <em>y</em> are not in this range, the multiplication result is implementation-defined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multiply two 24-bit integer values x and y, where x and y are treated as signed integers. x and y are 32-bit integers but only the low 24-bits are used to perform the multiplication. s_mul24 should only be used when values in x and y are in the range [-223, 223-1]. If x and y are not in this range, the multiplication result is implementation-defined.\n\nResult Type,x and y must be i32 or vector(2,3,4,8,16) of i32 values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 169,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mul24",
          "OriginalName": "u_mul24",
          "Description": "Multiply two 24-bit integer values <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers. <em>x</em> and <em>y</em> are 32-bit integers but only the low 24-bits are used to perform the multiplication. u_mul24 should only be used when values in <em>x</em> and <em>y</em> are in the range [0, 2<sup>24</sup>-1]. If <em>x</em> and <em>y</em> are not in this range, the multiplication result is implementation-defined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multiply two 24-bit integer values x and y, where x and y are treated as unsigned integers. x and y are 32-bit integers but only the low 24-bits are used to perform the multiplication. u_mul24 should only be used when values in x and y are in the range [0, 224-1]. If x and y are not in this range, the multiplication result is implementation-defined.\n\nResult Type,x and y must be i32 or vector(2,3,4,8,16) of i32 values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 170,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_abs",
          "OriginalName": "u_abs",
          "Description": "Returns |<em>x</em>|, where <em>x</em> is treated as unsigned integer.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns |x|, where x is treated as unsigned integer.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 201,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_abs_diff",
          "OriginalName": "u_abs_diff",
          "Description": "Returns | <em>x</em> - <em>y</em> | without modulo overflow, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns | x - y | without modulo overflow, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 202,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mul_hi",
          "OriginalName": "u_mul_hi",
          "Description": "Computes <em>x</em> * <em>y</em> and returns the high half of the product of <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes x * y and returns the high half of the product of x and y, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 203,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mad_hi",
          "OriginalName": "u_mad_hi",
          "Description": "Returns <em>mul_hi</em>(<em>a</em>, <em>b</em>) + <em>c</em>, where <em>a</em>,<em>b</em> and <em>c</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns mul_hi(a, b) + c, where a,b and c are treated as unsigned integers.\n\nResult Type,a,b and c must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 204,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fclamp",
          "OriginalName": "fclamp",
          "Description": "Returns <em>fmin</em>(<em>fmax</em>(<em>x</em>, <em>minval</em>), <em>maxval</em>). Results are undefined if <em>minval</em> &gt; <em>maxval</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>minval</em> and <em>maxval</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns fmin(fmax(x, minval), maxval). Results are undefined if minval &gt; maxval.\n\nResult Type,x,minval and maxval must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 95,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "minval",
              "Tpe": "ID"
            },
            {
              "Name": "maxval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Degrees",
          "OriginalName": "degrees",
          "Description": "Converts <em>radians</em> to degrees, i.e. (180 / &#960;) * <em>radians</em>.\n<br />\n<em>Result Type</em> and <em>radians</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Converts radians to degrees, i.e. (180 / &#960;) * radians.\n\nResult Type and radians must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 96,
          "Operands": [
            {
              "Name": "radians",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmax_common",
          "OriginalName": "fmax_common",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>. If x or y are infinite or NaN, the return values are undefined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x. If x or y are infinite or NaN, the return values are undefined.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 97,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmin_common",
          "OriginalName": "fmin_common",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>. If x or y are infinite or NaN, the return values are undefined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x. If x or y are infinite or NaN, the return values are undefined.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 98,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Mix",
          "OriginalName": "mix",
          "Description": "Returns the linear blend of <em>x</em> &amp; <em>y</em> implemented as:<br />\n<em>x</em> + (<em>y</em> - <em>x</em>) * <em>a</em>\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>a</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> This function can be implemented using contractions such as mad or fma<br />",
          "DescriptionPlain": "Returns the linear blend of x &amp; y implemented as:\nx + (y - x) * a\n\nResult Type,x,y and a must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: This function can be implemented using contractions such as mad or fma",
          "Category": "CommonInstructions",
          "Number": 99,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "a",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Radians",
          "OriginalName": "radians",
          "Description": "Converts <em>degrees</em> to radians, i.e. (&#960; / 180) * <em>degrees</em>.\n<br />\n<em>Result Type</em> and <em>degrees</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Converts degrees to radians, i.e. (&#960; / 180) * degrees.\n\nResult Type and degrees must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 100,
          "Operands": [
            {
              "Name": "degrees",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Step",
          "OriginalName": "step",
          "Description": "Returns 0.0 if <em>x</em> &lt; <em>edge</em>, otherwise it returns 1.0.\n<br />\n<em>Result Type</em>,<em>edge</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns 0.0 if x &lt; edge, otherwise it returns 1.0.\n\nResult Type,edge and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 101,
          "Operands": [
            {
              "Name": "edge",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Smoothstep",
          "OriginalName": "smoothstep",
          "Description": "Returns 0.0 if <em>x</em> &#8656; <em>edge<sub>0</sub></em> and 1.0 if <em>x</em> &gt;= <em>edge<sub>1</sub></em> and performs smooth Hermite interpolation between 0 and 1, when <em>edge<sub>0</sub></em> &lt; x &lt; <em>edge<sub>1</sub></em>.<br />\n<br />\n This is equivalent to :<br />\n t = <em>fclamp</em>((<em>x</em> - <em>edge<sub>0</sub></em>) / (<em>edge<sub>1</sub></em> - <em>edge<sub>0</sub></em>), 0, 1);<br />\n return t * t * (3 - 2 * t);<br />\n<br />\nResults are undefined if <em>edge<sub>0</sub></em> &gt;= <em>edge<sub>1</sub></em> or if <em>x</em>, <em>edge<sub>0</sub></em> or <em>edge<sub>1</sub></em> is a NaN.\n<br />\n<em>Result Type</em>,<em>edge<sub>0</sub></em>,<em>edge<sub>1</sub></em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> This function can be implemented using contractions such as mad or fma<br />",
          "DescriptionPlain": "Returns 0.0 if x &#8656; edge0 and 1.0 if x &gt;= edge1 and performs smooth Hermite interpolation between 0 and 1, when edge0 &lt; x &lt; edge1.\n\n This is equivalent to :\n t = fclamp((x - edge0) / (edge1 - edge0), 0, 1);\n return t * t * (3 - 2 * t);\n\nResults are undefined if edge0 &gt;= edge1 or if x, edge0 or edge1 is a NaN.\n\nResult Type,edge0,edge1 and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: This function can be implemented using contractions such as mad or fma",
          "Category": "CommonInstructions",
          "Number": 102,
          "Operands": [
            {
              "Name": "edge0",
              "Tpe": "ID"
            },
            {
              "Name": "edge1",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sign",
          "OriginalName": "sign",
          "Description": "Returns 1.0 if <em>x</em> &gt; 0, -0.0 if <em>x</em> = -0.0, +0.0 if <em>x</em> = +0.0, or -1.0 if <em>x</em> &lt; 0. Returns 0.0 if <em>x</em> is a NaN.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns 1.0 if x &gt; 0, -0.0 if x = -0.0, +0.0 if x = +0.0, or -1.0 if x &lt; 0. Returns 0.0 if x is a NaN.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 103,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cross",
          "OriginalName": "cross",
          "Description": "Returns the cross product of <em>p<sub>0</sub></em>.xyz and <em>p<sub>1</sub></em>.xyz. <br />\nWhen the vector component count is 4, the w component returned will be 0.0.\n<br />\n<em>Result Type</em>,<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> must be  <em>vector(3,4)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the cross product of p0.xyz and p1.xyz. \nWhen the vector component count is 4, the w component returned will be 0.0.\n\nResult Type,p0 and p1 must be  vector(3,4) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "GeometricInstructions",
          "Number": 104,
          "Operands": [
            {
              "Name": "p0",
              "Tpe": "ID"
            },
            {
              "Name": "p1",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Distance",
          "OriginalName": "distance",
          "Description": "Returns the distance between <em>p<sub>0</sub></em> and <em>p<sub>1</sub></em>.  This is calculated as <em>length</em>(<em>p<sub>0</sub></em> - <em>p<sub>1</sub></em>).\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same type. <em>Result Type</em>, <em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same component type",
          "DescriptionPlain": "Returns the distance between p0 and p1.  This is calculated as length(p0 - p1).\n\nResult Type must be floating-point. \np0 and p1 must be floating-point or vector(2,3,4) of floating-point values. \np0 and p1 operands must have the same type. Result Type, p0 and p1 operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 105,
          "Operands": [
            {
              "Name": "p0",
              "Tpe": "ID"
            },
            {
              "Name": "p1",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Length",
          "OriginalName": "length",
          "Description": "Return the length of vector <em>p</em>, i.e. <em>sqrt</em>( <em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> + &#8230; )\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p</em> must be  <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>p</em> operands must have the same component type",
          "DescriptionPlain": "Return the length of vector p, i.e. sqrt( p.x2 + p.y2 + &#8230; )\n\nResult Type must be floating-point. \np must be  vector(2,3,4) of floating-point values. \nResult Type and p operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 106,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Normalize",
          "OriginalName": "normalize",
          "Description": "Returns a vector in the same direction as <em>p</em> but with a length of 1.\n<br />\n<em>Result Type</em> and <em>p</em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns a vector in the same direction as p but with a length of 1.\n\nResult Type and p must be floating-point or vector(2,3,4) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "GeometricInstructions",
          "Number": 107,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fast_distance",
          "OriginalName": "fast_distance",
          "Description": "Returns <em>fast_length</em>(<em>p<sub>0</sub></em> - <em>p<sub>1</sub></em>).\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same type. <em>Result Type</em>, <em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same component type",
          "DescriptionPlain": "Returns fast_length(p0 - p1).\n\nResult Type must be floating-point. \np0 and p1 must be floating-point or vector(2,3,4) of floating-point values. \np0 and p1 operands must have the same type. Result Type, p0 and p1 operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 108,
          "Operands": [
            {
              "Name": "p0",
              "Tpe": "ID"
            },
            {
              "Name": "p1",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fast_length",
          "OriginalName": "fast_length",
          "Description": "Return the length of vector <em>p</em> computed as: <em>half_sqrt</em>( <em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> + &#8230; )\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p</em> must be  <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>p</em> operands must have the same component type",
          "DescriptionPlain": "Return the length of vector p computed as: half_sqrt( p.x2 + p.y2 + &#8230; )\n\nResult Type must be floating-point. \np must be  vector(2,3,4) of floating-point values. \nResult Type and p operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 109,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fast_normalize",
          "OriginalName": "fast_normalize",
          "Description": "Returns a vector in the same direction as <em>p</em> but with a length of 1 computed as:<br />\n<em>p</em> * <em>half_rsqrt</em>( <em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> &#8230; ) <br />\n<br />\nThe result shall be within 8192 ulps error from the infinitely precise result of:<br />\nif (<em>all</em>( <em>p</em> == 0.0f )) { result = <em>p</em>; }<br />\nelse {  result = <em>p</em> / <em>sqrt</em>(<em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> + &#8230;); }<br />\n<br />\nwith the following exceptions :<br />\n1) If the sum of squares is greater than FLT_MAX then the value of the floating-point values in the result vector are undefined.<br />\n2) If the sum of squares is less than FLT_MIN then the implementation may return back <em>p</em>.<br />\n3) If the device is in \"denorms are flushed to zero\" mode, individual operand elements with magnitude less than <em>sqrt</em>(FLT_MIN) may be flushed to zero before proceeding with the calculation.\n<br />\n<em>Result Type</em> and <em>p</em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns a vector in the same direction as p but with a length of 1 computed as:\np * half_rsqrt( p.x2 + p.y2 &#8230; ) \n\nThe result shall be within 8192 ulps error from the infinitely precise result of:\nif (all( p == 0.0f )) { result = p; }\nelse {  result = p / sqrt(p.x2 + p.y2 + &#8230;); }\n\nwith the following exceptions :\n1) If the sum of squares is greater than FLT_MAX then the value of the floating-point values in the result vector are undefined.\n2) If the sum of squares is less than FLT_MIN then the implementation may return back p.\n3) If the device is in \"denorms are flushed to zero\" mode, individual operand elements with magnitude less than sqrt(FLT_MIN) may be flushed to zero before proceeding with the calculation.\n\nResult Type and p must be floating-point or vector(2,3,4) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "GeometricInstructions",
          "Number": 110,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Bitselect",
          "OriginalName": "bitselect",
          "Description": "Each bit of the result is the corresponding bit of <em>a</em> if the corresponding bit of <em>c</em> is 0.  Otherwise it is the corresponding bit of <em>b</em>.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>floating-point</em> or <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Each bit of the result is the corresponding bit of a if the corresponding bit of c is 0.  Otherwise it is the corresponding bit of b.\n\nResult Type,a,b and c must be floating-point or integer or vector(2,3,4,8,16) of floating-point or integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "RelationalInstructions",
          "Number": 186,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Select",
          "OriginalName": "select",
          "Description": "Each bit of the result is the corresponding bit of <em>a</em> if the corresponding bit of <em>c</em> is 0.  Otherwise it is the corresponding bit of <em>b</em>.\n<br />\n<em>c</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\n<em>Result Type</em>,<em>a</em> and <em>b</em> must be <em>floating-point</em> or <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\n<em>Result Type</em>, <em>a</em> and <em>b</em> must have the same type. <em>c</em> operand must have the same component count and component bit width as the rest of the operands.",
          "DescriptionPlain": "Each bit of the result is the corresponding bit of a if the corresponding bit of c is 0.  Otherwise it is the corresponding bit of b.\n\nc must be integer or vector(2,3,4,8,16) of integer values. \nResult Type,a and b must be floating-point or integer or vector(2,3,4,8,16) of floating-point or integer values. \nResult Type, a and b must have the same type. c operand must have the same component count and component bit width as the rest of the operands.",
          "Category": "RelationalInstructions",
          "Number": 187,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vloadn",
          "OriginalName": "vloadn",
          "Description": "Return a vector value which is read from address (<em>p</em> + (<em>offset</em> * <em>n</em>)). <br />\nThe address computed as (<em>p</em> + (<em>offset</em> * <em>n</em>)) must be 8-bit aligned if <em>p</em> points to i8 value; 16-bit aligned if <em>p</em> points to i16 or half value; 32-bit aligned if <em>p</em> points to i32 or float value; 64-bit aligned if <em>p</em> points to i64 or double value.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>constant</em>, <em>generic</em>) to <em>floating-point</em>, <em>integer</em>. <br />\n<em>Result Type</em> must be  <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\n<em>Result Type</em> component count must be equal to <em>n</em> and its component type must be equal to the type pointed by <em>p</em>.<br />\n<em>n</em> must be 2,3,4,8 or 16.",
          "DescriptionPlain": "Return a vector value which is read from address (p + (offset * n)). \nThe address computed as (p + (offset * n)) must be 8-bit aligned if p points to i8 value; 16-bit aligned if p points to i16 or half value; 32-bit aligned if p points to i32 or float value; 64-bit aligned if p points to i64 or double value.\n\noffset must be size_t. \np must be a pointer(constant, generic) to floating-point, integer. \nResult Type must be  vector(2,3,4,8,16) of floating-point or integer values. \nResult Type component count must be equal to n and its component type must be equal to the type pointed by p.\nn must be 2,3,4,8 or 16.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 171,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "n",
              "Type": "LiteralNumber"
            }
          ]
        },
        {
          "Name": "Vstoren",
          "OriginalName": "vstoren",
          "Description": "Write <em>data</em> vector value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be 8-bit aligned if <em>p</em> points to i8 value; 16-bit aligned if <em>p</em> points to i16 or half value; 32-bit aligned if <em>p</em> points to i32 or float value; 64-bit aligned if <em>p</em> points to i64 or double value.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>floating-point</em>, <em>integer</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\n<em>data</em> component type must be equal to the type pointed by <em>p</em>.",
          "DescriptionPlain": "Write data vector value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be 8-bit aligned if p points to i8 value; 16-bit aligned if p points to i16 or half value; 32-bit aligned if p points to i32 or float value; 64-bit aligned if p points to i64 or double value.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to floating-point, integer. \ndata must be  vector(2,3,4,8,16) of floating-point or integer values. \ndata component type must be equal to the type pointed by p.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 172,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vload_half",
          "OriginalName": "vload_half",
          "Description": "Reads a half value from the address (<em>p</em> + (<em>offset</em>)) and converts it to a float return value. The address computed as (<em>p</em> + (<em>offset</em>)) must be 16-bit aligned.\n<br />\n<em>Result Type</em> must be <em>float</em>. <br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>constant</em>, <em>generic</em>) to <em>half</em>. <br />",
          "DescriptionPlain": "Reads a half value from the address (p + (offset)) and converts it to a float return value. The address computed as (p + (offset)) must be 16-bit aligned.\n\nResult Type must be float. \noffset must be size_t. \np must be a pointer(constant, generic) to half. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 173,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vload_halfn",
          "OriginalName": "vload_halfn",
          "Description": "Reads a half vector value from the address (<em>p</em> + (<em>offset</em> * <em>n</em>)) and converts it to a float vector return value. The address computed as (<em>p</em> + (<em>offset</em> * <em>n</em>)) must be 16-bit aligned.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>constant</em>, <em>generic</em>) to <em>half</em>. <br />\n<em>Result Type</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\n<em>Result Type</em> component count must be equal to <em>n</em>.<br />\n<em>n</em> must be 2,3,4,8 or 16.",
          "DescriptionPlain": "Reads a half vector value from the address (p + (offset * n)) and converts it to a float vector return value. The address computed as (p + (offset * n)) must be 16-bit aligned.\n\noffset must be size_t. \np must be a pointer(constant, generic) to half. \nResult Type must be  vector(2,3,4,8,16) of float values. \nResult Type component count must be equal to n.\nn must be 2,3,4,8 or 16.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 174,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "n",
              "Type": "LiteralNumber"
            }
          ]
        },
        {
          "Name": "Vstore_half",
          "OriginalName": "vstore_half",
          "Description": "Converts <em>data</em> float or double value to a half value and then write the converted value to the address (<em>p</em> + <em>offset</em>). The address computed as (<em>p</em> + <em>offset</em>) must be 16-bit aligned. <br />\nThis function uses the default rounding mode when converting <em>data</em> to a half value. The default rounding mode is round to nearest even.\n<br />\n<em>data</em> must be <em>float</em> or <em>double</em>. <br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />",
          "DescriptionPlain": "Converts data float or double value to a half value and then write the converted value to the address (p + offset). The address computed as (p + offset) must be 16-bit aligned. \nThis function uses the default rounding mode when converting data to a half value. The default rounding mode is round to nearest even.\n\ndata must be float or double. \noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 175,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstore_half_r",
          "OriginalName": "vstore_half_r",
          "Description": "Converts <em>data</em> float or double value to a half value and then write the converted value to the address (<em>p</em> + <em>offset</em>). The address computed as (<em>p</em> + <em>offset</em>) must be 16-bit aligned. <br />\nThis function uses <em>mode</em> rounding mode when converting <em>data</em> to a half value.\n<br />\n<em>data</em> must be <em>float</em> or <em>double</em>. <br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />",
          "DescriptionPlain": "Converts data float or double value to a half value and then write the converted value to the address (p + offset). The address computed as (p + offset) must be 16-bit aligned. \nThis function uses mode rounding mode when converting data to a half value.\n\ndata must be float or double. \noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 176,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "FP Rounding Mode\nmode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstore_halfn",
          "OriginalName": "vstore_halfn",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be 16-bit aligned.<br />\nThis function uses the default rounding mode when converting <em>data</em> to a vector of half values. The default rounding mode is round to nearest even.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be 16-bit aligned.\nThis function uses the default rounding mode when converting data to a vector of half values. The default rounding mode is round to nearest even.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 177,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstore_halfn_r",
          "OriginalName": "vstore_halfn_r",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be 16-bit aligned.<br />\nThis function uses <em>mode</em> rounding mode when converting <em>data</em> to a half value.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be 16-bit aligned.\nThis function uses mode rounding mode when converting data to a half value.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 178,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "FP Rounding Mode\nmode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vloada_halfn",
          "OriginalName": "vloada_halfn",
          "Description": "Reads a half vector value from the address (<em>p</em> + (<em>offset</em> * <em>n</em>)) and converts it to a float vector return value. The address computed as (<em>p</em> + (<em>offset</em> * <em>n</em>)) must be (2 * <em>n</em>) bytes aligned, when n = 2,4,8,16; For <em>n</em> = 3, the function returns a vector of 3 float values from the address (<em>p</em> + (<em>offset</em> * 4)). The address computed as (<em>p</em> + (<em>offset</em> * 4)) must be 8-bytes aligned\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>constant</em>, <em>generic</em>) to <em>half</em>. <br />\n<em>Result Type</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\n<em>Result Type</em> component count must be equal to <em>n</em>.<br />\n<em>n</em> must be 2,3,4,8 or 16.",
          "DescriptionPlain": "Reads a half vector value from the address (p + (offset * n)) and converts it to a float vector return value. The address computed as (p + (offset * n)) must be (2 * n) bytes aligned, when n = 2,4,8,16; For n = 3, the function returns a vector of 3 float values from the address (p + (offset * 4)). The address computed as (p + (offset * 4)) must be 8-bytes aligned\n\noffset must be size_t. \np must be a pointer(constant, generic) to half. \nResult Type must be  vector(2,3,4,8,16) of float values. \nResult Type component count must be equal to n.\nn must be 2,3,4,8 or 16.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 179,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "n",
              "Type": "LiteralNumber"
            }
          ]
        },
        {
          "Name": "Vstorea_halfn",
          "OriginalName": "vstorea_halfn",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be (2 * compCountOf(<em>data</em>)) bytes aligned, when n = 2,4,8,16; For <em>n</em> = 3, the function returns a vector of 3 float values from the address (<em>p</em> + (<em>offset</em> * 4)). The address computed as (<em>p</em> + (<em>offset</em> * 4)) must be 8-bytes aligned.<br />\nThis function uses the default rounding mode when converting <em>data</em> to a vector of half values. The default rounding mode is round to nearest even.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be (2 * compCountOf(data)) bytes aligned, when n = 2,4,8,16; For n = 3, the function returns a vector of 3 float values from the address (p + (offset * 4)). The address computed as (p + (offset * 4)) must be 8-bytes aligned.\nThis function uses the default rounding mode when converting data to a vector of half values. The default rounding mode is round to nearest even.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 180,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstorea_halfn_r",
          "OriginalName": "vstorea_halfn_r",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be (2 * compCountOf(<em>data</em>)) bytes aligned, when n = 2,4,8,16; For <em>n</em> = 3, the function returns a vector of 3 float values from the address (<em>p</em> + (<em>offset</em> * 4)). The address computed as (<em>p</em> + (<em>offset</em> * 4)) must be 8-bytes aligned.<br />\nThis function uses <em>mode</em> rounding mode when converting <em>data</em> to a vector of half values.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be (2 * compCountOf(data)) bytes aligned, when n = 2,4,8,16; For n = 3, the function returns a vector of 3 float values from the address (p + (offset * 4)). The address computed as (p + (offset * 4)) must be 8-bytes aligned.\nThis function uses mode rounding mode when converting data to a vector of half values.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 181,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "FP Rounding Mode\nmode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Shuffle",
          "OriginalName": "shuffle",
          "Description": "Construct a permutation of components from <em>x</em> vector value, returning a vector value with the same component type as <em>x</em> and component component count that is the same as <em>shuffle mask</em>.<br />\nIn this function, only the <em>ilogb</em>(2 <em>m</em> -1) least significant bits of each mask element are considered, where <em>m</em> is equal to the component count of <em>x</em>.<br />\n<em>shuffle mask</em> operand specifies, for each component in the result vector, which component of <em>x</em> it gets.<br />\nThe size of each component in <em>shuffle mask</em> must match the size of each component in <em>Result Type</em>.<br />\n<em>Result Type</em> must have the same component type as <em>x</em> and component count as <em>shuffle mask</em>.\n<br />\n<em>shuffle mask</em> must be  <em>vector(2,4,8,16)</em> of <em>integer</em> values. <br />\n<em>Result Type</em> and <em>x</em> must be  <em>vector(2,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Construct a permutation of components from x vector value, returning a vector value with the same component type as x and component component count that is the same as shuffle mask.\nIn this function, only the ilogb(2 m -1) least significant bits of each mask element are considered, where m is equal to the component count of x.\nshuffle mask operand specifies, for each component in the result vector, which component of x it gets.\nThe size of each component in shuffle mask must match the size of each component in Result Type.\nResult Type must have the same component type as x and component count as shuffle mask.\n\nshuffle mask must be  vector(2,4,8,16) of integer values. \nResult Type and x must be  vector(2,4,8,16) of floating-point or integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MiscellaneousVectorInstructions",
          "Number": 182,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "shuffle mask",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Shuffle2",
          "OriginalName": "shuffle2",
          "Description": "Construct a permutation of components from <em>x</em> and <em>y</em> vector values, returning a vector value with the same component type as <em>x</em> and <em>y</em> and component count that is the same as <em>shuffle mask</em>.<br />\nIn this function, only the <em>ilogb</em>(2 <em>m</em> - 1) + 1 least significant bits of each mask component are considered, where <em>m</em> is equal to the component count of <em>x</em> and <em>y</em>.<br />\n<em>shuffle mask</em> operand specifies, for each component in the result vector, which component of <em>x</em> or <em>y</em> it gets. Where component count begins with <em>x</em> and then proceeds to <em>y</em>.<br />\n<em>x</em> and <em>y</em> must be of the same type.<br />\nThe size of each component in <em>shuffle mask</em> must match the size of each component in <em>Result Type</em>.<br />\n<em>Result Type</em> must have the same component type as <em>x</em> and component count as <em>shuffle mask</em>.\n<br />\n<em>shuffle mask</em> must be  <em>vector(2,4,8,16)</em> of <em>integer</em> values. <br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be  <em>vector(2,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Construct a permutation of components from x and y vector values, returning a vector value with the same component type as x and y and component count that is the same as shuffle mask.\nIn this function, only the ilogb(2 m - 1) + 1 least significant bits of each mask component are considered, where m is equal to the component count of x and y.\nshuffle mask operand specifies, for each component in the result vector, which component of x or y it gets. Where component count begins with x and then proceeds to y.\nx and y must be of the same type.\nThe size of each component in shuffle mask must match the size of each component in Result Type.\nResult Type must have the same component type as x and component count as shuffle mask.\n\nshuffle mask must be  vector(2,4,8,16) of integer values. \nResult Type,x and y must be  vector(2,4,8,16) of floating-point or integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MiscellaneousVectorInstructions",
          "Number": 183,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "shuffle mask",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Printf",
          "OriginalName": "printf",
          "Description": "The <em>printf</em> extended instruction writes output to an implementation-defined stream such as stdout under control of the string pointed to by format that specifies how subsequent arguments are converted for output.  If there are insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.  The printf function returns when the end of the format string is encountered<br />\n<em>printf</em> returns 0 if it was executed successfully and -1 otherwise\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>format</em> must be <strong>OpString</strong>.<br />",
          "DescriptionPlain": "The printf extended instruction writes output to an implementation-defined stream such as stdout under control of the string pointed to by format that specifies how subsequent arguments are converted for output.  If there are insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.  The printf function returns when the end of the format string is encountered\nprintf returns 0 if it was executed successfully and -1 otherwise\n\nResult Type must be i32. \nformat must be OpString.",
          "Category": "MiscInstructions",
          "Number": 184,
          "Operands": [
            {
              "Name": "format",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Prefetch",
          "OriginalName": "prefetch",
          "Description": "Prefetch <em>num_elements</em> * size in bytes of the type pointed by <em>p</em>, into the global cache. The prefetch instruction is applied to a work-item in a work-group and does not affect the functional behavior of the kernel.\n<br />\n<em>num_elements</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>) to <em>floating-point</em>, <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em>, <em>integer</em> values. <br />",
          "DescriptionPlain": "Prefetch num_elements * size in bytes of the type pointed by p, into the global cache. The prefetch instruction is applied to a work-item in a work-group and does not affect the functional behavior of the kernel.\n\nnum_elements must be size_t. \nResult Type must be void. \np must be a pointer(global) to floating-point, integer or vector(2,3,4,8,16) of floating-point, integer values. ",
          "Category": "MiscInstructions",
          "Number": 185,
          "Operands": [
            {
              "Name": "num_elements",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef",
          "OriginalName": "read_imagef",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns floating-point values in the range [0.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to one of the pre-defined packed formats or <strong>UNORM INT8</strong>, or <strong>UNORM INT16</strong>. <br />\n<br />\nThis function returns floating-point values in the range[-1.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to <strong>SNORM INT8</strong>, or <strong>SNORM INT16</strong>.<br />\n<br />\nThis function returns floating-point values for <em>image</em> objects created with <em>channel data type</em> set to <strong>HALF FLOAT</strong>, or <strong>FLOAT</strong>.<br />\n<br />\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.<br />\n<br />\nValues returned by this function for image objects with <em>channel data type</em> which is not specified in the description above are undefined.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em>, <em>image2dMsaaDepth</em>, <em>image2dArrayMsaaDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>image2dDepth</em>, <em>image2dMsaa</em> or <em>image2dMsaaDepth</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dArrayMsaa</em> or <em>image2dArrayMsaaDepth</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />\n<em>Result Type</em> must be a <em>float</em> when <em>img</em> is a <em>image2dArrayDepth</em>, <em>image2dDepth</em>, <em>image2dMsaaDepth</em> or <em>image2dArrayMsaaDepth</em>, and  <em>vector(4)</em> of <em>float</em> values when <em>img</em> is on of the remaining valid image types for this instruction.",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns floating-point values in the range [0.0 &#8230; 1.0] for image objects created with channel data type set to one of the pre-defined packed formats or UNORM INT8, or UNORM INT16. \n\nThis function returns floating-point values in the range[-1.0 &#8230; 1.0] for image objects created with channel data type set to SNORM INT8, or SNORM INT16.\n\nThis function returns floating-point values for image objects created with channel data type set to HALF FLOAT, or FLOAT.\n\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nValues returned by this function for image objects with channel data type which is not specified in the description above are undefined.\n\nResult Type must be float or vector(4) of float values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth, image2dMsaa, image2dArrayMsaa, image2dMsaaDepth, image2dArrayMsaaDepth or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, image2dDepth, image2dMsaa or image2dMsaaDepth, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, image2dArrayDepth, image2dArrayMsaa or image2dArrayMsaaDepth, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.\nResult Type must be a float when img is a image2dArrayDepth, image2dDepth, image2dMsaaDepth or image2dArrayMsaaDepth, and  vector(4) of float values when img is on of the remaining valid image types for this instruction.",
          "Category": "ImageReadFunctions",
          "Number": 111,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei",
          "OriginalName": "read_imagei",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns a non-parametric <em>i32</em> integer value.<br />\n<br />\nThis function can only be used if <em>img</em> image object <em>channel data type</em> is set to <strong>SIGNED INT8</strong>, <strong>SIGNED INT16</strong> or <strong>SIGNED INT32</strong>. If the <em>channel data type</em> is not one of these values, the values returned by read_imagei are undefined.<br />\n<br />\nThe sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>image2dDepth</em>, <em>image2dMsaa</em> or <em>image2dMsaaDepth</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dArrayMsaa</em> or <em>image2dArrayMsaaDepth</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns a non-parametric i32 integer value.\n\nThis function can only be used if img image object channel data type is set to SIGNED INT8, SIGNED INT16 or SIGNED INT32. If the channel data type is not one of these values, the values returned by read_imagei are undefined.\n\nThe sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dMsaa, image2dArrayMsaa or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, image2dDepth, image2dMsaa or image2dMsaaDepth, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, image2dArrayDepth, image2dArrayMsaa or image2dArrayMsaaDepth, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.",
          "Category": "ImageReadFunctions",
          "Number": 112,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui",
          "OriginalName": "read_imageui",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns a non-parametric <em>i32</em> integer value.<br />\n<br />\nThis function can only be used if <em>img</em> image object <em>channel data type</em> is set to <strong>UNSIGNED INT8</strong>, <strong>UNSIGNED INT16</strong> or <strong>UNSIGNED INT32</strong>. If the <em>channel data type</em> is not one of these values, the values returned by read_imagei are undefined.<br />\n<br />\nThe sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>image2dDepth</em>, <em>image2dMsaa</em> or <em>image2dMsaaDepth</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dArrayMsaa</em> or <em>image2dArrayMsaaDepth</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns a non-parametric i32 integer value.\n\nThis function can only be used if img image object channel data type is set to UNSIGNED INT8, UNSIGNED INT16 or UNSIGNED INT32. If the channel data type is not one of these values, the values returned by read_imagei are undefined.\n\nThe sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dMsaa, image2dArrayMsaa or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, image2dDepth, image2dMsaa or image2dMsaaDepth, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, image2dArrayDepth, image2dArrayMsaa or image2dArrayMsaaDepth, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.",
          "Category": "ImageReadFunctions",
          "Number": 113,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageh",
          "OriginalName": "read_imageh",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns half precision floating-point values in the range [0.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to one of the pre-defined packed formats or <strong>UNORM INT8</strong>, or <strong>UNORM INT16</strong>. <br />\n<br />\nThis function returns half precision floating-point values in the range[-1.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to <strong>SNORM INT8</strong>, or <strong>SNORM INT16</strong>.<br />\n<br />\nThis function returns half precision floating-point values for <em>image</em> objects created with <em>channel data type</em> set to <strong>HALF FLOAT</strong>, or <strong>FLOAT</strong>.<br />\n<br />\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.<br />\n<br />\nValues returned by this function for image objects with <em>channel data type</em> which is not specified in the description above are undefined.\n<br />\n<em>Result Type</em> must be <em>half</em> or <em>vector(4)</em> of <em>half</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />\n<em>Result Type</em> must be a <em>half</em> when <em>img</em> is a <em>image2dArrayDepth</em>, <em>image2dDepth</em>, <em>image2dMsaaDepth</em> or <em>image2dArrayMsaaDepth</em>, and  <em>vector(4)</em> of <em>half</em> values when <em>img</em> is on of the remaining valid image types for this instruction.",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns half precision floating-point values in the range [0.0 &#8230; 1.0] for image objects created with channel data type set to one of the pre-defined packed formats or UNORM INT8, or UNORM INT16. \n\nThis function returns half precision floating-point values in the range[-1.0 &#8230; 1.0] for image objects created with channel data type set to SNORM INT8, or SNORM INT16.\n\nThis function returns half precision floating-point values for image objects created with channel data type set to HALF FLOAT, or FLOAT.\n\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nValues returned by this function for image objects with channel data type which is not specified in the description above are undefined.\n\nResult Type must be half or vector(4) of half values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.\nResult Type must be a half when img is a image2dArrayDepth, image2dDepth, image2dMsaaDepth or image2dArrayMsaaDepth, and  vector(4) of half values when img is on of the remaining valid image types for this instruction.",
          "Category": "ImageReadFunctions",
          "Number": 114,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef_samplerless",
          "OriginalName": "read_imagef_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imagef function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imagef function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be float or vector(4) of float values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 115,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei_samplerless",
          "OriginalName": "read_imagei_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imagei function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imagei function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dMsaa, image2dArrayMsaa or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 116,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui_samplerless",
          "OriginalName": "read_imageui_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imageui function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imageui function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 117,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageh_samplerless",
          "OriginalName": "read_imageh_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imageh function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>half</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imageh function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be  vector(4) of half values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 118,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef_mipmap_lod",
          "OriginalName": "read_imagef_mipmap_lod",
          "Description": "Use the coordinate specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the mip-level specified by <em>lod</em> in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\n<em>lod</em> is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a <em>float</em>.",
          "DescriptionPlain": "Use the coordinate specified by coords, and the sampler object specified by s to do an element lookup in the mip-level specified by lod in the image object specified by img.\n\nResult Type must be float or vector(4) of float values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nlod is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- Result Type must be a float.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- Result Type must be a float.",
          "Category": "ImageReadFunctions",
          "Number": 123,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei_mipmap_lod",
          "OriginalName": "read_imagei_mipmap_lod",
          "Description": "Use the coordinate specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the mip-level specified by <em>lod</em> in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\n<em>lod</em> is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>lod</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />",
          "DescriptionPlain": "Use the coordinate specified by coords, and the sampler object specified by s to do an element lookup in the mip-level specified by lod in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nlod is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- lod must be a float.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n\nWhen img type is image1d:\n- coords must be a float. \n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. ",
          "Category": "ImageReadFunctions",
          "Number": 124,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui_mipmap_lod",
          "OriginalName": "read_imageui_mipmap_lod",
          "Description": "Use the coordinate specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the mip-level specified by <em>lod</em> in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\n<em>lod</em> is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />",
          "DescriptionPlain": "Use the coordinate specified by coords, and the sampler object specified by s to do an element lookup in the mip-level specified by lod in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nlod is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n\nWhen img type is image1d:\n- coords must be a float. \n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. ",
          "Category": "ImageReadFunctions",
          "Number": 125,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef_mipmap_gradient",
          "OriginalName": "read_imagef_mipmap_gradient",
          "Description": "Use the gradients <em>grad_x</em> and <em>grad_y</em>, the coordinates specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the computed mip-level in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a <em>float</em>.",
          "DescriptionPlain": "Use the gradients grad_x and grad_y, the coordinates specified by coords, and the sampler object specified by s to do an element lookup in the computed mip-level in the image object specified by img.\n\nResult Type must be float or vector(4) of float values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- grad_x and grad_y must be a float.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a float.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(4) of float values.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a float.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a float.",
          "Category": "ImageReadFunctions",
          "Number": 126,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "grad_x",
              "Tpe": "ID"
            },
            {
              "Name": "grad_y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei_mipmap_gradient",
          "OriginalName": "read_imagei_mipmap_gradient",
          "Description": "Use the gradients <em>grad_x</em> and <em>grad_y</em>, the coordinates specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the computed mip-level in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.",
          "DescriptionPlain": "Use the gradients grad_x and grad_y, the coordinates specified by coords, and the sampler object specified by s to do an element lookup in the computed mip-level in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- grad_x and grad_y must be a float.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a float.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.",
          "Category": "ImageReadFunctions",
          "Number": 127,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "grad_x",
              "Tpe": "ID"
            },
            {
              "Name": "grad_y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui_mipmap_gradient",
          "OriginalName": "read_imageui_mipmap_gradient",
          "Description": "Use the gradients <em>grad_x</em> and <em>grad_y</em>, the coordinates specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the computed mip-level in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.",
          "DescriptionPlain": "Use the gradients grad_x and grad_y, the coordinates specified by coords, and the sampler object specified by s to do an element lookup in the computed mip-level in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- grad_x and grad_y must be a float.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a float.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.",
          "Category": "ImageReadFunctions",
          "Number": 128,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "grad_x",
              "Tpe": "ID"
            },
            {
              "Name": "grad_y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagef",
          "OriginalName": "write_imagef",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image2dDepth</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM INT16</strong>, <strong>UNORM INT24</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArrayDepth</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM INT16</strong>, <strong>UNORM INT24</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>.  <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with WriteOnly or ReadWrite access qualifier.\nWhen img is a image2d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value is a  vector(4) of float values.\n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a i32, and is in the range (0 &#8230; image width - 1)\n- value is a  vector(4) of float values.\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value is a  vector(4) of float values\n\nWhen img is a image2dDepth, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM INT16, UNORM INT24, FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value is a float.\n\nWhen img is a image2dArrayDepth, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM INT16, UNORM INT24, FLOAT. \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a float.\n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT.  \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.",
          "Category": "ImageWriteFunctions",
          "Number": 119,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagei",
          "OriginalName": "write_imagei",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>. <em>value</em> component type is considered to be a signed integer. <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe <em>channel data type</em> of <em>img</em> must be set to <strong>SIGNED INT8</strong>, <strong>SIGNED INT16</strong>, <strong>SIGNED INT32</strong>. <br />\nWhen <em>img</em> is a <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>:<br />\n- <em>coords</em> must be a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type. value component type is considered to be a signed integer. coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe channel data type of img must be set to SIGNED INT8, SIGNED INT16, SIGNED INT32. \nWhen img is a image2d:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value must be a  vector(4) of i32 values.\n\nWhen img is a image2dArray:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1d or image1dBuffer:\n- coords must be a i32, and is in the range (0 &#8230; image width - 1)\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1dArray:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value must be a  vector(4) of i32 values\n\nWhen img is a image3d:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.",
          "Category": "ImageWriteFunctions",
          "Number": 120,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imageui",
          "OriginalName": "write_imageui",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>. <em>value</em> component type is considered to be an unsigned integer. <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe <em>channel data type</em> of <em>img</em> must be set to <strong>UNSIGNED INT8</strong>, <strong>UNSIGNED INT16</strong>, <strong>UNSIGNED INT32</strong>. <br />\nWhen <em>img</em> is a <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>:<br />\n- <em>coords</em> must be a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type. value component type is considered to be an unsigned integer. coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe channel data type of img must be set to UNSIGNED INT8, UNSIGNED INT16, UNSIGNED INT32. \nWhen img is a image2d:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value must be a  vector(4) of i32 values.\n\nWhen img is a image2dArray:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1d or image1dBuffer:\n- coords must be a i32, and is in the range (0 &#8230; image width - 1)\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1dArray:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value must be a  vector(4) of i32 values\n\nWhen img is a image3d:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.",
          "Category": "ImageWriteFunctions",
          "Number": 121,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imageh",
          "OriginalName": "write_imageh",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>.  <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nWhen img is a image2d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value is a  vector(4) of half values.\n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of half values.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a i32, and is in the range (0 &#8230; image width - 1)\n- value is a  vector(4) of half values.\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value is a  vector(4) of half values\n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT.  \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of half values.",
          "Category": "ImageWriteFunctions",
          "Number": 122,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagef_mipmap_lod",
          "OriginalName": "write_imagef_mipmap_lod",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> in the mip-level specified by <em>lod</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe behavior of the function is undefined unless <em>lod</em> value is in the range (0 &#8230; number of mip-levels in the image - 1).<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height  of the mip-level specified by <em>lod</em> - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1)<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dDepth</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width  of the mip-level specified by <em>lod</em>- 1), (0 &#8230; image height of the mip-level specified by <em>lod</em>- 1) respectively. <br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArrayDepth</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip - level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image depth of the mip-level specified by <em>lod</em> - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords in the mip-level specified by lod to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe behavior of the function is undefined unless lod value is in the range (0 &#8230; number of mip-levels in the image - 1).\nWhen img is a image2d, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height  of the mip-level specified by lod - 1) respectively. \n- value is a  vector(4) of float values.\n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- coords is a i32, and is in the range (0 &#8230; image width of the mip-level specified by lod - 1)\n- value is a  vector(4) of float values.\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. \n- value is a  vector(4) of float values.\n\nWhen img is a image2dDepth, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width  of the mip-level specified by lod- 1), (0 &#8230; image height of the mip-level specified by lod- 1) respectively. \n- value is a float.\n\nWhen img is a image2dArrayDepth, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip - level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a float.\n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image depth of the mip-level specified by lod - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.",
          "Category": "ImageWriteFunctions",
          "Number": 129,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagei_mipmap_lod",
          "OriginalName": "write_imagei_mipmap_lod",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> in the mip-level specified by <em>lod</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates. <em>value</em> component type is treated as signed integer.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe behavior of the function is undefined unless <em>lod</em> value is in the range (0 &#8230; number of mip-levels in the image - 1).<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height  of the mip-level specified by <em>lod</em> - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1)<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image depth of the mip-level specified by <em>lod</em> - 1) respectively. The fourth component is ignored.<br />",
          "DescriptionPlain": "Write value to the coordinates specified by coords in the mip-level specified by lod to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates. value component type is treated as signed integer.\n\nResult Type must be void. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe behavior of the function is undefined unless lod value is in the range (0 &#8230; number of mip-levels in the image - 1).\nWhen img is a image2d, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height  of the mip-level specified by lod - 1) respectively. \n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- coords is a i32, and is in the range (0 &#8230; image width of the mip-level specified by lod - 1)\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. \n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image depth of the mip-level specified by lod - 1) respectively. The fourth component is ignored.",
          "Category": "ImageWriteFunctions",
          "Number": 130,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imageui_mipmap_lod",
          "OriginalName": "write_imageui_mipmap_lod",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> in the mip-level specified by <em>lod</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates. <em>value</em> component type is treated as unsigned integer.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe behavior of the function is undefined unless <em>lod</em> value is in the range (0 &#8230; number of mip-levels in the image - 1).<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height  of the mip-level specified by <em>lod</em> - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1)<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image depth of the mip-level specified by <em>lod</em> - 1) respectively. The fourth component is ignored.",
          "DescriptionPlain": "Write value to the coordinates specified by coords in the mip-level specified by lod to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates. value component type is treated as unsigned integer.\n\nResult Type must be void. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe behavior of the function is undefined unless lod value is in the range (0 &#8230; number of mip-levels in the image - 1).\nWhen img is a image2d, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height  of the mip-level specified by lod - 1) respectively. \n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- coords is a i32, and is in the range (0 &#8230; image width of the mip-level specified by lod - 1)\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. \n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image depth of the mip-level specified by lod - 1) respectively. The fourth component is ignored.",
          "Category": "ImageWriteFunctions",
          "Number": 131,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_width",
          "OriginalName": "get_image_width",
          "Description": "Return the width in pixels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the width in pixels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 132,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_height",
          "OriginalName": "get_image_height",
          "Description": "Return the height in pixels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the height in pixels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 133,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_depth",
          "OriginalName": "get_image_depth",
          "Description": "Return the depth in pixels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the depth in pixels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 134,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_channel_data_type",
          "OriginalName": "get_image_channel_data_type",
          "Description": "Return the <em>channel data type</em> of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>Result Type</em> must contain a value from <a href=\"#ImageChannelType\"><strong>ImageChannelType</strong></a> enumeration.",
          "DescriptionPlain": "Return the channel data type of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nResult Type must contain a value from ImageChannelType enumeration.",
          "Category": "ImageQueryFunctions",
          "Number": 135,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_channel_order",
          "OriginalName": "get_image_channel_order",
          "Description": "Return the <em>channel order</em> of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>Result Type</em> must contain a value from <a href=\"#ImageChannelOrder\"><strong>ImageChannelOrder</strong></a> enumeration.",
          "DescriptionPlain": "Return the channel order of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nResult Type must contain a value from ImageChannelOrder enumeration.",
          "Category": "ImageQueryFunctions",
          "Number": 136,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_dim",
          "OriginalName": "get_image_dim",
          "Description": "Return the dimensions of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>Result Type&#8217;must be  'vector(2)</em> of <em>i32</em> values when <em>img</em> is a <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em> or <em>image2dDepth</em>. The width and height of the image are contained in the first and second components of the return value repectively.<br />\n<em>Result Type&#8217;must be  'vector(4)</em> of <em>i32</em> values when <em>img</em> is a <em>image3d</em>. The width, height and depth of the image are contained in the first, second and third components of the return value repectively. The fourth component is 0.<br />",
          "DescriptionPlain": "Return the dimensions of the image object specified by img.\n\nResult Type must be i32 or vector(2,4) of i32 values. \nimg must be image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nResult Type&#8217;must be  'vector(2) of i32 values when img is a image2d, image2dArray, image2dArrayDepth or image2dDepth. The width and height of the image are contained in the first and second components of the return value repectively.\nResult Type&#8217;must be  'vector(4) of i32 values when img is a image3d. The width, height and depth of the image are contained in the first, second and third components of the return value repectively. The fourth component is 0.",
          "Category": "ImageQueryFunctions",
          "Number": 137,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_array_size",
          "OriginalName": "get_image_array_size",
          "Description": "Return the number of samples in the MSAA image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>Result Type</em> must be <em>size_t</em>. <br />\n<em>img</em> must be <em>image1dArray</em>, <em>image2dArray</em> or <em>image2dArrayDepth</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>img</em> must be <em>image2dMsaa</em>, <em>image2dArrayMsaa</em>, <em>image2dMsaaDepth</em> or <em>image2dArrayMsaaDepth</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the number of samples in the MSAA image object specified by img.\n\nResult Type must be i32. \nResult Type must be size_t. \nimg must be image1dArray, image2dArray or image2dArrayDepth value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nimg must be image2dMsaa, image2dArrayMsaa, image2dMsaaDepth or image2dArrayMsaaDepth value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 138,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_num_mip_levels",
          "OriginalName": "get_image_num_mip_levels",
          "Description": "Return the number of mip-levels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the number of mip-levels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 140,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        }
      ],
      "Enums": [
        {
          "Name": "ImageChannelOrder",
          "Values": [
            {
              "Value": 4272,
              "Name": "R"
            },
            {
              "Value": 4273,
              "Name": "A"
            },
            {
              "Value": 4274,
              "Name": "RG"
            },
            {
              "Value": 4275,
              "Name": "RA"
            },
            {
              "Value": 4276,
              "Name": "RGB"
            },
            {
              "Value": 4277,
              "Name": "RGBA"
            },
            {
              "Value": 4278,
              "Name": "BGRA"
            },
            {
              "Value": 4279,
              "Name": "ARGB"
            },
            {
              "Value": 4280,
              "Name": "INTENSITY"
            },
            {
              "Value": 4281,
              "Name": "LUMINANCE"
            },
            {
              "Value": 4282,
              "Name": "Rx"
            },
            {
              "Value": 4283,
              "Name": "RGx"
            },
            {
              "Value": 4284,
              "Name": "RGBx"
            },
            {
              "Value": 4285,
              "Name": "DEPTH"
            },
            {
              "Value": 4286,
              "Name": "DEPTH STENCIL"
            },
            {
              "Value": 4287,
              "Name": "sRGB"
            },
            {
              "Value": 4288,
              "Name": "sRGBx"
            },
            {
              "Value": 4289,
              "Name": "sRGBA"
            },
            {
              "Value": 4290,
              "Name": "sBGRA"
            }
          ]
        },
        {
          "Name": "ImageChannelType",
          "Values": [
            {
              "Value": 4304,
              "Name": "SNORM INT8"
            },
            {
              "Value": 4305,
              "Name": "SNORM INT16"
            },
            {
              "Value": 4306,
              "Name": "UNORM INT8"
            },
            {
              "Value": 4307,
              "Name": "UNORM_INT16"
            },
            {
              "Value": 4308,
              "Name": "UNORM SHORT 565"
            },
            {
              "Value": 4309,
              "Name": "UNORM SHORT 555"
            },
            {
              "Value": 4310,
              "Name": "UNORM INT 101010"
            },
            {
              "Value": 4311,
              "Name": "SIGNED INT8"
            },
            {
              "Value": 4312,
              "Name": "SIGNED INT16"
            },
            {
              "Value": 4313,
              "Name": "SIGNED INT32"
            },
            {
              "Value": 4314,
              "Name": "UNSIGNED INT8"
            },
            {
              "Value": 4315,
              "Name": "UNSIGNED INT16"
            },
            {
              "Value": 4316,
              "Name": "UNSIGNED INT32"
            },
            {
              "Value": 4317,
              "Name": "HALF FLOAT"
            },
            {
              "Value": 4318,
              "Name": "FLOAT"
            },
            {
              "Value": 4319,
              "Name": "UNORM INT24"
            }
          ]
        }
      ]
    },
    {
      "Metadata": {
        "Language": "Open CL",
        "Version": 2.0,
        "Title": "OpenCL 2.1 Extended Instruction Set Specification (Provisional)",
        "Author": "Boaz Ouriel, Intel",
        "Revnumber": "version 0.99, revision 30",
        "LastUpdate": "Last updated 2015-04-02 11:22:52 MDT"
      },
      "ExtendedInstructions": [
        {
          "Name": "Acos",
          "OriginalName": "acos",
          "Description": "Compute the arc cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 0,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Acosh",
          "OriginalName": "acosh",
          "Description": "Compute the inverse hyperbolic cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the inverse hyperbolic cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 1,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Acospi",
          "OriginalName": "acospi",
          "Description": "Compute <em>acos</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute acos(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 2,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Asin",
          "OriginalName": "asin",
          "Description": "Compute the arc sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 3,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Asinh",
          "OriginalName": "asinh",
          "Description": "Compute the inverse hyperbolic sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the inverse hyperbolic sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 4,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Asinpi",
          "OriginalName": "asinpi",
          "Description": "Compute <em>asin</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute asin(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 5,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atan",
          "OriginalName": "atan",
          "Description": "Compute the arc tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 6,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atan2",
          "OriginalName": "atan2",
          "Description": "Compute the arc tangent of <em>y</em> / <em>x</em>.\n<br />\n<em>Result Type</em>,<em>y</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the arc tangent of y / x.\n\nResult Type,y and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 7,
          "Operands": [
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atanh",
          "OriginalName": "atanh",
          "Description": "Compute the hyperbolic arc tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the hyperbolic arc tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 8,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atanpi",
          "OriginalName": "atanpi",
          "Description": "Compute <em>atan</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute atan(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 9,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Atan2pi",
          "OriginalName": "atan2pi",
          "Description": "Compute <em>atan2</em>(<em>y</em>, <em>x</em>) / &#960;.\n<br />\n<em>Result Type</em>,<em>y</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute atan2(y, x) / &#960;.\n\nResult Type,y and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 10,
          "Operands": [
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cbrt",
          "OriginalName": "cbrt",
          "Description": "Compute the cube-root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the cube-root of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 11,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ceil",
          "OriginalName": "ceil",
          "Description": "Round <em>x</em> to integral value using the round to positive infinity rounding mode.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to integral value using the round to positive infinity rounding mode.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 12,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Copysign",
          "OriginalName": "copysign",
          "Description": "Returns <em>x</em> with its sign changed to match the sign of <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns x with its sign changed to match the sign of y.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 13,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cos",
          "OriginalName": "cos",
          "Description": "Compute the cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 14,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cosh",
          "OriginalName": "cosh",
          "Description": "Compute the hyperbolic cosine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the hyperbolic cosine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 15,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cospi",
          "OriginalName": "cospi",
          "Description": "Compute <em>cos</em>(<em>x</em>) / &#960;.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute cos(x) / &#960;.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 16,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Erfc",
          "OriginalName": "erfc",
          "Description": "Complementary error function of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Complementary error function of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 17,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Erf",
          "OriginalName": "erf",
          "Description": "Error function of <em>x</em> encountered in integrating the normal distribution.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Error function of x encountered in integrating the normal distribution.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 18,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Exp",
          "OriginalName": "exp",
          "Description": "Compute the base-e exponential of <em>x</em>. (i.e. <em>e</em><sup><em>x</em></sup>)\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the base-e exponential of x. (i.e. ex)\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 19,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Exp2",
          "OriginalName": "exp2",
          "Description": "Computes 2 raised to the power of <em>x</em>. (i.e. <em>2</em><sup><em>x</em></sup>)\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes 2 raised to the power of x. (i.e. 2x)\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 20,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Exp10",
          "OriginalName": "exp10",
          "Description": "Computes 10 raised to the power of <em>x</em>. (i.e. <em>10</em><sup><em>x</em></sup>)\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes 10 raised to the power of x. (i.e. 10x)\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 21,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Expm1",
          "OriginalName": "expm1",
          "Description": "Computes <em>e</em><sup><em>x</em></sup> <em>- 1.0</em> .\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes ex - 1.0 .\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 22,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fabs",
          "OriginalName": "fabs",
          "Description": "Compute the absolute value of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the absolute value of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 23,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fdim",
          "OriginalName": "fdim",
          "Description": "Compute <em>x - y</em> if <em>x &gt; y</em>, <em>+0</em> if <em>x</em> is less than or equal to <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute x - y if x &gt; y, +0 if x is less than or equal to y.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 24,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Floor",
          "OriginalName": "floor",
          "Description": "Round <em>x</em> to the integral value using the round to negative infinity rounding mode.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to the integral value using the round to negative infinity rounding mode.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 25,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fma",
          "OriginalName": "fma",
          "Description": "Compute the correctly rounded floating-point representation of the sum of <em>c</em> with the infinitely precise product of <em>a</em> and <em>b</em>.Rounding of intermediate products shall not occur. Edge case behavior is per the IEEE 754-2008 standard.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the correctly rounded floating-point representation of the sum of c with the infinitely precise product of a and b.Rounding of intermediate products shall not occur. Edge case behavior is per the IEEE 754-2008 standard.\n\nResult Type,a,b and c must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 26,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmax",
          "OriginalName": "fmax",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>. If one argument is a NaN, <em>Fmax</em> returns the other argument.  If both arguments are NaNs, <em>Fmax</em> returns a NaN.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> fmax behave as defined by C99 and may not match the IEEE 754-2008 definition for maxNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x. If one argument is a NaN, Fmax returns the other argument.  If both arguments are NaNs, Fmax returns a NaN.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: fmax behave as defined by C99 and may not match the IEEE 754-2008 definition for maxNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "Category": "MathExtendedInstructions",
          "Number": 27,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmin",
          "OriginalName": "fmin",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>. If one argument is a NaN, <em>Fmin</em> returns the other argument.  If both arguments are NaNs, <em>Fmin</em> returns a NaN.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> fmin behave as defined by C99 and may not match the IEEE 754-2008 definition for minNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x. If one argument is a NaN, Fmin returns the other argument.  If both arguments are NaNs, Fmin returns a NaN.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: fmin behave as defined by C99 and may not match the IEEE 754-2008 definition for minNum with regard to signaling NaNs.Specifically, signaling NaNs may behave as quiet NaNs",
          "Category": "MathExtendedInstructions",
          "Number": 28,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmod",
          "OriginalName": "fmod",
          "Description": "Modulus. Returns <em>x</em> - <em>y</em> * <em>trunc</em> (<em>x</em>/<em>y</em>).\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Modulus. Returns x - y * trunc (x/y).\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 29,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fract",
          "OriginalName": "fract",
          "Description": "Returns <em>fmin</em>( <em>x</em> - <em>floor</em>(<em>x</em>), 0x1.fffffep-1f. <em>floor</em>(<em>x</em>) is returned in <em>ptr</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>ptr</em> must be a <em>pointer</em>(<em>generic</em>) to <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type, or must be a pointer to the same type.<br />",
          "DescriptionPlain": "Returns fmin( x - floor(x), 0x1.fffffep-1f. floor(x) is returned in ptr.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nptr must be a pointer(generic) to floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type, or must be a pointer to the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 30,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "ptr",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Frexp",
          "OriginalName": "frexp",
          "Description": "Extract the mantissa and exponent from <em>x</em>. The <em>Result Type</em> holds the mantissa, and <em>exp</em> points to the exponent. For each component the mantissa returned is a <em>floating-point</em> with magnitude in the interval [1/2, 1) or 0.  Each component of <em>x</em> equals mantissa returned * 2<sup>exp</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>exp</em> must be a <em>pointer</em>(<em>generic</em>) to <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>exp</em> operand must point to an <em>i32</em> with the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Extract the mantissa and exponent from x. The Result Type holds the mantissa, and exp points to the exponent. For each component the mantissa returned is a floating-point with magnitude in the interval [1/2, 1) or 0.  Each component of x equals mantissa returned * 2exp.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nexp must be a pointer(generic) to i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x operands must be of the same type. exp operand must point to an i32 with the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 31,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "exp",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Hypot",
          "OriginalName": "hypot",
          "Description": "Compute the value of the square root of <em>x</em><sup>2</sup>+ <em>y</em><sup>2</sup> without undue overflow or underflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the value of the square root of x2+ y2 without undue overflow or underflow.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 32,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ilogb",
          "OriginalName": "ilogb",
          "Description": "Return the exponent of <em>x</em> as an <em>i32</em> value.\n<br />\n<em>Result Type</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must have the same component count.<br />",
          "DescriptionPlain": "Return the exponent of x as an i32 value.\n\nResult Type must be i32 or vector(2,3,4,8,16) of i32 values. \nx must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must have the same component count.",
          "Category": "MathExtendedInstructions",
          "Number": 33,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ldexp",
          "OriginalName": "ldexp",
          "Description": "Multiply <em>x</em> by 2 to the power <em>k</em>.\n<br />\n<em>k</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>exp</em> operand must have the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Multiply x by 2 to the power k.\n\nk must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must be of the same type. exp operand must have the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 34,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "k",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Lgamma",
          "OriginalName": "lgamma",
          "Description": "Log gamma function of <em>x</em>. Returns the natural logarithm of the absolute value of the gamma function.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Log gamma function of x. Returns the natural logarithm of the absolute value of the gamma function.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 35,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Lgamma_r",
          "OriginalName": "lgamma_r",
          "Description": "Log gamma function of <em>x</em>. Returns the natural logarithm of the absolute value of the gamma function. The sign of the gamma function is returned in the <em>signp</em> operand\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>singp</em> must be a <em>pointer</em>(<em>generic</em>) to <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>singp</em> operand must point to an <em>i32</em> with the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Log gamma function of x. Returns the natural logarithm of the absolute value of the gamma function. The sign of the gamma function is returned in the signp operand\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nsingp must be a pointer(generic) to i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x operands must be of the same type. singp operand must point to an i32 with the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 36,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "singp",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log",
          "OriginalName": "log",
          "Description": "Compute natural logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute natural logarithm of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 37,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log2",
          "OriginalName": "log2",
          "Description": "Compute a base 2 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute a base 2 logarithm of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 38,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log10",
          "OriginalName": "log10",
          "Description": "Compute a base 10 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute a base 10 logarithm of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 39,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Log1p",
          "OriginalName": "log1p",
          "Description": "Compute log<sub>e</sub>(1.0 + <em>x</em>).\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute loge(1.0 + x).\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 40,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Logb",
          "OriginalName": "logb",
          "Description": "Compute the exponent of <em>x</em>, which is the integral part of log<sub>r</sub>  | <em>x</em> |.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the exponent of x, which is the integral part of logr  | x |.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 41,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Mad",
          "OriginalName": "mad",
          "Description": "mad approximates <em>a</em> * <em>b</em> + <em>c</em>. Whether or how the product of <em>a</em> * <em>b</em> is rounded and how supernormal or subnormal intermediate products are handled is not defined.  mad is intended to be used where speed is preferred over accuracy\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> For some usages, e.g.mad(<em>a</em>, <em>b</em>, -<em>a</em>*<em>b</em>), the definition of mad() is loose enough that almost any result is allowed from mad() for some values of <em>a</em> and <em>b</em>.",
          "DescriptionPlain": "mad approximates a * b + c. Whether or how the product of a * b is rounded and how supernormal or subnormal intermediate products are handled is not defined.  mad is intended to be used where speed is preferred over accuracy\n\nResult Type,a,b and c must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: For some usages, e.g.mad(a, b, -a*b), the definition of mad() is loose enough that almost any result is allowed from mad() for some values of a and b.",
          "Category": "MathExtendedInstructions",
          "Number": 42,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Maxmag",
          "OriginalName": "maxmag",
          "Description": "Returns <em>x</em> if | <em>x</em> | &gt; | <em>y</em> | , <em>y</em> if | <em>y</em> | &gt; | <em>x</em> | , otherwise <em>fmax</em>(<em>x</em>, <em>y</em>).\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns x if | x | &gt; | y | , y if | y | &gt; | x | , otherwise fmax(x, y).\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 43,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Minmag",
          "OriginalName": "minmag",
          "Description": "Returns <em>x</em> if | <em>x</em> | &lt; | <em>y</em> |, <em>y</em> if | <em>y</em> | &lt; | <em>x</em> |, otherwise <em>fmin</em>(<em>x</em>, <em>y</em>).\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns x if | x | &lt; | y |, y if | y | &lt; | x |, otherwise fmin(x, y).\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 44,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Modf",
          "OriginalName": "modf",
          "Description": "Decompose a <em>floating-point</em> number. The modf function breaks the argument <em>x</em> into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part in the object pointed to by <em>iptr</em>\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>iptr</em> must be a <em>pointer</em>(<em>generic</em>) to <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type, or must be a pointer to the same type.<br />",
          "DescriptionPlain": "Decompose a floating-point number. The modf function breaks the argument x into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part in the object pointed to by iptr\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \niptr must be a pointer(generic) to floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type, or must be a pointer to the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 45,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "iptr",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Nan",
          "OriginalName": "nan",
          "Description": "Returns a quiet NaN. The <em>nancode</em> may be placed in the significand of the resulting NaN.\n<br />\n<em>nancode</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>nancode</em> operands must have the same component count.<br />",
          "DescriptionPlain": "Returns a quiet NaN. The nancode may be placed in the significand of the resulting NaN.\n\nnancode must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and nancode operands must have the same component count.",
          "Category": "MathExtendedInstructions",
          "Number": 46,
          "Operands": [
            {
              "Name": "nancode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Nextafter",
          "OriginalName": "nextafter",
          "Description": "Computes the next representable <em>floating-point</em> value following <em>x</em> in the direction of <em>y</em>. Thus, if <em>y</em> is less than <em>x</em>, <em>nextafter</em>() returns the largest representable floating-point number less than <em>x</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes the next representable floating-point value following x in the direction of y. Thus, if y is less than x, nextafter() returns the largest representable floating-point number less than x.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 47,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Pow",
          "OriginalName": "pow",
          "Description": "Compute <em>x</em> to the power <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute x to the power y.\n\nResult Type,x,y and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 48,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Pown",
          "OriginalName": "pown",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>y</em> is an <em>i32</em> integer.\n<br />\n<em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>y</em> operand must have the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Compute x to the power y, where y is an i32 integer.\n\ny must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must be of the same type. y operand must have the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 49,
          "Operands": [
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Powr",
          "OriginalName": "powr",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>y</em> is an integer.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute x to the power y, where y is an integer.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 50,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Remainder",
          "OriginalName": "remainder",
          "Description": "Compute the value r such that r = <em>x</em> - n*<em>y</em>, where n is the integer nearest the exact value of <em>x</em>/<em>y</em>. If there are two integers closest to <em>x</em>/<em>y</em>, n shall be the even one. If r is zero, it is given the same sign as <em>x</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the value r such that r = x - n*y, where n is the integer nearest the exact value of x/y. If there are two integers closest to x/y, n shall be the even one. If r is zero, it is given the same sign as x.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 51,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Remquo",
          "OriginalName": "remquo",
          "Description": "The remquo function computes the value r such that r = <em>x</em> - k*<em>y</em>, where k is the integer nearest the exact value of <em>x</em>/<em>y</em>.  If there are two integers closest to <em>x</em>/<em>y</em>, k shall be the even one. If r is zero, it is given the same sign as <em>x</em>.  This is the same value that is returned by the <em>remainder</em> function. remquo also calculates the lower seven bits of the integral quotient <em>x</em>/<em>y</em>, and gives that value the same sign as <em>x</em>/<em>y</em>. It stores this signed value in the object pointed to by <em>quo</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>quo</em> must be a <em>pointer</em>(<em>generic</em>) to <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em>, <em>x</em> and <em>y</em> operands must be of the same type. <em>quo</em> operand must point to an <em>i32</em> with the same component count as <em>Result Type</em>, <em>x</em> and <em>y</em> operands.<br />",
          "DescriptionPlain": "The remquo function computes the value r such that r = x - k*y, where k is the integer nearest the exact value of x/y.  If there are two integers closest to x/y, k shall be the even one. If r is zero, it is given the same sign as x.  This is the same value that is returned by the remainder function. remquo also calculates the lower seven bits of the integral quotient x/y, and gives that value the same sign as x/y. It stores this signed value in the object pointed to by quo.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nquo must be a pointer(generic) to i32 or vector(2,3,4,8,16) of i32 values. \nResult Type, x and y operands must be of the same type. quo operand must point to an i32 with the same component count as Result Type, x and y operands.",
          "Category": "MathExtendedInstructions",
          "Number": 52,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "quo",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rint",
          "OriginalName": "rint",
          "Description": "Round <em>x</em> to integral value (using round to nearest even rounding mode) in floating-point format.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to integral value (using round to nearest even rounding mode) in floating-point format.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 53,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rootn",
          "OriginalName": "rootn",
          "Description": "Compute <em>x</em> to the power 1/<em>y</em>.\n<br />\n<em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>x</em> operands must be of the same type. <em>y</em> operand must have the same component count as <em>Result Type</em> and <em>x</em> operands.<br />",
          "DescriptionPlain": "Compute x to the power 1/y.\n\ny must be i32 or vector(2,3,4,8,16) of i32 values. \nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nResult Type and x operands must be of the same type. y operand must have the same component count as Result Type and x operands.",
          "Category": "MathExtendedInstructions",
          "Number": 54,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Round",
          "OriginalName": "round",
          "Description": "Return the integral value nearest to <em>x</em> rounding halfway cases away from zero, regardless of the current rounding direction.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Return the integral value nearest to x rounding halfway cases away from zero, regardless of the current rounding direction.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 55,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rsqrt",
          "OriginalName": "rsqrt",
          "Description": "Compute inverse square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute inverse square root of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 56,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sin",
          "OriginalName": "sin",
          "Description": "Compute sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 57,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sincos",
          "OriginalName": "sincos",
          "Description": "Compute sine and cosine of <em>x</em>. The computed sine is the return value and computed cosine is returned in <em>cosval</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\n<em>cosval</em> must be a <em>pointer</em>(<em>generic</em>) to <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type, or must be a pointer to the same type.<br />",
          "DescriptionPlain": "Compute sine and cosine of x. The computed sine is the return value and computed cosine is returned in cosval.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \ncosval must be a pointer(generic) to floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type, or must be a pointer to the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 58,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "cosval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sinh",
          "OriginalName": "sinh",
          "Description": "Compute hyperbolic sine of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute hyperbolic sine of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 59,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sinpi",
          "OriginalName": "sinpi",
          "Description": "Compute <em>sin</em> (&#960; x).\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute sin (&#960; x).\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 60,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sqrt",
          "OriginalName": "sqrt",
          "Description": "Compute square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute square root of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 61,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tan",
          "OriginalName": "tan",
          "Description": "Compute tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 62,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tanh",
          "OriginalName": "tanh",
          "Description": "Compute hyperbolic tangent of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute hyperbolic tangent of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 63,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tanpi",
          "OriginalName": "tanpi",
          "Description": "Compute <em>tan</em> (&#960; x).\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute tan (&#960; x).\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 64,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Tgamma",
          "OriginalName": "tgamma",
          "Description": "Compute the gamma function of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Compute the gamma function of x.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 65,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Trunc",
          "OriginalName": "trunc",
          "Description": "Round <em>x</em> to integral value using the round to zero rounding mode.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Round x to integral value using the round to zero rounding mode.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MathExtendedInstructions",
          "Number": 66,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_cos",
          "OriginalName": "half_cos",
          "Description": "Compute cosine of <em>x</em>, where <em>x</em> must be in the range -2<sup>16</sup> &#8230; +2<sup>16</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute cosine of x, where x must be in the range -216 &#8230; +216.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 67,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_divide",
          "OriginalName": "half_divide",
          "Description": "Compute <em>x</em> / <em>y</em>.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute x / y.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 68,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_exp",
          "OriginalName": "half_exp",
          "Description": "Compute the base-e exponential of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the base-e exponential of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 69,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_exp2",
          "OriginalName": "half_exp2",
          "Description": "Compute the base- 2 exponential of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the base- 2 exponential of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 70,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_exp10",
          "OriginalName": "half_exp10",
          "Description": "Compute the base- 10 exponential of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the base- 10 exponential of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 71,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_log",
          "OriginalName": "half_log",
          "Description": "Compute natural logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute natural logarithm of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 72,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_log2",
          "OriginalName": "half_log2",
          "Description": "Compute a base 2 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute a base 2 logarithm of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 73,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_log10",
          "OriginalName": "half_log10",
          "Description": "Compute a base 10 logarithm of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute a base 10 logarithm of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 74,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_powr",
          "OriginalName": "half_powr",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>x</em> is &gt;= 0.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute x to the power y, where x is &gt;= 0.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 75,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_recip",
          "OriginalName": "half_recip",
          "Description": "Compute reciprocal of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute reciprocal of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 76,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_rsqrt",
          "OriginalName": "half_rsqrt",
          "Description": "Compute inverse square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute inverse square root of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 77,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_sin",
          "OriginalName": "half_sin",
          "Description": "Compute sine of <em>x</em>, where <em>x</em> must be in the range -2<sup>16</sup> &#8230; +2<sup>16</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute sine of x, where x must be in the range -216 &#8230; +216.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 78,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_sqrt",
          "OriginalName": "half_sqrt",
          "Description": "Compute the square root of <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute the square root of x.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 79,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Half_tan",
          "OriginalName": "half_tan",
          "Description": "Compute tangent value of <em>x</em>, where <em>x</em> must be in the range -2<sup>16</sup> &#8230; +2<sup>16</sup>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.<br />\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  <br />",
          "DescriptionPlain": "Compute tangent value of x, where x must be in the range -216 &#8230; +216.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThis function is implemented with a minimum of 10-bits of accuracy i.e. an ULP value &#8656; 8192 ulp.\n The support for denormal values is optional and may return any result allowed even when -cl-denormals-are-zero flag is not in force.  ",
          "Category": "MathExtendedInstructions",
          "Number": 80,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_cos",
          "OriginalName": "native_cos",
          "Description": "Compute cosine of <em>x</em> over an implementation-defined range. The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute cosine of x over an implementation-defined range. The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 81,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_divide",
          "OriginalName": "native_divide",
          "Description": "Compute <em>x</em> / <em>y</em> over an implementation-defined range. The maximum error is implementation-defined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute x / y over an implementation-defined range. The maximum error is implementation-defined.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 82,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_exp",
          "OriginalName": "native_exp",
          "Description": "Compute the base-e exponential of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the base-e exponential of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 83,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_exp2",
          "OriginalName": "native_exp2",
          "Description": "Compute the base- 2 exponential of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined..\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the base- 2 exponential of x over an implementation-defined range.  The maximum error is implementation-defined..\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 84,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_exp10",
          "OriginalName": "native_exp10",
          "Description": "Compute the base- 10 exponential of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined..\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the base- 10 exponential of x over an implementation-defined range.  The maximum error is implementation-defined..\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 85,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_log",
          "OriginalName": "native_log",
          "Description": "Compute natural logarithm of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute natural logarithm of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 86,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_log2",
          "OriginalName": "native_log2",
          "Description": "Compute a base 2 logarithm of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute a base 2 logarithm of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 87,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_log10",
          "OriginalName": "native_log10",
          "Description": "Compute a base 10 logarithm of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute a base 10 logarithm of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 88,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_powr",
          "OriginalName": "native_powr",
          "Description": "Compute <em>x</em> to the power <em>y</em>, where <em>x</em> is &gt;= 0.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute x to the power y, where x is &gt;= 0.\n\nResult Type,x and y must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 89,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_recip",
          "OriginalName": "native_recip",
          "Description": "Compute reciprocal of <em>x</em> over an implementation-defined range. The range of x and y are implementation-defined. The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute reciprocal of x over an implementation-defined range. The range of x and y are implementation-defined. The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 90,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_rsqrt",
          "OriginalName": "native_rsqrt",
          "Description": "Compute inverse square root of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute inverse square root of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 91,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_sin",
          "OriginalName": "native_sin",
          "Description": "Compute sine of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute sine of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 92,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_sqrt",
          "OriginalName": "native_sqrt",
          "Description": "Compute the square root of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute the square root of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 93,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Native_tan",
          "OriginalName": "native_tan",
          "Description": "Compute tangent value of <em>x</em> over an implementation-defined range.  The maximum error is implementation-defined.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>float</em> or <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function<br />",
          "DescriptionPlain": "Compute tangent value of x over an implementation-defined range.  The maximum error is implementation-defined.\n\nResult Type and x must be float or vector(2,3,4,8,16) of float values. \nAll of the operands, including the Result Type operand, must be of the same type.\nThe function may map to one or more native device instructions and will typically have better performance compared to the non native corresponding functions. Support for denormal values is implementation-defined for this function",
          "Category": "MathExtendedInstructions",
          "Number": 94,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_abs",
          "OriginalName": "s_abs",
          "Description": "Returns |<em>x</em>|, where <em>x</em> is treated as signed integer.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns |x|, where x is treated as signed integer.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 141,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_abs_diff",
          "OriginalName": "s_abs_diff",
          "Description": "Returns | <em>x</em> - <em>y</em> | without modulo overflow, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns | x - y | without modulo overflow, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 142,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_add_sat",
          "OriginalName": "s_add_sat",
          "Description": "Returns the saturated value of <em>x</em> + <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x + y, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 143,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_add_sat",
          "OriginalName": "u_add_sat",
          "Description": "Returns the saturated value of <em>x</em> + <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x + y, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 144,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_hadd",
          "OriginalName": "s_hadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em>) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as signed integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y) &gt;&gt; 1, where x and y are treated as signed integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 145,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_hadd",
          "OriginalName": "u_hadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em>) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as unsigned integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y) &gt;&gt; 1, where x and y are treated as unsigned integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 146,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_rhadd",
          "OriginalName": "s_rhadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em> + 1) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as signed integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y + 1) &gt;&gt; 1, where x and y are treated as signed integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 147,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_rhadd",
          "OriginalName": "u_rhadd",
          "Description": "Returns the value of (<em>x</em> + <em>y</em> + 1) &gt;&gt; 1, where <em>x</em> and <em>y</em> are treated as unsigned integers. The intermediate sum does not modulo overflow.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the value of (x + y + 1) &gt;&gt; 1, where x and y are treated as unsigned integers. The intermediate sum does not modulo overflow.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 148,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_clamp",
          "OriginalName": "s_clamp",
          "Description": "Returns <em>s_min</em>(<em>s_max</em>(<em>x</em>,<em>minval</em>),<em>maxval</em>). Results are undefined if <em>minval</em> &gt; <em>maxval</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>minval</em> and <em>maxval</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns s_min(s_max(x,minval),maxval). Results are undefined if minval &gt; maxval.\n\nResult Type,x,minval and maxval must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 149,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "minval",
              "Tpe": "ID"
            },
            {
              "Name": "maxval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_clamp",
          "OriginalName": "u_clamp",
          "Description": "Returns <em>u_min</em>(<em>u_max</em>(<em>x</em>,<em>minval</em>),<em>maxval</em>). Results are undefined if <em>minval</em> &gt; <em>maxval</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>minval</em> and <em>maxval</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns u_min(u_max(x,minval),maxval). Results are undefined if minval &gt; maxval.\n\nResult Type,x,minval and maxval must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 150,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "minval",
              "Tpe": "ID"
            },
            {
              "Name": "maxval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Clz",
          "OriginalName": "clz",
          "Description": "Returns the number of leading 0-bits in <em>x</em>, starting at the most significant bit position. If <em>x</em> is 0, returns the size in bits of the type of <em>x</em> or component type of <em>x</em>, if <em>x</em> is a vector.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, returns the size in bits of the type of x or component type of x, if x is a vector.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 151,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Ctz",
          "OriginalName": "ctz",
          "Description": "Returns the count of trailing 0-bits in <em>x</em>. If <em>x</em> is 0, returns the size in bits of the type of <em>x</em> or component type of <em>x</em>, if <em>x</em> is a vector.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the count of trailing 0-bits in x. If x is 0, returns the size in bits of the type of x or component type of x, if x is a vector.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 152,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mad_hi",
          "OriginalName": "s_mad_hi",
          "Description": "Returns <em>mul_hi</em>(<em>a</em>, <em>b</em>) + <em>c</em>, where <em>a</em>,<em>b</em> and <em>c</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns mul_hi(a, b) + c, where a,b and c are treated as signed integers.\n\nResult Type,a,b and c must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 153,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_max",
          "OriginalName": "s_max",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 156,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_max",
          "OriginalName": "u_max",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 157,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_min",
          "OriginalName": "s_min",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 158,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_min",
          "OriginalName": "u_min",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 159,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mul_hi",
          "OriginalName": "s_mul_hi",
          "Description": "Computes <em>x</em> * <em>y</em> and returns the high half of the product of <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes x * y and returns the high half of the product of x and y, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 160,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Rotate",
          "OriginalName": "rotate",
          "Description": "For each element in <em>v</em>, the bits are shifted left by the number of bits given by the corresponding element in <em>i</em>. Bits shifted off the left side of the element are shifted back in from the right.\n<br />\n<em>Result Type</em>,<em>v</em> and <em>i</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "For each element in v, the bits are shifted left by the number of bits given by the corresponding element in i. Bits shifted off the left side of the element are shifted back in from the right.\n\nResult Type,v and i must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 161,
          "Operands": [
            {
              "Name": "v",
              "Tpe": "ID"
            },
            {
              "Name": "i",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_sub_sat",
          "OriginalName": "s_sub_sat",
          "Description": "Returns the saturated value of <em>x</em> - <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x - y, where x and y are treated as signed integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 162,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_sub_sat",
          "OriginalName": "u_sub_sat",
          "Description": "Returns the saturated value of <em>x</em> - <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the saturated value of x - y, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 163,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_upsample",
          "OriginalName": "u_upsample",
          "Description": "When <em>hi</em> and <em>lo</em> component type is i8:<br />\nResult = ((upcast&#8230;to i16)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component type is i16:<br />\nResult = ((upcast&#8230;to i32)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component i32:<br />\nResult = ((upcast&#8230;to i64)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\n<em>hi</em> and <em>lo</em> are treated as unsigned integers.\n<br />\n<em>hi</em> and <em>lo</em> must be <em>i8</em>, <em>i16</em> or <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i8</em>, <em>i16</em> or <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>i16</em>, <em>i32</em> or <em>i64</em> or <em>vector(2,3,4,8,16)</em> of <em>i16</em>, <em>i32</em> or <em>i64</em> values. <br />\n<em>hi</em> and <em>lo</em> operands must be of the same type. When <em>hi</em> and <em>lo</em> component type is i8, the <em>Result Type</em> component type must be i16. When <em>hi</em> and <em>lo</em> component type is i16, the <em>Result Type</em> component type must be i32. When <em>hi</em> and <em>lo</em> component type is i32, the <em>Result Type</em> component type must be i64. <em>Result Type</em> must have the same component count as <em>hi</em> and <em>lo</em> operands.<br />",
          "DescriptionPlain": "When hi and lo component type is i8:\nResult = ((upcast&#8230;to i16)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component type is i16:\nResult = ((upcast&#8230;to i32)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component i32:\nResult = ((upcast&#8230;to i64)hi &lt;&lt; 8) | lo\n\nhi and lo are treated as unsigned integers.\n\nhi and lo must be i8, i16 or i32 or vector(2,3,4,8,16) of i8, i16 or i32 values. \nResult Type must be i16, i32 or i64 or vector(2,3,4,8,16) of i16, i32 or i64 values. \nhi and lo operands must be of the same type. When hi and lo component type is i8, the Result Type component type must be i16. When hi and lo component type is i16, the Result Type component type must be i32. When hi and lo component type is i32, the Result Type component type must be i64. Result Type must have the same component count as hi and lo operands.",
          "Category": "IntegerInstructions",
          "Number": 164,
          "Operands": [
            {
              "Name": "hi",
              "Tpe": "ID"
            },
            {
              "Name": "lo",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_upsample",
          "OriginalName": "s_upsample",
          "Description": "When <em>hi</em> and <em>lo</em> component type is i8:<br />\nResult = ((upcast&#8230;to i16)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component type is i16:<br />\nResult = ((upcast&#8230;to i32)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\nWhen <em>hi</em> and <em>lo</em> component i32:<br />\nResult = ((upcast&#8230;to i64)<em>hi</em> &lt;&lt; 8) | <em>lo</em><br />\n<br />\n<em>hi</em> and <em>lo</em> are treated as signed integers.\n<br />\n<em>hi</em> and <em>lo</em> must be <em>i8</em>, <em>i16</em> or <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i8</em>, <em>i16</em> or <em>i32</em> values. <br />\n<em>Result Type</em> must be <em>i16</em>, <em>i32</em> or <em>i64</em> or <em>vector(2,3,4,8,16)</em> of <em>i16</em>, <em>i32</em> or <em>i64</em> values. <br />\n<em>hi</em> and <em>lo</em> operands must be of the same type. When <em>hi</em> and <em>lo</em> component type is i8, the <em>Result Type</em> component type must be i16. When <em>hi</em> and <em>lo</em> component type is i16, the <em>Result Type</em> component type must be i32. When <em>hi</em> and <em>lo</em> component type is i32, the <em>Result Type</em> component type must be i64. <em>Result Type</em> must have the same component count as <em>hi</em> and <em>lo</em> operands.<br />",
          "DescriptionPlain": "When hi and lo component type is i8:\nResult = ((upcast&#8230;to i16)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component type is i16:\nResult = ((upcast&#8230;to i32)hi &lt;&lt; 8) | lo\n\nWhen hi and lo component i32:\nResult = ((upcast&#8230;to i64)hi &lt;&lt; 8) | lo\n\nhi and lo are treated as signed integers.\n\nhi and lo must be i8, i16 or i32 or vector(2,3,4,8,16) of i8, i16 or i32 values. \nResult Type must be i16, i32 or i64 or vector(2,3,4,8,16) of i16, i32 or i64 values. \nhi and lo operands must be of the same type. When hi and lo component type is i8, the Result Type component type must be i16. When hi and lo component type is i16, the Result Type component type must be i32. When hi and lo component type is i32, the Result Type component type must be i64. Result Type must have the same component count as hi and lo operands.",
          "Category": "IntegerInstructions",
          "Number": 165,
          "Operands": [
            {
              "Name": "hi",
              "Tpe": "ID"
            },
            {
              "Name": "lo",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Popcount",
          "OriginalName": "popcount",
          "Description": "Returns the number of non-zero bits in <em>x</em>.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the number of non-zero bits in x.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 166,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mad24",
          "OriginalName": "s_mad24",
          "Description": "Multipy two 24-bit integer values <em>x</em> and <em>y</em> and add the 32-bit integer result to the 32-bit integer <em>z</em>. Refer to definition of s_mul24 to see how the 24-bit integer multiplication is performed.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>z</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multipy two 24-bit integer values x and y and add the 32-bit integer result to the 32-bit integer z. Refer to definition of s_mul24 to see how the 24-bit integer multiplication is performed.\n\nResult Type,x,y and z must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 167,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "z",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mad24",
          "OriginalName": "u_mad24",
          "Description": "Multipy two 24-bit integer values <em>x</em> and <em>y</em> and add the 32-bit integer result to the 32-bit integer <em>z</em>. Refer to definition of u_mul24 to see how the 24-bit integer multiplication is performed.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>z</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multipy two 24-bit integer values x and y and add the 32-bit integer result to the 32-bit integer z. Refer to definition of u_mul24 to see how the 24-bit integer multiplication is performed.\n\nResult Type,x,y and z must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 168,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "z",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "S_mul24",
          "OriginalName": "s_mul24",
          "Description": "Multiply two 24-bit integer values <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as signed integers. <em>x</em> and <em>y</em> are 32-bit integers but only the low 24-bits are used to perform the multiplication. s_mul24 should only be used when values in <em>x</em> and <em>y</em> are in the range [-2<sup>23</sup>, 2<sup>23</sup>-1]. If <em>x</em> and <em>y</em> are not in this range, the multiplication result is implementation-defined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multiply two 24-bit integer values x and y, where x and y are treated as signed integers. x and y are 32-bit integers but only the low 24-bits are used to perform the multiplication. s_mul24 should only be used when values in x and y are in the range [-223, 223-1]. If x and y are not in this range, the multiplication result is implementation-defined.\n\nResult Type,x and y must be i32 or vector(2,3,4,8,16) of i32 values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 169,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mul24",
          "OriginalName": "u_mul24",
          "Description": "Multiply two 24-bit integer values <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers. <em>x</em> and <em>y</em> are 32-bit integers but only the low 24-bits are used to perform the multiplication. u_mul24 should only be used when values in <em>x</em> and <em>y</em> are in the range [0, 2<sup>24</sup>-1]. If <em>x</em> and <em>y</em> are not in this range, the multiplication result is implementation-defined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>i32</em> or <em>vector(2,3,4,8,16)</em> of <em>i32</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Multiply two 24-bit integer values x and y, where x and y are treated as unsigned integers. x and y are 32-bit integers but only the low 24-bits are used to perform the multiplication. u_mul24 should only be used when values in x and y are in the range [0, 224-1]. If x and y are not in this range, the multiplication result is implementation-defined.\n\nResult Type,x and y must be i32 or vector(2,3,4,8,16) of i32 values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 170,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_abs",
          "OriginalName": "u_abs",
          "Description": "Returns |<em>x</em>|, where <em>x</em> is treated as unsigned integer.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns |x|, where x is treated as unsigned integer.\n\nResult Type and x must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 201,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_abs_diff",
          "OriginalName": "u_abs_diff",
          "Description": "Returns | <em>x</em> - <em>y</em> | without modulo overflow, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns | x - y | without modulo overflow, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 202,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mul_hi",
          "OriginalName": "u_mul_hi",
          "Description": "Computes <em>x</em> * <em>y</em> and returns the high half of the product of <em>x</em> and <em>y</em>, where <em>x</em> and <em>y</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Computes x * y and returns the high half of the product of x and y, where x and y are treated as unsigned integers.\n\nResult Type,x and y must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 203,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "U_mad_hi",
          "OriginalName": "u_mad_hi",
          "Description": "Returns <em>mul_hi</em>(<em>a</em>, <em>b</em>) + <em>c</em>, where <em>a</em>,<em>b</em> and <em>c</em> are treated as unsigned integers.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns mul_hi(a, b) + c, where a,b and c are treated as unsigned integers.\n\nResult Type,a,b and c must be integer or vector(2,3,4,8,16) of integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "IntegerInstructions",
          "Number": 204,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fclamp",
          "OriginalName": "fclamp",
          "Description": "Returns <em>fmin</em>(<em>fmax</em>(<em>x</em>, <em>minval</em>), <em>maxval</em>). Results are undefined if <em>minval</em> &gt; <em>maxval</em>.\n<br />\n<em>Result Type</em>,<em>x</em>,<em>minval</em> and <em>maxval</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns fmin(fmax(x, minval), maxval). Results are undefined if minval &gt; maxval.\n\nResult Type,x,minval and maxval must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 95,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "minval",
              "Tpe": "ID"
            },
            {
              "Name": "maxval",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Degrees",
          "OriginalName": "degrees",
          "Description": "Converts <em>radians</em> to degrees, i.e. (180 / &#960;) * <em>radians</em>.\n<br />\n<em>Result Type</em> and <em>radians</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Converts radians to degrees, i.e. (180 / &#960;) * radians.\n\nResult Type and radians must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 96,
          "Operands": [
            {
              "Name": "radians",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmax_common",
          "OriginalName": "fmax_common",
          "Description": "Returns <em>y</em> if <em>x</em> &lt; <em>y</em>, otherwise it returns <em>x</em>. If x or y are infinite or NaN, the return values are undefined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if x &lt; y, otherwise it returns x. If x or y are infinite or NaN, the return values are undefined.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 97,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fmin_common",
          "OriginalName": "fmin_common",
          "Description": "Returns <em>y</em> if <em>y</em> &lt; <em>x</em>, otherwise it returns <em>x</em>. If x or y are infinite or NaN, the return values are undefined.\n<br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns y if y &lt; x, otherwise it returns x. If x or y are infinite or NaN, the return values are undefined.\n\nResult Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 98,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Mix",
          "OriginalName": "mix",
          "Description": "Returns the linear blend of <em>x</em> &amp; <em>y</em> implemented as:<br />\n<em>x</em> + (<em>y</em> - <em>x</em>) * <em>a</em>\n<br />\n<em>Result Type</em>,<em>x</em>,<em>y</em> and <em>a</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> This function can be implemented using contractions such as mad or fma<br />",
          "DescriptionPlain": "Returns the linear blend of x &amp; y implemented as:\nx + (y - x) * a\n\nResult Type,x,y and a must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: This function can be implemented using contractions such as mad or fma",
          "Category": "CommonInstructions",
          "Number": 99,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "a",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Radians",
          "OriginalName": "radians",
          "Description": "Converts <em>degrees</em> to radians, i.e. (&#960; / 180) * <em>degrees</em>.\n<br />\n<em>Result Type</em> and <em>degrees</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Converts degrees to radians, i.e. (&#960; / 180) * degrees.\n\nResult Type and degrees must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 100,
          "Operands": [
            {
              "Name": "degrees",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Step",
          "OriginalName": "step",
          "Description": "Returns 0.0 if <em>x</em> &lt; <em>edge</em>, otherwise it returns 1.0.\n<br />\n<em>Result Type</em>,<em>edge</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns 0.0 if x &lt; edge, otherwise it returns 1.0.\n\nResult Type,edge and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 101,
          "Operands": [
            {
              "Name": "edge",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Smoothstep",
          "OriginalName": "smoothstep",
          "Description": "Returns 0.0 if <em>x</em> &#8656; <em>edge<sub>0</sub></em> and 1.0 if <em>x</em> &gt;= <em>edge<sub>1</sub></em> and performs smooth Hermite interpolation between 0 and 1, when <em>edge<sub>0</sub></em> &lt; x &lt; <em>edge<sub>1</sub></em>.<br />\n<br />\n This is equivalent to :<br />\n t = <em>fclamp</em>((<em>x</em> - <em>edge<sub>0</sub></em>) / (<em>edge<sub>1</sub></em> - <em>edge<sub>0</sub></em>), 0, 1);<br />\n return t * t * (3 - 2 * t);<br />\n<br />\nResults are undefined if <em>edge<sub>0</sub></em> &gt;= <em>edge<sub>1</sub></em> or if <em>x</em>, <em>edge<sub>0</sub></em> or <em>edge<sub>1</sub></em> is a NaN.\n<br />\n<em>Result Type</em>,<em>edge<sub>0</sub></em>,<em>edge<sub>1</sub></em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />\n<strong>Note:</strong> This function can be implemented using contractions such as mad or fma<br />",
          "DescriptionPlain": "Returns 0.0 if x &#8656; edge0 and 1.0 if x &gt;= edge1 and performs smooth Hermite interpolation between 0 and 1, when edge0 &lt; x &lt; edge1.\n\n This is equivalent to :\n t = fclamp((x - edge0) / (edge1 - edge0), 0, 1);\n return t * t * (3 - 2 * t);\n\nResults are undefined if edge0 &gt;= edge1 or if x, edge0 or edge1 is a NaN.\n\nResult Type,edge0,edge1 and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.\nNote: This function can be implemented using contractions such as mad or fma",
          "Category": "CommonInstructions",
          "Number": 102,
          "Operands": [
            {
              "Name": "edge0",
              "Tpe": "ID"
            },
            {
              "Name": "edge1",
              "Tpe": "ID"
            },
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Sign",
          "OriginalName": "sign",
          "Description": "Returns 1.0 if <em>x</em> &gt; 0, -0.0 if <em>x</em> = -0.0, +0.0 if <em>x</em> = +0.0, or -1.0 if <em>x</em> &lt; 0. Returns 0.0 if <em>x</em> is a NaN.\n<br />\n<em>Result Type</em> and <em>x</em> must be <em>floating-point</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns 1.0 if x &gt; 0, -0.0 if x = -0.0, +0.0 if x = +0.0, or -1.0 if x &lt; 0. Returns 0.0 if x is a NaN.\n\nResult Type and x must be floating-point or vector(2,3,4,8,16) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "CommonInstructions",
          "Number": 103,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Cross",
          "OriginalName": "cross",
          "Description": "Returns the cross product of <em>p<sub>0</sub></em>.xyz and <em>p<sub>1</sub></em>.xyz. <br />\nWhen the vector component count is 4, the w component returned will be 0.0.\n<br />\n<em>Result Type</em>,<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> must be  <em>vector(3,4)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns the cross product of p0.xyz and p1.xyz. \nWhen the vector component count is 4, the w component returned will be 0.0.\n\nResult Type,p0 and p1 must be  vector(3,4) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "GeometricInstructions",
          "Number": 104,
          "Operands": [
            {
              "Name": "p0",
              "Tpe": "ID"
            },
            {
              "Name": "p1",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Distance",
          "OriginalName": "distance",
          "Description": "Returns the distance between <em>p<sub>0</sub></em> and <em>p<sub>1</sub></em>.  This is calculated as <em>length</em>(<em>p<sub>0</sub></em> - <em>p<sub>1</sub></em>).\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same type. <em>Result Type</em>, <em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same component type",
          "DescriptionPlain": "Returns the distance between p0 and p1.  This is calculated as length(p0 - p1).\n\nResult Type must be floating-point. \np0 and p1 must be floating-point or vector(2,3,4) of floating-point values. \np0 and p1 operands must have the same type. Result Type, p0 and p1 operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 105,
          "Operands": [
            {
              "Name": "p0",
              "Tpe": "ID"
            },
            {
              "Name": "p1",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Length",
          "OriginalName": "length",
          "Description": "Return the length of vector <em>p</em>, i.e. <em>sqrt</em>( <em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> + &#8230; )\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p</em> must be  <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>p</em> operands must have the same component type",
          "DescriptionPlain": "Return the length of vector p, i.e. sqrt( p.x2 + p.y2 + &#8230; )\n\nResult Type must be floating-point. \np must be  vector(2,3,4) of floating-point values. \nResult Type and p operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 106,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Normalize",
          "OriginalName": "normalize",
          "Description": "Returns a vector in the same direction as <em>p</em> but with a length of 1.\n<br />\n<em>Result Type</em> and <em>p</em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns a vector in the same direction as p but with a length of 1.\n\nResult Type and p must be floating-point or vector(2,3,4) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "GeometricInstructions",
          "Number": 107,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fast_distance",
          "OriginalName": "fast_distance",
          "Description": "Returns <em>fast_length</em>(<em>p<sub>0</sub></em> - <em>p<sub>1</sub></em>).\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same type. <em>Result Type</em>, <em>p<sub>0</sub></em> and <em>p<sub>1</sub></em> operands must have the same component type",
          "DescriptionPlain": "Returns fast_length(p0 - p1).\n\nResult Type must be floating-point. \np0 and p1 must be floating-point or vector(2,3,4) of floating-point values. \np0 and p1 operands must have the same type. Result Type, p0 and p1 operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 108,
          "Operands": [
            {
              "Name": "p0",
              "Tpe": "ID"
            },
            {
              "Name": "p1",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fast_length",
          "OriginalName": "fast_length",
          "Description": "Return the length of vector <em>p</em> computed as: <em>half_sqrt</em>( <em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> + &#8230; )\n<br />\n<em>Result Type</em> must be <em>floating-point</em>. <br />\n<em>p</em> must be  <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\n<em>Result Type</em> and <em>p</em> operands must have the same component type",
          "DescriptionPlain": "Return the length of vector p computed as: half_sqrt( p.x2 + p.y2 + &#8230; )\n\nResult Type must be floating-point. \np must be  vector(2,3,4) of floating-point values. \nResult Type and p operands must have the same component type",
          "Category": "GeometricInstructions",
          "Number": 109,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Fast_normalize",
          "OriginalName": "fast_normalize",
          "Description": "Returns a vector in the same direction as <em>p</em> but with a length of 1 computed as:<br />\n<em>p</em> * <em>half_rsqrt</em>( <em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> &#8230; ) <br />\n<br />\nThe result shall be within 8192 ulps error from the infinitely precise result of:<br />\nif (<em>all</em>( <em>p</em> == 0.0f )) { result = <em>p</em>; }<br />\nelse {  result = <em>p</em> / <em>sqrt</em>(<em>p</em>.x<sup>2</sup> + <em>p</em>.y<sup>2</sup> + &#8230;); }<br />\n<br />\nwith the following exceptions :<br />\n1) If the sum of squares is greater than FLT_MAX then the value of the floating-point values in the result vector are undefined.<br />\n2) If the sum of squares is less than FLT_MIN then the implementation may return back <em>p</em>.<br />\n3) If the device is in \"denorms are flushed to zero\" mode, individual operand elements with magnitude less than <em>sqrt</em>(FLT_MIN) may be flushed to zero before proceeding with the calculation.\n<br />\n<em>Result Type</em> and <em>p</em> must be <em>floating-point</em> or <em>vector(2,3,4)</em> of <em>floating-point</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Returns a vector in the same direction as p but with a length of 1 computed as:\np * half_rsqrt( p.x2 + p.y2 &#8230; ) \n\nThe result shall be within 8192 ulps error from the infinitely precise result of:\nif (all( p == 0.0f )) { result = p; }\nelse {  result = p / sqrt(p.x2 + p.y2 + &#8230;); }\n\nwith the following exceptions :\n1) If the sum of squares is greater than FLT_MAX then the value of the floating-point values in the result vector are undefined.\n2) If the sum of squares is less than FLT_MIN then the implementation may return back p.\n3) If the device is in \"denorms are flushed to zero\" mode, individual operand elements with magnitude less than sqrt(FLT_MIN) may be flushed to zero before proceeding with the calculation.\n\nResult Type and p must be floating-point or vector(2,3,4) of floating-point values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "GeometricInstructions",
          "Number": 110,
          "Operands": [
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Bitselect",
          "OriginalName": "bitselect",
          "Description": "Each bit of the result is the corresponding bit of <em>a</em> if the corresponding bit of <em>c</em> is 0.  Otherwise it is the corresponding bit of <em>b</em>.\n<br />\n<em>Result Type</em>,<em>a</em>,<em>b</em> and <em>c</em> must be <em>floating-point</em> or <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Each bit of the result is the corresponding bit of a if the corresponding bit of c is 0.  Otherwise it is the corresponding bit of b.\n\nResult Type,a,b and c must be floating-point or integer or vector(2,3,4,8,16) of floating-point or integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "RelationalInstructions",
          "Number": 186,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Select",
          "OriginalName": "select",
          "Description": "Each bit of the result is the corresponding bit of <em>a</em> if the corresponding bit of <em>c</em> is 0.  Otherwise it is the corresponding bit of <em>b</em>.\n<br />\n<em>c</em> must be <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>integer</em> values. <br />\n<em>Result Type</em>,<em>a</em> and <em>b</em> must be <em>floating-point</em> or <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\n<em>Result Type</em>, <em>a</em> and <em>b</em> must have the same type. <em>c</em> operand must have the same component count and component bit width as the rest of the operands.",
          "DescriptionPlain": "Each bit of the result is the corresponding bit of a if the corresponding bit of c is 0.  Otherwise it is the corresponding bit of b.\n\nc must be integer or vector(2,3,4,8,16) of integer values. \nResult Type,a and b must be floating-point or integer or vector(2,3,4,8,16) of floating-point or integer values. \nResult Type, a and b must have the same type. c operand must have the same component count and component bit width as the rest of the operands.",
          "Category": "RelationalInstructions",
          "Number": 187,
          "Operands": [
            {
              "Name": "a",
              "Tpe": "ID"
            },
            {
              "Name": "b",
              "Tpe": "ID"
            },
            {
              "Name": "c",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vloadn",
          "OriginalName": "vloadn",
          "Description": "Return a vector value which is read from address (<em>p</em> + (<em>offset</em> * <em>n</em>)). <br />\nThe address computed as (<em>p</em> + (<em>offset</em> * <em>n</em>)) must be 8-bit aligned if <em>p</em> points to i8 value; 16-bit aligned if <em>p</em> points to i16 or half value; 32-bit aligned if <em>p</em> points to i32 or float value; 64-bit aligned if <em>p</em> points to i64 or double value.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>constant</em>, <em>generic</em>) to <em>floating-point</em>, <em>integer</em>. <br />\n<em>Result Type</em> must be  <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\n<em>Result Type</em> component count must be equal to <em>n</em> and its component type must be equal to the type pointed by <em>p</em>.<br />\n<em>n</em> must be 2,3,4,8 or 16.",
          "DescriptionPlain": "Return a vector value which is read from address (p + (offset * n)). \nThe address computed as (p + (offset * n)) must be 8-bit aligned if p points to i8 value; 16-bit aligned if p points to i16 or half value; 32-bit aligned if p points to i32 or float value; 64-bit aligned if p points to i64 or double value.\n\noffset must be size_t. \np must be a pointer(constant, generic) to floating-point, integer. \nResult Type must be  vector(2,3,4,8,16) of floating-point or integer values. \nResult Type component count must be equal to n and its component type must be equal to the type pointed by p.\nn must be 2,3,4,8 or 16.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 171,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "n",
              "Type": "LiteralNumber"
            }
          ]
        },
        {
          "Name": "Vstoren",
          "OriginalName": "vstoren",
          "Description": "Write <em>data</em> vector value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be 8-bit aligned if <em>p</em> points to i8 value; 16-bit aligned if <em>p</em> points to i16 or half value; 32-bit aligned if <em>p</em> points to i32 or float value; 64-bit aligned if <em>p</em> points to i64 or double value.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>floating-point</em>, <em>integer</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\n<em>data</em> component type must be equal to the type pointed by <em>p</em>.",
          "DescriptionPlain": "Write data vector value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be 8-bit aligned if p points to i8 value; 16-bit aligned if p points to i16 or half value; 32-bit aligned if p points to i32 or float value; 64-bit aligned if p points to i64 or double value.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to floating-point, integer. \ndata must be  vector(2,3,4,8,16) of floating-point or integer values. \ndata component type must be equal to the type pointed by p.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 172,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vload_half",
          "OriginalName": "vload_half",
          "Description": "Reads a half value from the address (<em>p</em> + (<em>offset</em>)) and converts it to a float return value. The address computed as (<em>p</em> + (<em>offset</em>)) must be 16-bit aligned.\n<br />\n<em>Result Type</em> must be <em>float</em>. <br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>constant</em>, <em>generic</em>) to <em>half</em>. <br />",
          "DescriptionPlain": "Reads a half value from the address (p + (offset)) and converts it to a float return value. The address computed as (p + (offset)) must be 16-bit aligned.\n\nResult Type must be float. \noffset must be size_t. \np must be a pointer(constant, generic) to half. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 173,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vload_halfn",
          "OriginalName": "vload_halfn",
          "Description": "Reads a half vector value from the address (<em>p</em> + (<em>offset</em> * <em>n</em>)) and converts it to a float vector return value. The address computed as (<em>p</em> + (<em>offset</em> * <em>n</em>)) must be 16-bit aligned.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>constant</em>, <em>generic</em>) to <em>half</em>. <br />\n<em>Result Type</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\n<em>Result Type</em> component count must be equal to <em>n</em>.<br />\n<em>n</em> must be 2,3,4,8 or 16.",
          "DescriptionPlain": "Reads a half vector value from the address (p + (offset * n)) and converts it to a float vector return value. The address computed as (p + (offset * n)) must be 16-bit aligned.\n\noffset must be size_t. \np must be a pointer(constant, generic) to half. \nResult Type must be  vector(2,3,4,8,16) of float values. \nResult Type component count must be equal to n.\nn must be 2,3,4,8 or 16.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 174,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "n",
              "Type": "LiteralNumber"
            }
          ]
        },
        {
          "Name": "Vstore_half",
          "OriginalName": "vstore_half",
          "Description": "Converts <em>data</em> float or double value to a half value and then write the converted value to the address (<em>p</em> + <em>offset</em>). The address computed as (<em>p</em> + <em>offset</em>) must be 16-bit aligned. <br />\nThis function uses the default rounding mode when converting <em>data</em> to a half value. The default rounding mode is round to nearest even.\n<br />\n<em>data</em> must be <em>float</em> or <em>double</em>. <br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />",
          "DescriptionPlain": "Converts data float or double value to a half value and then write the converted value to the address (p + offset). The address computed as (p + offset) must be 16-bit aligned. \nThis function uses the default rounding mode when converting data to a half value. The default rounding mode is round to nearest even.\n\ndata must be float or double. \noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 175,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstore_half_r",
          "OriginalName": "vstore_half_r",
          "Description": "Converts <em>data</em> float or double value to a half value and then write the converted value to the address (<em>p</em> + <em>offset</em>). The address computed as (<em>p</em> + <em>offset</em>) must be 16-bit aligned. <br />\nThis function uses <em>mode</em> rounding mode when converting <em>data</em> to a half value.\n<br />\n<em>data</em> must be <em>float</em> or <em>double</em>. <br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />",
          "DescriptionPlain": "Converts data float or double value to a half value and then write the converted value to the address (p + offset). The address computed as (p + offset) must be 16-bit aligned. \nThis function uses mode rounding mode when converting data to a half value.\n\ndata must be float or double. \noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 176,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "FP Rounding Mode\nmode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstore_halfn",
          "OriginalName": "vstore_halfn",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be 16-bit aligned.<br />\nThis function uses the default rounding mode when converting <em>data</em> to a vector of half values. The default rounding mode is round to nearest even.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be 16-bit aligned.\nThis function uses the default rounding mode when converting data to a vector of half values. The default rounding mode is round to nearest even.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 177,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstore_halfn_r",
          "OriginalName": "vstore_halfn_r",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be 16-bit aligned.<br />\nThis function uses <em>mode</em> rounding mode when converting <em>data</em> to a half value.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be 16-bit aligned.\nThis function uses mode rounding mode when converting data to a half value.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 178,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "FP Rounding Mode\nmode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vloada_halfn",
          "OriginalName": "vloada_halfn",
          "Description": "Reads a half vector value from the address (<em>p</em> + (<em>offset</em> * <em>n</em>)) and converts it to a float vector return value. The address computed as (<em>p</em> + (<em>offset</em> * <em>n</em>)) must be (2 * <em>n</em>) bytes aligned, when n = 2,4,8,16; For <em>n</em> = 3, the function returns a vector of 3 float values from the address (<em>p</em> + (<em>offset</em> * 4)). The address computed as (<em>p</em> + (<em>offset</em> * 4)) must be 8-bytes aligned\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>constant</em>, <em>generic</em>) to <em>half</em>. <br />\n<em>Result Type</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> values. <br />\n<em>Result Type</em> component count must be equal to <em>n</em>.<br />\n<em>n</em> must be 2,3,4,8 or 16.",
          "DescriptionPlain": "Reads a half vector value from the address (p + (offset * n)) and converts it to a float vector return value. The address computed as (p + (offset * n)) must be (2 * n) bytes aligned, when n = 2,4,8,16; For n = 3, the function returns a vector of 3 float values from the address (p + (offset * 4)). The address computed as (p + (offset * 4)) must be 8-bytes aligned\n\noffset must be size_t. \np must be a pointer(constant, generic) to half. \nResult Type must be  vector(2,3,4,8,16) of float values. \nResult Type component count must be equal to n.\nn must be 2,3,4,8 or 16.",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 179,
          "Operands": [
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "n",
              "Type": "LiteralNumber"
            }
          ]
        },
        {
          "Name": "Vstorea_halfn",
          "OriginalName": "vstorea_halfn",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be (2 * compCountOf(<em>data</em>)) bytes aligned, when n = 2,4,8,16; For <em>n</em> = 3, the function returns a vector of 3 float values from the address (<em>p</em> + (<em>offset</em> * 4)). The address computed as (<em>p</em> + (<em>offset</em> * 4)) must be 8-bytes aligned.<br />\nThis function uses the default rounding mode when converting <em>data</em> to a vector of half values. The default rounding mode is round to nearest even.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be (2 * compCountOf(data)) bytes aligned, when n = 2,4,8,16; For n = 3, the function returns a vector of 3 float values from the address (p + (offset * 4)). The address computed as (p + (offset * 4)) must be 8-bytes aligned.\nThis function uses the default rounding mode when converting data to a vector of half values. The default rounding mode is round to nearest even.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 180,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Vstorea_halfn_r",
          "OriginalName": "vstorea_halfn_r",
          "Description": "Converts <em>data</em> vector of float or vector of double values to a vector of half values and then write the converted value to the address (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>)) ), where compCountOf(<em>data</em>) is equal to the component count of the vector <em>data</em>.<br />\nThe address computed as (<em>p</em> + (<em>offset</em> * compCountOf(<em>data</em>))) must be (2 * compCountOf(<em>data</em>)) bytes aligned, when n = 2,4,8,16; For <em>n</em> = 3, the function returns a vector of 3 float values from the address (<em>p</em> + (<em>offset</em> * 4)). The address computed as (<em>p</em> + (<em>offset</em> * 4)) must be 8-bytes aligned.<br />\nThis function uses <em>mode</em> rounding mode when converting <em>data</em> to a vector of half values.\n<br />\n<em>offset</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>generic</em>) to <em>half</em>. <br />\n<em>data</em> must be  <em>vector(2,3,4,8,16)</em> of <em>float</em> or <em>double</em> values. <br />",
          "DescriptionPlain": "Converts data vector of float or vector of double values to a vector of half values and then write the converted value to the address (p + (offset * compCountOf(data)) ), where compCountOf(data) is equal to the component count of the vector data.\nThe address computed as (p + (offset * compCountOf(data))) must be (2 * compCountOf(data)) bytes aligned, when n = 2,4,8,16; For n = 3, the function returns a vector of 3 float values from the address (p + (offset * 4)). The address computed as (p + (offset * 4)) must be 8-bytes aligned.\nThis function uses mode rounding mode when converting data to a vector of half values.\n\noffset must be size_t. \nResult Type must be void. \np must be a pointer(generic) to half. \ndata must be  vector(2,3,4,8,16) of float or double values. ",
          "Category": "VectorDataLoadAndStoreInstructions",
          "Number": 181,
          "Operands": [
            {
              "Name": "data",
              "Tpe": "ID"
            },
            {
              "Name": "offset",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            },
            {
              "Name": "FP Rounding Mode\nmode",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Shuffle",
          "OriginalName": "shuffle",
          "Description": "Construct a permutation of components from <em>x</em> vector value, returning a vector value with the same component type as <em>x</em> and component component count that is the same as <em>shuffle mask</em>.<br />\nIn this function, only the <em>ilogb</em>(2 <em>m</em> -1) least significant bits of each mask element are considered, where <em>m</em> is equal to the component count of <em>x</em>.<br />\n<em>shuffle mask</em> operand specifies, for each component in the result vector, which component of <em>x</em> it gets.<br />\nThe size of each component in <em>shuffle mask</em> must match the size of each component in <em>Result Type</em>.<br />\n<em>Result Type</em> must have the same component type as <em>x</em> and component count as <em>shuffle mask</em>.\n<br />\n<em>shuffle mask</em> must be  <em>vector(2,4,8,16)</em> of <em>integer</em> values. <br />\n<em>Result Type</em> and <em>x</em> must be  <em>vector(2,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Construct a permutation of components from x vector value, returning a vector value with the same component type as x and component component count that is the same as shuffle mask.\nIn this function, only the ilogb(2 m -1) least significant bits of each mask element are considered, where m is equal to the component count of x.\nshuffle mask operand specifies, for each component in the result vector, which component of x it gets.\nThe size of each component in shuffle mask must match the size of each component in Result Type.\nResult Type must have the same component type as x and component count as shuffle mask.\n\nshuffle mask must be  vector(2,4,8,16) of integer values. \nResult Type and x must be  vector(2,4,8,16) of floating-point or integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MiscellaneousVectorInstructions",
          "Number": 182,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "shuffle mask",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Shuffle2",
          "OriginalName": "shuffle2",
          "Description": "Construct a permutation of components from <em>x</em> and <em>y</em> vector values, returning a vector value with the same component type as <em>x</em> and <em>y</em> and component count that is the same as <em>shuffle mask</em>.<br />\nIn this function, only the <em>ilogb</em>(2 <em>m</em> - 1) + 1 least significant bits of each mask component are considered, where <em>m</em> is equal to the component count of <em>x</em> and <em>y</em>.<br />\n<em>shuffle mask</em> operand specifies, for each component in the result vector, which component of <em>x</em> or <em>y</em> it gets. Where component count begins with <em>x</em> and then proceeds to <em>y</em>.<br />\n<em>x</em> and <em>y</em> must be of the same type.<br />\nThe size of each component in <em>shuffle mask</em> must match the size of each component in <em>Result Type</em>.<br />\n<em>Result Type</em> must have the same component type as <em>x</em> and component count as <em>shuffle mask</em>.\n<br />\n<em>shuffle mask</em> must be  <em>vector(2,4,8,16)</em> of <em>integer</em> values. <br />\n<em>Result Type</em>,<em>x</em> and <em>y</em> must be  <em>vector(2,4,8,16)</em> of <em>floating-point</em> or <em>integer</em> values. <br />\nAll of the operands, including the <em>Result Type</em> operand, must be of the same type.<br />",
          "DescriptionPlain": "Construct a permutation of components from x and y vector values, returning a vector value with the same component type as x and y and component count that is the same as shuffle mask.\nIn this function, only the ilogb(2 m - 1) + 1 least significant bits of each mask component are considered, where m is equal to the component count of x and y.\nshuffle mask operand specifies, for each component in the result vector, which component of x or y it gets. Where component count begins with x and then proceeds to y.\nx and y must be of the same type.\nThe size of each component in shuffle mask must match the size of each component in Result Type.\nResult Type must have the same component type as x and component count as shuffle mask.\n\nshuffle mask must be  vector(2,4,8,16) of integer values. \nResult Type,x and y must be  vector(2,4,8,16) of floating-point or integer values. \nAll of the operands, including the Result Type operand, must be of the same type.",
          "Category": "MiscellaneousVectorInstructions",
          "Number": 183,
          "Operands": [
            {
              "Name": "x",
              "Tpe": "ID"
            },
            {
              "Name": "y",
              "Tpe": "ID"
            },
            {
              "Name": "shuffle mask",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Printf",
          "OriginalName": "printf",
          "Description": "The <em>printf</em> extended instruction writes output to an implementation-defined stream such as stdout under control of the string pointed to by format that specifies how subsequent arguments are converted for output.  If there are insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.  The printf function returns when the end of the format string is encountered<br />\n<em>printf</em> returns 0 if it was executed successfully and -1 otherwise\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>format</em> must be <strong>OpString</strong>.<br />",
          "DescriptionPlain": "The printf extended instruction writes output to an implementation-defined stream such as stdout under control of the string pointed to by format that specifies how subsequent arguments are converted for output.  If there are insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.  The printf function returns when the end of the format string is encountered\nprintf returns 0 if it was executed successfully and -1 otherwise\n\nResult Type must be i32. \nformat must be OpString.",
          "Category": "MiscInstructions",
          "Number": 184,
          "Operands": [
            {
              "Name": "format",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Prefetch",
          "OriginalName": "prefetch",
          "Description": "Prefetch <em>num_elements</em> * size in bytes of the type pointed by <em>p</em>, into the global cache. The prefetch instruction is applied to a work-item in a work-group and does not affect the functional behavior of the kernel.\n<br />\n<em>num_elements</em> must be <em>size_t</em>. <br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>p</em> must be a <em>pointer</em>(<em>global</em>) to <em>floating-point</em>, <em>integer</em> or <em>vector(2,3,4,8,16)</em> of <em>floating-point</em>, <em>integer</em> values. <br />",
          "DescriptionPlain": "Prefetch num_elements * size in bytes of the type pointed by p, into the global cache. The prefetch instruction is applied to a work-item in a work-group and does not affect the functional behavior of the kernel.\n\nnum_elements must be size_t. \nResult Type must be void. \np must be a pointer(global) to floating-point, integer or vector(2,3,4,8,16) of floating-point, integer values. ",
          "Category": "MiscInstructions",
          "Number": 185,
          "Operands": [
            {
              "Name": "num_elements",
              "Tpe": "ID"
            },
            {
              "Name": "p",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef",
          "OriginalName": "read_imagef",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns floating-point values in the range [0.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to one of the pre-defined packed formats or <strong>UNORM INT8</strong>, or <strong>UNORM INT16</strong>. <br />\n<br />\nThis function returns floating-point values in the range[-1.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to <strong>SNORM INT8</strong>, or <strong>SNORM INT16</strong>.<br />\n<br />\nThis function returns floating-point values for <em>image</em> objects created with <em>channel data type</em> set to <strong>HALF FLOAT</strong>, or <strong>FLOAT</strong>.<br />\n<br />\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.<br />\n<br />\nValues returned by this function for image objects with <em>channel data type</em> which is not specified in the description above are undefined.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em>, <em>image2dMsaaDepth</em>, <em>image2dArrayMsaaDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>image2dDepth</em>, <em>image2dMsaa</em> or <em>image2dMsaaDepth</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dArrayMsaa</em> or <em>image2dArrayMsaaDepth</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />\n<em>Result Type</em> must be a <em>float</em> when <em>img</em> is a <em>image2dArrayDepth</em>, <em>image2dDepth</em>, <em>image2dMsaaDepth</em> or <em>image2dArrayMsaaDepth</em>, and  <em>vector(4)</em> of <em>float</em> values when <em>img</em> is on of the remaining valid image types for this instruction.",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns floating-point values in the range [0.0 &#8230; 1.0] for image objects created with channel data type set to one of the pre-defined packed formats or UNORM INT8, or UNORM INT16. \n\nThis function returns floating-point values in the range[-1.0 &#8230; 1.0] for image objects created with channel data type set to SNORM INT8, or SNORM INT16.\n\nThis function returns floating-point values for image objects created with channel data type set to HALF FLOAT, or FLOAT.\n\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nValues returned by this function for image objects with channel data type which is not specified in the description above are undefined.\n\nResult Type must be float or vector(4) of float values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth, image2dMsaa, image2dArrayMsaa, image2dMsaaDepth, image2dArrayMsaaDepth or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, image2dDepth, image2dMsaa or image2dMsaaDepth, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, image2dArrayDepth, image2dArrayMsaa or image2dArrayMsaaDepth, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.\nResult Type must be a float when img is a image2dArrayDepth, image2dDepth, image2dMsaaDepth or image2dArrayMsaaDepth, and  vector(4) of float values when img is on of the remaining valid image types for this instruction.",
          "Category": "ImageReadFunctions",
          "Number": 111,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei",
          "OriginalName": "read_imagei",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns a non-parametric <em>i32</em> integer value.<br />\n<br />\nThis function can only be used if <em>img</em> image object <em>channel data type</em> is set to <strong>SIGNED INT8</strong>, <strong>SIGNED INT16</strong> or <strong>SIGNED INT32</strong>. If the <em>channel data type</em> is not one of these values, the values returned by read_imagei are undefined.<br />\n<br />\nThe sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>image2dDepth</em>, <em>image2dMsaa</em> or <em>image2dMsaaDepth</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dArrayMsaa</em> or <em>image2dArrayMsaaDepth</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns a non-parametric i32 integer value.\n\nThis function can only be used if img image object channel data type is set to SIGNED INT8, SIGNED INT16 or SIGNED INT32. If the channel data type is not one of these values, the values returned by read_imagei are undefined.\n\nThe sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dMsaa, image2dArrayMsaa or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, image2dDepth, image2dMsaa or image2dMsaaDepth, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, image2dArrayDepth, image2dArrayMsaa or image2dArrayMsaaDepth, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.",
          "Category": "ImageReadFunctions",
          "Number": 112,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui",
          "OriginalName": "read_imageui",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns a non-parametric <em>i32</em> integer value.<br />\n<br />\nThis function can only be used if <em>img</em> image object <em>channel data type</em> is set to <strong>UNSIGNED INT8</strong>, <strong>UNSIGNED INT16</strong> or <strong>UNSIGNED INT32</strong>. If the <em>channel data type</em> is not one of these values, the values returned by read_imagei are undefined.<br />\n<br />\nThe sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>image2dDepth</em>, <em>image2dMsaa</em> or <em>image2dMsaaDepth</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dArrayMsaa</em> or <em>image2dArrayMsaaDepth</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns a non-parametric i32 integer value.\n\nThis function can only be used if img image object channel data type is set to UNSIGNED INT8, UNSIGNED INT16 or UNSIGNED INT32. If the channel data type is not one of these values, the values returned by read_imagei are undefined.\n\nThe sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dMsaa, image2dArrayMsaa or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, image2dDepth, image2dMsaa or image2dMsaaDepth, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, image2dArrayDepth, image2dArrayMsaa or image2dArrayMsaaDepth, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.",
          "Category": "ImageReadFunctions",
          "Number": 113,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageh",
          "OriginalName": "read_imageh",
          "Description": "Use the coordinate specified by <em>coords</em> and the <em>sampler</em> object specified by <em>s</em> to do an element lookup to the image object specified by <em>img</em>.<br />\n<br />\nThis function returns half precision floating-point values in the range [0.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to one of the pre-defined packed formats or <strong>UNORM INT8</strong>, or <strong>UNORM INT16</strong>. <br />\n<br />\nThis function returns half precision floating-point values in the range[-1.0 &#8230; 1.0] for <em>image</em> objects created with <em>channel data type</em> set to <strong>SNORM INT8</strong>, or <strong>SNORM INT16</strong>.<br />\n<br />\nThis function returns half precision floating-point values for <em>image</em> objects created with <em>channel data type</em> set to <strong>HALF FLOAT</strong>, or <strong>FLOAT</strong>.<br />\n<br />\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to <strong>Nearest</strong>, coordinates set to non-parametric coordinates and addressing mode set to <strong>ClampToEdge</strong>, <strong>Clamp</strong> or <strong>None</strong>; otherwise the values returned are undefined.<br />\n<br />\nValues returned by this function for image objects with <em>channel data type</em> which is not specified in the description above are undefined.\n<br />\n<em>Result Type</em> must be <em>half</em> or <em>vector(4)</em> of <em>half</em> values. <br />\n<em>coords</em> must be <em>float</em> or <em>i32</em> or <em>vector(2,4)</em> of <em>float</em> or <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\nWhen <em>img</em> is a <em>image1d</em>, <em>coords</em> must be <em>float</em> or <em>i32</em>. <br />\nWhen <em>img</em> is a <em>image2d</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>float</em> or <em>i32</em> values.<br />\nWhen <em>img</em> is a <em>image1dArray</em>, <em>coords</em> must be  <em>vector(2)</em> of <em>i32</em> values. The second component of <em>coords</em> is used to identify the image in the array<br />\nWhen <em>img</em> is a <em>image2dArray</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>i32</em> values. The third component of <em>coords</em> is used to identify the image in the array, while the fourth component is ignored.<br />\nWhen <em>img</em> is a <em>image3d</em>, <em>coords</em> must be  <em>vector(4)</em> of <em>float</em> or <em>i32</em> values. The fourth component of <em>coords</em> is ignored.<br />\n<em>Result Type</em> must be a <em>half</em> when <em>img</em> is a <em>image2dArrayDepth</em>, <em>image2dDepth</em>, <em>image2dMsaaDepth</em> or <em>image2dArrayMsaaDepth</em>, and  <em>vector(4)</em> of <em>half</em> values when <em>img</em> is on of the remaining valid image types for this instruction.",
          "DescriptionPlain": "Use the coordinate specified by coords and the sampler object specified by s to do an element lookup to the image object specified by img.\n\nThis function returns half precision floating-point values in the range [0.0 &#8230; 1.0] for image objects created with channel data type set to one of the pre-defined packed formats or UNORM INT8, or UNORM INT16. \n\nThis function returns half precision floating-point values in the range[-1.0 &#8230; 1.0] for image objects created with channel data type set to SNORM INT8, or SNORM INT16.\n\nThis function returns half precision floating-point values for image objects created with channel data type set to HALF FLOAT, or FLOAT.\n\nWhen called with i32 coordinates the sampler object must be defined with a filter mode set to Nearest, coordinates set to non-parametric coordinates and addressing mode set to ClampToEdge, Clamp or None; otherwise the values returned are undefined.\n\nValues returned by this function for image objects with channel data type which is not specified in the description above are undefined.\n\nResult Type must be half or vector(4) of half values. \ncoords must be float or i32 or vector(2,4) of float or i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\nWhen img is a image1d, coords must be float or i32. \nWhen img is a image2d, coords must be  vector(2) of float or i32 values.\nWhen img is a image1dArray, coords must be  vector(2) of i32 values. The second component of coords is used to identify the image in the array\nWhen img is a image2dArray, coords must be  vector(4) of i32 values. The third component of coords is used to identify the image in the array, while the fourth component is ignored.\nWhen img is a image3d, coords must be  vector(4) of float or i32 values. The fourth component of coords is ignored.\nResult Type must be a half when img is a image2dArrayDepth, image2dDepth, image2dMsaaDepth or image2dArrayMsaaDepth, and  vector(4) of half values when img is on of the remaining valid image types for this instruction.",
          "Category": "ImageReadFunctions",
          "Number": 114,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef_samplerless",
          "OriginalName": "read_imagef_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imagef function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imagef function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be float or vector(4) of float values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 115,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei_samplerless",
          "OriginalName": "read_imagei_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imagei function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dMsaa</em>, <em>image2dArrayMsaa</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imagei function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dMsaa, image2dArrayMsaa or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 116,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui_samplerless",
          "OriginalName": "read_imageui_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imageui function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imageui function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be  vector(4) of i32 values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 117,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageh_samplerless",
          "OriginalName": "read_imageh_samplerless",
          "Description": "Use the coordinate specified by <em>coords</em> to do an element lookup to the image object specified by <em>img</em>. This function behaves exactly as the corresponding read_imageh function that take integer coordinates and a sampler with filter mode set to <strong>Nearest</strong>, non-parametric coordinates and addressing mode set to <strong>None</strong>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>half</em> values. <br />\n<em>coords</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Use the coordinate specified by coords to do an element lookup to the image object specified by img. This function behaves exactly as the corresponding read_imageh function that take integer coordinates and a sampler with filter mode set to Nearest, non-parametric coordinates and addressing mode set to None.\n\nResult Type must be  vector(4) of half values. \ncoords must be i32 or vector(2,4) of i32 values. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.",
          "Category": "ImageReadFunctions",
          "Number": 118,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef_mipmap_lod",
          "OriginalName": "read_imagef_mipmap_lod",
          "Description": "Use the coordinate specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the mip-level specified by <em>lod</em> in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\n<em>lod</em> is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>Result Type</em> must be a <em>float</em>.",
          "DescriptionPlain": "Use the coordinate specified by coords, and the sampler object specified by s to do an element lookup in the mip-level specified by lod in the image object specified by img.\n\nResult Type must be float or vector(4) of float values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nlod is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- Result Type must be a float.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- Result Type must be a float.",
          "Category": "ImageReadFunctions",
          "Number": 123,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei_mipmap_lod",
          "OriginalName": "read_imagei_mipmap_lod",
          "Description": "Use the coordinate specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the mip-level specified by <em>lod</em> in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\n<em>lod</em> is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>lod</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />",
          "DescriptionPlain": "Use the coordinate specified by coords, and the sampler object specified by s to do an element lookup in the mip-level specified by lod in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nlod is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- lod must be a float.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n\nWhen img type is image1d:\n- coords must be a float. \n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. ",
          "Category": "ImageReadFunctions",
          "Number": 124,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui_mipmap_lod",
          "OriginalName": "read_imageui_mipmap_lod",
          "Description": "Use the coordinate specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the mip-level specified by <em>lod</em> in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\n<em>lod</em> is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />",
          "DescriptionPlain": "Use the coordinate specified by coords, and the sampler object specified by s to do an element lookup in the mip-level specified by lod in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nlod is clamped to the minimum of (actual number of mip-levels - 1) in the image or value specified for CL_SAMPLER_LOD_MAX.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n\nWhen img type is image1d:\n- coords must be a float. \n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. ",
          "Category": "ImageReadFunctions",
          "Number": 125,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagef_mipmap_gradient",
          "OriginalName": "read_imagef_mipmap_gradient",
          "Description": "Use the gradients <em>grad_x</em> and <em>grad_y</em>, the coordinates specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the computed mip-level in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>float</em> or <em>vector(4)</em> of <em>float</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n- <em>Result Type</em> must be a <em>float</em>.",
          "DescriptionPlain": "Use the gradients grad_x and grad_y, the coordinates specified by coords, and the sampler object specified by s to do an element lookup in the computed mip-level in the image object specified by img.\n\nResult Type must be float or vector(4) of float values. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- grad_x and grad_y must be a float.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a float.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(4) of float values.\n- Result Type must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a float.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n- Result Type must be a float.",
          "Category": "ImageReadFunctions",
          "Number": 126,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "grad_x",
              "Tpe": "ID"
            },
            {
              "Name": "grad_y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imagei_mipmap_gradient",
          "OriginalName": "read_imagei_mipmap_gradient",
          "Description": "Use the gradients <em>grad_x</em> and <em>grad_y</em>, the coordinates specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the computed mip-level in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.",
          "DescriptionPlain": "Use the gradients grad_x and grad_y, the coordinates specified by coords, and the sampler object specified by s to do an element lookup in the computed mip-level in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- grad_x and grad_y must be a float.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a float.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.",
          "Category": "ImageReadFunctions",
          "Number": 127,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "grad_x",
              "Tpe": "ID"
            },
            {
              "Name": "grad_y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Read_imageui_mipmap_gradient",
          "OriginalName": "read_imageui_mipmap_gradient",
          "Description": "Use the gradients <em>grad_x</em> and <em>grad_y</em>, the coordinates specified by <em>coords</em>, and the sampler object specified by <em>s</em> to do an element lookup in the computed mip-level in the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be  <em>vector(4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with ReadOnly or ReadWrite access qualifier.<br />\n<em>s</em> must be <em>sampler</em> value.<br />\n<em>s</em> must be set to use parametric coordinates.<br />\nWhen <em>img</em> type is <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image1d</em>:<br />\n- <em>coords</em> must be a <em>float</em>. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a <em>float</em>.<br />\n<br />\nWhen <em>img</em> type is <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> type is <em>image2dArrayDepth</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>float</em> values. <br />\n- <em>grad_x</em> and <em>grad_y</em> must be a  <em>vector(2)</em> of <em>float</em> values.",
          "DescriptionPlain": "Use the gradients grad_x and grad_y, the coordinates specified by coords, and the sampler object specified by s to do an element lookup in the computed mip-level in the image object specified by img.\n\nResult Type must be  vector(4) of i32 values. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with ReadOnly or ReadWrite access qualifier.\ns must be sampler value.\ns must be set to use parametric coordinates.\nWhen img type is image2d:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArray:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image1d:\n- coords must be a float. \n- grad_x and grad_y must be a float.\n\nWhen img type is image1dArray:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a float.\n\nWhen img type is image3d:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(4) of float values.\n\nWhen img type is image2dDepth:\n- coords must be a  vector(2) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.\n\nWhen img type is image2dArrayDepth:\n- coords must be a  vector(4) of float values. \n- grad_x and grad_y must be a  vector(2) of float values.",
          "Category": "ImageReadFunctions",
          "Number": 128,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "s",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "grad_x",
              "Tpe": "ID"
            },
            {
              "Name": "grad_y",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagef",
          "OriginalName": "write_imagef",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image2dDepth</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM INT16</strong>, <strong>UNORM INT24</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArrayDepth</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM INT16</strong>, <strong>UNORM INT24</strong>, <strong>FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>, <strong>FLOAT</strong>.  <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with WriteOnly or ReadWrite access qualifier.\nWhen img is a image2d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value is a  vector(4) of float values.\n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a i32, and is in the range (0 &#8230; image width - 1)\n- value is a  vector(4) of float values.\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value is a  vector(4) of float values\n\nWhen img is a image2dDepth, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM INT16, UNORM INT24, FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value is a float.\n\nWhen img is a image2dArrayDepth, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM INT16, UNORM INT24, FLOAT. \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a float.\n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT, FLOAT.  \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.",
          "Category": "ImageWriteFunctions",
          "Number": 119,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagei",
          "OriginalName": "write_imagei",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>. <em>value</em> component type is considered to be a signed integer. <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe <em>channel data type</em> of <em>img</em> must be set to <strong>SIGNED INT8</strong>, <strong>SIGNED INT16</strong>, <strong>SIGNED INT32</strong>. <br />\nWhen <em>img</em> is a <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>:<br />\n- <em>coords</em> must be a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type. value component type is considered to be a signed integer. coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe channel data type of img must be set to SIGNED INT8, SIGNED INT16, SIGNED INT32. \nWhen img is a image2d:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value must be a  vector(4) of i32 values.\n\nWhen img is a image2dArray:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1d or image1dBuffer:\n- coords must be a i32, and is in the range (0 &#8230; image width - 1)\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1dArray:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value must be a  vector(4) of i32 values\n\nWhen img is a image3d:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.",
          "Category": "ImageWriteFunctions",
          "Number": 120,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imageui",
          "OriginalName": "write_imageui",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>. <em>value</em> component type is considered to be an unsigned integer. <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe <em>channel data type</em> of <em>img</em> must be set to <strong>UNSIGNED INT8</strong>, <strong>UNSIGNED INT16</strong>, <strong>UNSIGNED INT32</strong>. <br />\nWhen <em>img</em> is a <em>image2d</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>:<br />\n- <em>coords</em> must be a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>:<br />\n- <em>coords</em> must be a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>:<br />\n- <em>coords</em> must be a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> must be a  <em>vector(4)</em> of <em>i32</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type. value component type is considered to be an unsigned integer. coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe channel data type of img must be set to UNSIGNED INT8, UNSIGNED INT16, UNSIGNED INT32. \nWhen img is a image2d:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value must be a  vector(4) of i32 values.\n\nWhen img is a image2dArray:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1d or image1dBuffer:\n- coords must be a i32, and is in the range (0 &#8230; image width - 1)\n- value must be a  vector(4) of i32 values.\n\nWhen img is a image1dArray:\n- coords must be a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value must be a  vector(4) of i32 values\n\nWhen img is a image3d:\n- coords must be a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value must be a  vector(4) of i32 values.",
          "Category": "ImageWriteFunctions",
          "Number": 121,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imageh",
          "OriginalName": "write_imageh",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width - 1)<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>. <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- The <em>channel data type</em> of <em>img</em> is set to <strong>UNORM SHORT 565</strong>,<strong>UNORM SHORT 555</strong>, <strong>UNORM INT 101010</strong>, <strong>UNORM INT8</strong>, <strong>SNORM INT8</strong>, <strong>UNORM INT16</strong>, <strong>SNORM INT16</strong>,  <strong>HALF FLOAT</strong>.  <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>half</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nWhen img is a image2d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1) respectively. \n- value is a  vector(4) of half values.\n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of half values.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a i32, and is in the range (0 &#8230; image width - 1)\n- value is a  vector(4) of half values.\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT. \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width - 1), (0 &#8230; image number of layers - 1) respectively. \n- value is a  vector(4) of half values\n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- The channel data type of img is set to UNORM SHORT 565,UNORM SHORT 555, UNORM INT 101010, UNORM INT8, SNORM INT8, UNORM INT16, SNORM INT16,  HALF FLOAT.  \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width - 1), (0 &#8230; image height - 1), (0 &#8230; image depth - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of half values.",
          "Category": "ImageWriteFunctions",
          "Number": 122,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagef_mipmap_lod",
          "OriginalName": "write_imagef_mipmap_lod",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> in the mip-level specified by <em>lod</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe behavior of the function is undefined unless <em>lod</em> value is in the range (0 &#8230; number of mip-levels in the image - 1).<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height  of the mip-level specified by <em>lod</em> - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1)<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.<br />\n<br />\nWhen <em>img</em> is a <em>image2dDepth</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width  of the mip-level specified by <em>lod</em>- 1), (0 &#8230; image height of the mip-level specified by <em>lod</em>- 1) respectively. <br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image2dArrayDepth</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip - level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a <em>float</em>.<br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image depth of the mip-level specified by <em>lod</em> - 1) respectively. The fourth component is ignored.<br />\n- <em>value</em> is a  <em>vector(4)</em> of <em>float</em> values.",
          "DescriptionPlain": "Write value to the coordinates specified by coords in the mip-level specified by lod to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates.\n\nResult Type must be void. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe behavior of the function is undefined unless lod value is in the range (0 &#8230; number of mip-levels in the image - 1).\nWhen img is a image2d, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height  of the mip-level specified by lod - 1) respectively. \n- value is a  vector(4) of float values.\n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- coords is a i32, and is in the range (0 &#8230; image width of the mip-level specified by lod - 1)\n- value is a  vector(4) of float values.\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. \n- value is a  vector(4) of float values.\n\nWhen img is a image2dDepth, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width  of the mip-level specified by lod- 1), (0 &#8230; image height of the mip-level specified by lod- 1) respectively. \n- value is a float.\n\nWhen img is a image2dArrayDepth, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip - level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n- value is a float.\n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image depth of the mip-level specified by lod - 1) respectively. The fourth component is ignored.\n- value is a  vector(4) of float values.",
          "Category": "ImageWriteFunctions",
          "Number": 129,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imagei_mipmap_lod",
          "OriginalName": "write_imagei_mipmap_lod",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> in the mip-level specified by <em>lod</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates. <em>value</em> component type is treated as signed integer.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe behavior of the function is undefined unless <em>lod</em> value is in the range (0 &#8230; number of mip-levels in the image - 1).<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height  of the mip-level specified by <em>lod</em> - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1)<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image depth of the mip-level specified by <em>lod</em> - 1) respectively. The fourth component is ignored.<br />",
          "DescriptionPlain": "Write value to the coordinates specified by coords in the mip-level specified by lod to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates. value component type is treated as signed integer.\n\nResult Type must be void. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe behavior of the function is undefined unless lod value is in the range (0 &#8230; number of mip-levels in the image - 1).\nWhen img is a image2d, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height  of the mip-level specified by lod - 1) respectively. \n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- coords is a i32, and is in the range (0 &#8230; image width of the mip-level specified by lod - 1)\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. \n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image depth of the mip-level specified by lod - 1) respectively. The fourth component is ignored.",
          "Category": "ImageWriteFunctions",
          "Number": 130,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Write_imageui_mipmap_lod",
          "OriginalName": "write_imageui_mipmap_lod",
          "Description": "Write <em>value</em> to the coordinates specified by <em>coords</em> in the mip-level specified by <em>lod</em> to the image object specified by <em>img</em>. The write happens only after the data in <em>value</em> is converted to the appropraite <em>img</em> image <em>channel data type</em>.  <em>coords</em> are considered to be non-parametric coordinates. <em>value</em> component type is treated as unsigned integer.\n<br />\n<em>Result Type</em> must be <em>void</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em> or <em>image3d</em> value, with WriteOnly or ReadWrite access qualifier.<br />\nThe behavior of the function is undefined unless <em>lod</em> value is in the range (0 &#8230; number of mip-levels in the image - 1).<br />\nWhen <em>img</em> is a <em>image2d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height  of the mip-level specified by <em>lod</em> - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image2dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.<br />\n<br />\nWhen <em>img</em> is a <em>image1d</em> or <em>image1dBuffer</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a <em>i32</em>, and is in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1)<br />\n<br />\nWhen <em>img</em> is a <em>image1dArray</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(2)</em> of <em>i32</em> values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image number of layers - 1) respectively. <br />\n<br />\nWhen <em>img</em> is a <em>image3d</em>, the behavior of the function is undefined unless: <br />\n- <em>coords</em> is a  <em>vector(4)</em> of <em>i32</em> values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image height of the mip-level specified by <em>lod</em> - 1), (0 &#8230; image depth of the mip-level specified by <em>lod</em> - 1) respectively. The fourth component is ignored.",
          "DescriptionPlain": "Write value to the coordinates specified by coords in the mip-level specified by lod to the image object specified by img. The write happens only after the data in value is converted to the appropraite img image channel data type.  coords are considered to be non-parametric coordinates. value component type is treated as unsigned integer.\n\nResult Type must be void. \nimg must be image1d, image1dArray, image2d, image2dArray or image3d value, with WriteOnly or ReadWrite access qualifier.\nThe behavior of the function is undefined unless lod value is in the range (0 &#8230; number of mip-levels in the image - 1).\nWhen img is a image2d, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height  of the mip-level specified by lod - 1) respectively. \n\nWhen img is a image2dArray, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. The fourth component is ignored.\n\nWhen img is a image1d or image1dBuffer, the behavior of the function is undefined unless: \n- coords is a i32, and is in the range (0 &#8230; image width of the mip-level specified by lod - 1)\n\nWhen img is a image1dArray, the behavior of the function is undefined unless: \n- coords is a  vector(2) of i32 values, where the first and second components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image number of layers - 1) respectively. \n\nWhen img is a image3d, the behavior of the function is undefined unless: \n- coords is a  vector(4) of i32 values, where the first, second and third components are in the range (0 &#8230; image width of the mip-level specified by lod - 1), (0 &#8230; image height of the mip-level specified by lod - 1), (0 &#8230; image depth of the mip-level specified by lod - 1) respectively. The fourth component is ignored.",
          "Category": "ImageWriteFunctions",
          "Number": 131,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "coords",
              "Tpe": "ID"
            },
            {
              "Name": "lod",
              "Tpe": "ID"
            },
            {
              "Name": "value",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_width",
          "OriginalName": "get_image_width",
          "Description": "Return the width in pixels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the width in pixels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 132,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_height",
          "OriginalName": "get_image_height",
          "Description": "Return the height in pixels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the height in pixels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 133,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_depth",
          "OriginalName": "get_image_depth",
          "Description": "Return the depth in pixels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the depth in pixels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 134,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_channel_data_type",
          "OriginalName": "get_image_channel_data_type",
          "Description": "Return the <em>channel data type</em> of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>Result Type</em> must contain a value from <a href=\"#ImageChannelType\"><strong>ImageChannelType</strong></a> enumeration.",
          "DescriptionPlain": "Return the channel data type of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nResult Type must contain a value from ImageChannelType enumeration.",
          "Category": "ImageQueryFunctions",
          "Number": 135,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_channel_order",
          "OriginalName": "get_image_channel_order",
          "Description": "Return the <em>channel order</em> of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dBuffer</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>Result Type</em> must contain a value from <a href=\"#ImageChannelOrder\"><strong>ImageChannelOrder</strong></a> enumeration.",
          "DescriptionPlain": "Return the channel order of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dBuffer, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nResult Type must contain a value from ImageChannelOrder enumeration.",
          "Category": "ImageQueryFunctions",
          "Number": 136,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_dim",
          "OriginalName": "get_image_dim",
          "Description": "Return the dimensions of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em> or <em>vector(2,4)</em> of <em>i32</em> values. <br />\n<em>img</em> must be <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>Result Type&#8217;must be  'vector(2)</em> of <em>i32</em> values when <em>img</em> is a <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em> or <em>image2dDepth</em>. The width and height of the image are contained in the first and second components of the return value repectively.<br />\n<em>Result Type&#8217;must be  'vector(4)</em> of <em>i32</em> values when <em>img</em> is a <em>image3d</em>. The width, height and depth of the image are contained in the first, second and third components of the return value repectively. The fourth component is 0.<br />",
          "DescriptionPlain": "Return the dimensions of the image object specified by img.\n\nResult Type must be i32 or vector(2,4) of i32 values. \nimg must be image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nResult Type&#8217;must be  'vector(2) of i32 values when img is a image2d, image2dArray, image2dArrayDepth or image2dDepth. The width and height of the image are contained in the first and second components of the return value repectively.\nResult Type&#8217;must be  'vector(4) of i32 values when img is a image3d. The width, height and depth of the image are contained in the first, second and third components of the return value repectively. The fourth component is 0.",
          "Category": "ImageQueryFunctions",
          "Number": 137,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_array_size",
          "OriginalName": "get_image_array_size",
          "Description": "Return the number of samples in the MSAA image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>Result Type</em> must be <em>size_t</em>. <br />\n<em>img</em> must be <em>image1dArray</em>, <em>image2dArray</em> or <em>image2dArrayDepth</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />\n<em>img</em> must be <em>image2dMsaa</em>, <em>image2dArrayMsaa</em>, <em>image2dMsaaDepth</em> or <em>image2dArrayMsaaDepth</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the number of samples in the MSAA image object specified by img.\n\nResult Type must be i32. \nResult Type must be size_t. \nimg must be image1dArray, image2dArray or image2dArrayDepth value, with ReadOnly, WriteOnly or ReadWrite access qualifier.\nimg must be image2dMsaa, image2dArrayMsaa, image2dMsaaDepth or image2dArrayMsaaDepth value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 138,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            },
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        },
        {
          "Name": "Get_image_num_mip_levels",
          "OriginalName": "get_image_num_mip_levels",
          "Description": "Return the number of mip-levels of the image object specified by <em>img</em>.\n<br />\n<em>Result Type</em> must be <em>i32</em>. <br />\n<em>img</em> must be <em>image1d</em>, <em>image1dArray</em>, <em>image2d</em>, <em>image2dArray</em>, <em>image2dArrayDepth</em>, <em>image2dDepth</em> or <em>image3d</em> value, with ReadOnly, WriteOnly or ReadWrite access qualifier.<br />",
          "DescriptionPlain": "Return the number of mip-levels of the image object specified by img.\n\nResult Type must be i32. \nimg must be image1d, image1dArray, image2d, image2dArray, image2dArrayDepth, image2dDepth or image3d value, with ReadOnly, WriteOnly or ReadWrite access qualifier.",
          "Category": "ImageQueryFunctions",
          "Number": 140,
          "Operands": [
            {
              "Name": "img",
              "Tpe": "ID"
            }
          ]
        }
      ],
      "Enums": [
        {
          "Name": "ImageChannelOrder",
          "Values": [
            {
              "Value": 4272,
              "Name": "R"
            },
            {
              "Value": 4273,
              "Name": "A"
            },
            {
              "Value": 4274,
              "Name": "RG"
            },
            {
              "Value": 4275,
              "Name": "RA"
            },
            {
              "Value": 4276,
              "Name": "RGB"
            },
            {
              "Value": 4277,
              "Name": "RGBA"
            },
            {
              "Value": 4278,
              "Name": "BGRA"
            },
            {
              "Value": 4279,
              "Name": "ARGB"
            },
            {
              "Value": 4280,
              "Name": "INTENSITY"
            },
            {
              "Value": 4281,
              "Name": "LUMINANCE"
            },
            {
              "Value": 4282,
              "Name": "Rx"
            },
            {
              "Value": 4283,
              "Name": "RGx"
            },
            {
              "Value": 4284,
              "Name": "RGBx"
            },
            {
              "Value": 4285,
              "Name": "DEPTH"
            },
            {
              "Value": 4286,
              "Name": "DEPTH STENCIL"
            },
            {
              "Value": 4287,
              "Name": "sRGB"
            },
            {
              "Value": 4288,
              "Name": "sRGBx"
            },
            {
              "Value": 4289,
              "Name": "sRGBA"
            },
            {
              "Value": 4290,
              "Name": "sBGRA"
            }
          ]
        },
        {
          "Name": "ImageChannelType",
          "Values": [
            {
              "Value": 4304,
              "Name": "SNORM INT8"
            },
            {
              "Value": 4305,
              "Name": "SNORM INT16"
            },
            {
              "Value": 4306,
              "Name": "UNORM INT8"
            },
            {
              "Value": 4307,
              "Name": "UNORM_INT16"
            },
            {
              "Value": 4308,
              "Name": "UNORM SHORT 565"
            },
            {
              "Value": 4309,
              "Name": "UNORM SHORT 555"
            },
            {
              "Value": 4310,
              "Name": "UNORM INT 101010"
            },
            {
              "Value": 4311,
              "Name": "SIGNED INT8"
            },
            {
              "Value": 4312,
              "Name": "SIGNED INT16"
            },
            {
              "Value": 4313,
              "Name": "SIGNED INT32"
            },
            {
              "Value": 4314,
              "Name": "UNSIGNED INT8"
            },
            {
              "Value": 4315,
              "Name": "UNSIGNED INT16"
            },
            {
              "Value": 4316,
              "Name": "UNSIGNED INT32"
            },
            {
              "Value": 4317,
              "Name": "HALF FLOAT"
            },
            {
              "Value": 4318,
              "Name": "FLOAT"
            },
            {
              "Value": 4319,
              "Name": "UNORM INT24"
            }
          ]
        }
      ]
    }
  ]
}